# create Makefile from this file with configure script
##### User configurable options #####
ALL: mpi
LARCH       = @ARCH@
DEVICE      = @DEVICE@
COMM        = @COMM@
MPIR_HOME   = @MPIR_HOME@
INCLUDE_DIR = @INCLUDE_PATH@ -Impid/@DEVICE@ -Iinclude
PREFIX	    = @PREFIX@
MAKE        = @MAKE@
CPRP        = @CPRP@
RSHCOMMAND  = @RSHCOMMAND@
DEFAULT_MACHINE = @DEFAULT_MACHINE@
ROMIO       = @ROMIO@
BUILDCPP    = @buildcpp@
NOF77	    = @NOF77@
NOMPE       = @NOMPE@
### End User configurable options ###

SHELL = /bin/sh

@VPATH@

MPIDIRS  = src/pt2pt src/env src/dmpi src/util src/context src/coll \
	   src/topol src/profile 
MPI2DIRS = src/misc2 src/external
DIRS     = $(MPIDIRS) $(MPI2DIRS) mpid/$(DEVICE) \
	   examples examples/basic examples/test/pt2pt examples/test/coll \
	   examples/test/topol examples/test/context \
	   examples/test/env examples/test/profile examples/test \
	   examples/perftest src/infoexport
# 
# This is a list of the devices that are available
DEVICES  = mpid/ch2 \
	   mpid/ch_nx mpid/ch_p4 mpid/ch_p4mpd \
	   mpid/ch_mpl mpid/t3e mpid/ch_meiko mpid/ch_shmem \
	   mpid/globus mpid/ch_lfshmem \
	   mpid/ch_cenju3
# Change this in maint/maketar also
OTHERDEVICES  = mpid/ch_nx mpid/ch_p4 mpid/ch_p4mpd mpid/ch_mpl \
		mpid/ch_meiko mpid/ch_shmem mpid/ch_lfshmem mpid/t3e \
		mpid/globus mpid/ch_cenju3

# Installation directories
prefix           = @prefix@
bindir           = @bindir@
includedir       = @includedir@
libdir           = @libdir@
# Build directories
libbuild_dir     = @libbuild_dir@
binbuild_dir     = @binbuild_dir@
includebuild_dir = @includebuild_dir@
top_srcdir       = @top_srcdir@
srcdir           = @srcdir@

# 
# Build the device FIRST in case the device include, used in mpiimpl.h, 
# needs to be built (e.g., ch_p4 device)
# We need MPI2DIRS for the Fortran interface, among other things
CODEDIRS = mpid/$(DEVICE) $(MPIDIRS) $(MPI2DIRS) 

#
# The order here was chosen to identify problems early in the build
# In particular, we try a linktest as soon as the libraries are available,
# with a second link test after the profiling libraries are built just to
# be sure that they still succeed.  There are "make clean"s around the 
# whole thing so that there is reduced danger of finding the "wrong" 
# object files .
#
# Notes on C++ interface:
# This is still incomplete.  In particular, there are a LOT of include
# files, including one name "config.h" in the C++ interface.  The
# C++ library is named libmpi++.a .
#	${top_srcdir}/makelinks
mpi: mkbuilddirs preinstall clean rmlib
	$(MAKE) mpilib
	$(MAKE) mpiflib
	$(MAKE) clean
	$(MAKE) profile
	$(MAKE) mpelib        
	@if [ $(ROMIO) = 1 -a -d romio ] ; then \
	    echo "making romio" ;  \
            (cd romio ; $(MAKE) )    \
        fi
	@-if [ $(BUILDCPP) = 1 -a -d MPI-2-C++ ] ; then \
            echo "making C++ interface" ; \
	    $(MAKE) cpplib ; \
	fi
	@-if [ -s f90modules/Makefile -a -n "@F90MODINC@" ] ; then \
	    echo "making Fortran 90 module for MPI" ; \
	    (cd f90modules ; $(MAKE) ) ;\
	fi
	$(MAKE) profileliblink
	@echo "Testing that MPI applications can be linked..."
	$(MAKE) linktest
	$(MAKE) mpichsharelibs
	$(MAKE) clean
	@if [ $(DEVICE) = "ch_p4" ] ; then \
	    echo '--->' ; \
	    echo "You may want to do" ; \
	    echo "    $(MAKE) serv_p4" ; \
	    echo "as well." ; \
	    echo '---<' ; \
	fi
	/bin/rm -f ${binbuild_dir}/mpirun
	if [ ${DEVICE} = "ch_p4mpd" ] ; then \
	    ${MAKE} mpirun_chp4mpd ; \
	else \
	    ${MAKE} mpirun ; \
	fi    
	if [ ${DEVICE} = "ch_p4" ] ; then ${MAKE} tstmachines ; fi
	/bin/rm -f ${binbuild_dir}/mpireconfig
	$(MAKE) mpireconfig
	$(MAKE) mpiman
	$(MAKE) ./bin/mpiinstall
	@echo '--->'
	@echo "Completed build of MPI.  Check the output for errors"
	@echo "Also try executing 'make testing' in examples/test"
	@echo "(This relies on mpirun, which currently works for many"
	@echo "but not all systems.  mpirun requires that you first"
	@echo "setup the util/machines/machines.$(LARCH) file for the"
	@echo "ch_p4 device.  Other devices do not need that file)."
	@echo " "
	@echo "Send bugs and comments to mpi-bugs@mcs.anl.gov"
	@echo "With any bug report, please send"
	@echo "     The version of MPICH (e.g., 1.1.1)"
	@echo " "
	@echo "The output of running your program with the -mpiversion argument"
	@echo "(e.g., mpirun -np 1 a.out -mpiversion)"
	@echo " "
	@echo "The output of "
	@echo "        uname -a"
	@echo "for your system.  If you are on an SGI system, also"
	@echo "	       hinv"
	@echo " "
	@echo "If the problem is with a script like configure or mpirun, run the"
	@echo "script with the -echo argument "
	@echo "(e.g., mpirun -echo -np 4 a.out )"
	@echo " "
	@echo "If you are using a network of workstations, also send the output of"
	@echo "${binbuild_dir}/tstmachines."
	@echo '---<'

examples: ${binbuild_dir}/mpirun
	( cd examples ; $(MAKE) default )

# 
# This is an experimental target.  We do only the libraries that we know 
# about.
# Note that we do *not* include the Fortran MPI_Init and its support 
# routines in the (C) shared libraries.  This is required for the Solaris
# shared libraries; if these files are not excluded, then the application
# will fail to link (even though no code even *references* the routines that 
# are used)!
#
# You will probably need to add @libbuild_dir@/shared to your LD_LIBRARY_PATH
# variable.  This value will need to be part of your environment, so that
# all programs will see it (including ones started on remote hosts).
#
# The ar at the end puts the Fortran MPI_Init and the routine that
# it calls to get getarg and iargc into a separate library.  This
# is needed for shared lib support
# Note that if there is no Fortran support, then we don't build the farg
# library
mpichsharelibs:
	@-( cd $(libbuild_dir) ; \
	CC="$(CC)" ; export CC ; CLINKER="@CLINKER@" ; export CLINKER ; \
	for lib in lib@MPILIBNAME@.a libp@MPILIBNAME@.a \
            libf@MPILIBNAME@.a ; do \
	    if [ -s $$lib ] ; then \
	      ${top_srcdir}/util/makesharedlib -exceptobjs="farg.o farg90.o initf.o" -lib=$$lib -kind=@SHAREDKIND@ ; \
	    fi ; \
	done ; \
        if [ $(NOF77) = 0 ] ; then \
	    ar x lib@MPILIBNAME@.a farg.o initf.o ; \
	    @AR@ lib@MPILIBNAME@farg.a farg.o initf.o ; \
	fi ; \
	)


mkbuilddirs:
	$(top_srcdir)/util/mkdirs ${libbuild_dir} ${includebuild_dir} ${binbuild_dir} ${sysconfdir}

#
# Remove the - in the linktest because the linktest should abort the build
# when it fails.
linktest:
	@if [ $(NOF77) = 1 ] ; then \
	( cd examples/test/pt2pt ; $(MAKE) linktest1 ) ; \
	else \
	( cd examples/test/pt2pt ; $(MAKE) linktest ) ; \
	fi

testing:
	(cd examples/test ; $(MAKE) testing)

#
# This is the target for the report function.  The optional lines on the make
# are
#   AUTHOR=string
#   CONFIGLOG=file
#
report:
	( if [ -n "$(AUTHOR)" ] ; then auth=-author="$(AUTHOR)" ; fi ; \
	  if [ -n "$(CONFIGLOG)" ] ; then conf=-config=$(CONFIGLOG) ; fi ; \
	doc/port -dotest $$auth $$conf ; )
	doc/docgather
	mv doc.tar doc$(ARCH)$(DEVICE).tar
	@echo "Final location of tar file is doc$(DEVICE).tar"
	@echo "util/insttest -prefix=install_directory"
	@echo "may be run to complete the testing.  This must be run"
	@echo "in the foreground.  It will try to start Upshot and Nupshot."
	@echo "It also does an installation into 'install_directory'"


#
# Make sure that a failure during the make causes the make to stop at 
# that point.
#	${top_srcdir}/makelinks
mpilib: ${top_srcdir}/Makefile.in
	-@(cd mpid/@DEVICE@ ; $(MAKE) setlinks)
	@for dir in $(CODEDIRS) ;\
	  do \
	  echo " " ;\
	  echo making mpir in directory $$dir ;\
	  (cd $$dir ; \
	  $(MAKE) default_all ; st=$$? ; if [ $$st != 0 ] ; then \
		echo "Exit status from make was $$st" ; fi ; exit $$st ) ;\
	  if [ $$? != 0 ] ; then exit 1 ; fi ; \
	  done
	-(cd src/infoexport ; $(MAKE) default_all )
	@RANLIB@ $(libbuild_dir)/lib@MPILIBNAME@.a
	@if test -w $(libbuild_dir)/lib@MPILIBNAME@++.a ; then \
		@RANLIB@ $(libbuild_dir)/lib@MPILIBNAME@++.a ; fi

mpiflib: ${top_srcdir}/Makefile.in
	@for dir in $(MPIDIRS) $(MPI2DIRS) ;\
	  do \
	  echo " " ;\
	  echo making mpir in directory $$dir ;\
	  (cd $$dir ; \
	  $(MAKE) wrapperlib ) ;\
	  done
	@RANLIB@ $(libbuild_dir)/libf@MPILIBNAME@.a

#
# This target is used to remove the libraries for this configuration; this
# can lead to better performance when rebuilding.
rmlib:
	/bin/rm -f $(libbuild_dir)/lib*.a 
	/bin/rm -f $(libbuild_dir)/shared/lib*.so*

#
# This is a special target for just the device part of the transport
# (used to speed builds for multiple Chameleon transport layers)
#
# WARNING: THIS DEPENDS ON THE ROUTINES IN MPIDIRS CALLING ROUTINES, NOT
# MACROS, FROM THE ADI.  THIS IS CURRENTLY THE CASE BUT MAY CHANGE
# 
# This uses the "default" entry instead of "default_all" because it is
# usually executed alone, and the RANLIB is needed at the end of this
# target anyway.
# Override the libbuild_dir
mpelib:
	@-if [ $(NOMPE) = 0 ] ; then \
            echo "making mpe graphics libraries" ; \
	    if [ ! -d mpe ] ; then mkdir mpe ; fi ; \
	    (cd mpe ; MAKE="$(MAKE)" ; export MAKE ; \
	     libbuild_dir="${libbuild_dir}"; export libbuild_dir ; \
	     /bin/rm -f config.cache ; \
	     if [ $(NOF77) = 1 ] ; then \
                 if ${top_srcdir}/mpe/configure --with-mpich=$(MPIR_HOME) \
				--with-mpichdev=$(libbuild_dir)  \
				@ENABLE_MPEDBG@ \
			        --disable-f77  \
				--prefix=$(prefix) \
				--libdir=$(libdir) \
				--bindir=$(bindir) \
	                        "@JUMPSHOT_OPTS@" \
				@MPE_OPTS@ ; then $(MAKE) ; \
		 else echo "Error configuring mpe" ; \
		      if [ -s config.log ] ; then cat config.log ; fi ; \
		 fi  \
	     else \
                 if ${top_srcdir}/mpe/configure --with-mpich=$(MPIR_HOME) \
			        --with-mpichdev=$(libbuild_dir)  \
			        --with-f77_extra_flag=@F77_EXTRA_FLAG@ \
				@ENABLE_MPEDBG@ \
				--prefix=$(prefix) \
				--libdir=$(libdir) \
				--bindir=$(bindir) \
				--with-flib_path_leader=@FLIB_PATH_LEADER@ \
	                        "@JUMPSHOT_OPTS@" \
			        @MPE_OPTS@ ; then $(MAKE) ; \
		 else echo "Error configuring mpe" ; \
		      if [ -s config.log ] ; then cat config.log ; fi ; \
		 fi   \
	     fi ) \
	fi
	@if test -w $(libbuild_dir)/libmpe.a ; then \
		@RANLIB@ $(libbuild_dir)/libmpe.a ; fi
	@if test -w $(libbuild_dir)/libmpe_nompi.a ; then \
		@RANLIB@ $(libbuild_dir)/libmpe_nompi.a ; fi

# Grumble.  The mpichdev is supposed to be the subdirectory of the mpich
# home.
# Note that mpi.h expects to find an mpi++.h.  Create an empty one if 
# necessary, in both the final includedir and the topsrc/include directory
# (the C++ configure doesn't use the correct compiler test for mpi.h)
# The rm of mpi++.h when the -s test fails deletes mpi++.h ONLY when we've
# created a dummy with touch

# We also added a dummy mpi++.h.  However, the C++ build step both builds
# and tests, so it needs the *real* includes.  This is done by setting the
# CPPFLAGS to point to the MPI-2-C++/src build directory. During installation,
# these flags are (should be) reset.
#	@if [ ! -s $(includebuild_dir)/mpi++.h ] ; then \
#		touch $(includebuild_dir)/mpi++.h ; fi
#	@if [ ! -s include/mpi++.h ] ; then \
#		touch include/mpi++.h ; fi
#		if [ ! -s $(includedir)/mpi++.h ] ; then \
#		    rm -f $(includedir)/mpi++.h ; fi ; \
#	        if [ ! -s ../include/mpi++.h ] ; then \
#		    rm -f ../include/mpi++.h ; fi ; 
cpplib:
	@(cd MPI-2-C++ ; MAKE="$(MAKE)" ; export MAKE ; \
	/bin/rm -f config.cache ; \
	CXXFLAGS="" ; export CXXFLAGS ; \
	CXX="g++" ; export CXX ; \
	ldir=`echo $(libdir) | sed -e 's%$(MPIR_HOME)/%%g'` ; \
	if ${top_srcdir}/MPI-2-C++/configure --with-mpich=.. \
			--with-libopt=" " \
			 --with-profiling \
			 --with-mpichbin=${binbuild_dir} \
			 --with-mpichlib=${libbuild_dir} \
			 --with-mpichsrc=${MPIR_HOME} \
	                 --with-mpichdev=$(libbuild_dir) ; then \
		$(MAKE) ; \
	fi ) 
	@if [ -f "MPI-2-C++/src/libmpi++.a" ] ; then \
	    cp -p MPI-2-C++/src/libmpi++.a $(libbuild_dir)/libmpich++.a ; fi 

mpidevlib:
	(cd mpid/$(DEVICE) ; $(MAKE) clean )
	@for dir in mpid/$(DEVICE) ;\
	  do \
	  echo " " ;\
	  echo making mpir in directory $$dir ;\
	  (cd $$dir ; \
	  $(MAKE) default) ;\
	  done

#
# This is mpilib, but with memory leak/usage debugging turned on.
# The command line switch -chmemdebug will enable leak reporting
# when MPI_Finalize is called.
mpilibdebug:
	@for dir in $(CODEDIRS) ;\
	  do \
	  echo " " ;\
	  echo making mpir in directory $$dir ;\
	  (cd $$dir ; \
	  $(MAKE) default_all MPIPROFILE="-DMPIR_DEBUG_MEM" ) ;\
	  (cd $$dir ; $(MAKE) clean ; \
	  $(MAKE) profile_all MPIPROFILE="-DMPIR_DEBUG_MEM -DMPI_BUILD_PROFILING");\
	  done 
	@RANLIB@ $(libbuild_dir)/lib@MPILIBNAME@.a
	@RANLIB@ $(libbuild_dir)/libp@MPILIBNAME@.a
	@if test -w $(libbuild_dir)/lib@MPILIBNAME@++.a ; then \
		@RANLIB@ $(libbuild_dir)/lib@MPILIBNAME@++.a ; fi

# 
# We need to include the device here, so that the MPID symbols will be 
# defined in libpmpich.a (the best order of libs is -lmpich -lpmpich).
# Since we allow -lmpich *only*, we need the device files in both 
# libraries.  The directory list is the same as CODEDIRS
profile:
	@if [ "@HAS_WEAK_SYMBOLS@" = 0 ] ; then \
	  for dir in mpid/${DEVICE} $(MPIDIRS) $(MPI2DIRS) ; do \
	    echo " " ;\
	    echo making mpir in directory $$dir ;\
	    (cd $$dir ; \
	    $(MAKE) profile_all MPIPROFILE="-DMPI_BUILD_PROFILING" ) ;\
	  done ; \
	  @RANLIB@ $(libbuild_dir)/libp@MPILIBNAME@.a ; \
	fi

#
# In some cases, we may not need to build a profiling library (if we can
# use weak symbols).  This ensures that users can always link with it, even
# if they don't need to.  Also, ROMIO may generate explicit profiling library
# routines, in that case the library will exist (but be small)
profileliblink:
	@if [ ! -s $(libbuild_dir)/libp@MPILIBNAME@.a ] ; then\
	  (cd $(libbuild_dir) ; ln -s lib@MPILIBNAME@.a \
		libp@MPILIBNAME@.a ) ; \
	fi

#
# This is a temporary hack.  The code to build the rest of the mpirun
# infrastructure should be part of the device setup code, not part of
# the master Makefile (this also applies to the server targets).
# Note that we copy rather than link to the programs
mpirun_chp4mpd:
	/bin/rm -f ${binbuild_dir}/startdaemons
	if [ -d mpid/mpd ] ; then \
	    if [ ! -f mpid/mpd/mpdcon ] ; then \
	        ( cd mpid/mpd ; $(MAKE) mpdcon ) ; \
	    fi ; \
	    cp mpid/mpd/mpdcon ${binbuild_dir}/mpirun ; \
	    cp mpid/mpd/startdaemons ${binbuild_dir}/startdaemons ; \
	fi
#
# Make mpirun from mpirun.*.in
#
mpirun: ${binbuild_dir}/mpirun

#
# If you change this, ALSO change it in the install target!

# We can't fill MPIRUNLIST with the output of a command that also uses 
# Makefile variables (sigh).
MPIRUNLIST = `test -s ${srcdir}/mpid/$(DEVICE)/mpirun.lst && cat ${srcdir}/mpid/$(DEVICE)/mpirun.lst || echo mpid/$(DEVICE)/mpirun.$(DEVICE).in`

#	  cp $(bindir)/$$bfile ${binbuild_dir}/$$bfile ; 
${binbuild_dir}/mpirun: ${srcdir}/util/mpirun.in ${srcdir}/util/mpirun.args.in 
	-@for file in util/mpirun.in util/mpirun.args.in $(MPIRUNLIST) ; do \
	  bfile=`basename $$file .in` ; \
	  /bin/rm -f ${binbuild_dir}/$$bfile ; \
	  cat ${srcdir}/$$file | sed -e "s%\#MPIR_HOME\#%$(MPIR_HOME)%g" \
		-e "s%\#AUTOMOUNTFIX\#%@AUTOMOUNTFIX@%g" \
		-e "s%\#EXECER_DIR\#%$(MPIR_HOME)/util%g" \
		-e "s%\#DEFAULT_DEVICE\#%$(DEVICE)%g" \
		-e "s%\#RSHCOMMAND\#%$(RSHCOMMAND)%g" \
		-e "s%\#SYNCLOC\#%@SYNCLOC@%g" \
		-e "s%\#CC\#%@CC@%g" \
		-e "s%\#COMM\#%@COMM@%g" \
	        -e "s%\#GLOBUSDIR\#%@GLOBUSDIR@%g" \
		-e "s%\#CLINKER\#%@CLINKER@%g" \
	        -e "s%\#MPIRUN_BIN\#%$(binbuild_dir)%g" \
		-e "s%\#datadir\#%$(MPIR_HOME)/util/machines%g" \
		-e "s%\#bindir\#%$(binbuild_dir)%g" \
		-e "s%\#DEFAULT_MACHINE\#%$(DEFAULT_MACHINE)%g" \
		-e "s%\#DEFAULT_ARCH\#%$(LARCH)%g" > $(binbuild_dir)/$$bfile ; \
	  chmod 775 $(binbuild_dir)/$$bfile ; \
	done ;

#
# If you change this, ALSO change it in the install target!
#	@-cp ${binbuild_dir}/mpireconfig config.status $(bindir)
mpireconfig: ${binbuild_dir}/mpireconfig config.status
${binbuild_dir}/mpireconfig: ${srcdir}/util/mpireconfig.in config.status
	-rm -f ${top_srcdir}/bin/mpireconfig.dat
	-rm -f ${binbuild_dir}/mpireconfig.dat
	@cat ${srcdir}/util/mpireconfig.in | \
		        sed -e "s%\#MPIR_HOME\#%$(MPIR_HOME)%g" \
			    -e "s%\#ARCH\#%$(LARCH)%g" \
			    -e "s%\#PREFIX\#%$(PREFIX)%g" \
			    -e "s%\#DEVICE\#%$(DEVICE)%g" \
			    -e "s%\#top_srcdir\#%$(top_srcdir)%g" \
			    -e "s%\#bindir\#%$(bindir)%g" \
			    -e "s%\#binbuild_dir\#%$(binbuild_dir)%g" \
				> \
		    ${binbuild_dir}/mpireconfig
	@chmod 775 ${binbuild_dir}/mpireconfig
	@sed -e 's%$$top_srcdir/$$file%$$file%g' \
	    -e 's%$$top_srcdir/$${file}%$${file}%g' \
		config.status > \
		${binbuild_dir}/mpireconfig.dat
	@-chmod 775 ${binbuild_dir}/mpireconfig.dat

#
# Make mpiman from mpiman.in
#
mpiman: ${binbuild_dir}/mpiman

#
# If you change this, ALSO change it in the install target!
${binbuild_dir}/mpiman: ${srcdir}/util/mpiman.in
	@/bin/rm -f ${binbuild_dir}/mpiman
	@cat ${srcdir}/util/mpiman.in \
	    | sed -e "s%\#INSTALL_DIR\#%$(MPIR_HOME)%g" > ${binbuild_dir}/mpiman
	@chmod 755 ${binbuild_dir}/mpiman

tstmachines: ${binbuild_dir}/tstmachines
${binbuild_dir}/tstmachines: ${srcdir}/util/tstmachines.in
	rm -f ${binbuild_dir}/tstmachines
	sed -e "s%\#MPIR_HOME\#%$(MPIR_HOME)%g" \
		-e "s%\#DEFAULT_DEVICE\#%$(DEVICE)%g" \
		-e "s%\#RSHCOMMAND\#%$(RSHCOMMAND)%g" \
		-e "s%\#DEFAULT_MACHINE\#%$(DEFAULT_MACHINE)%g" \
		-e "s%\#datadir\#%$(MPIR_HOME)/util/machines%g" \
		-e "s%\#bindir\#%$(binbuild_dir)%g" \
		-e "s%\#DEFAULT_ARCH\#%$(LARCH)%g" \
		-e "s%\#AUTOMOUNTFIX\#%@AUTOMOUNTFIX@%g" \
		-e "s%\#CC\#%@CC@%g" \
		-e "s%\#CLINKER\#%@CLINKER@%g" \
		${srcdir}/util/tstmachines.in > \
		    ${binbuild_dir}/tstmachines
	chmod 775 ${binbuild_dir}/tstmachines
#
# If you change this, ALSO change it in the install target!
#	-cp ${binbuild_dir}/chp4_servs $(bindir)
#	-cp util/chkserv $(bindir)
#	-cp util/chkmachine $(bindir)
# Note that we need to set the C compiler through an environment variable.
serv_p4 server:
	if [ ! -d mpid/server ] ; then mkdir mpid/server ; fi
	( cd mpid/server ; /bin/rm -f config.cache ; \
	  CC="@CC@" ; export CC ; MAKE="${MAKE}" ; export MAKE ; \
	  ${top_srcdir}/mpid/server/configure ; $(MAKE) serv_p4 ; \
	  cp serv_p4 $(binbuild_dir) )
	/bin/rm -f ${binbuild_dir}/chp4_servs
	@cat ${srcdir}/util/chp4_servs.in | \
	    sed -e "s%\#MPIR_HOME\#%$(MPIR_HOME)%g" \
		-e "s%\#DEFAULT_DEVICE\#%$(DEVICE)%g" \
		-e "s%\#RSHCOMMAND\#%$(RSHCOMMAND)%g" \
		-e "s%\#datadir\#%$(MPIR_HOME)/util/machines%g" \
		-e "s%\#bindir\#%$(binbuild_dir)%g" \
		-e "s%\#MPICH_JOBTYPE_REQUIRED\#%@MPICH_JOBTYPE_REQUIRED@%g" \
		-e "s%\#DEFAULT_MACHINE\#%$(DEFAULT_MACHINE)%g" \
		-e "s%\#DEFAULT_ARCH\#%$(LARCH)%g" > \
		    ${binbuild_dir}/chp4_servs ;\
	chmod 775 ${binbuild_dir}/chp4_servs
	-cp util/chkserv $(binbuild_dir)
	-cp util/chkmachine $(binbuild_dir)

#
# Changed clean to not remove the library, only the object files
#
# Also, it should not remove the "executables"
# We also do NOT clean util, since it has files (like mpicc) that are built
# by configure.  Builds with a new architecture
# should use make cleanslate
# We also remove the Makefile in nupshot after using it as it is created
# by the nupshot configure itself.
# We pass MAKE to the MPE Makefile to make sure that it has a valid
# version of make.  Since MPE is configured separately, it might have
# a make choice from a previous configuration.
clean:
	@-for dir in tsuite bugs mpid/server mpid/mpd installtest \
		f90modules ; do \
	    if [ -d $$dir -a -s $$dir/Makefile ] ; then \
		(cd $$dir ; $(MAKE) clean ) ; fi ; done
	@-if [ -d romio -a -s romio/Makefile -a "@ROMIO@" = 1 ] ; then \
	    (cd romio ; $(MAKE) clean ) ; fi
	@-if [ -d MPI-2-C++ -a -s MPI-2-C++/Makefile -a "@buildcpp@" = 1 ] ; then \
	    (cd MPI-2-C++ ; $(MAKE) clean ) ; fi
	@-if [ -d mpe -a -s mpe/Makefile -a "@NOMPE@" = 0 ] ; then \
	    (cd mpe ; $(MAKE) MAKE="$(MAKE)" clean ) ; fi
	@-for dir in $(DIRS) ;\
	  do \
	  if [ -s $$dir/Makefile ] ; then \
	  echo cleaning $$dir ;\
	  (cd $$dir ; $(MAKE) clean ; ) ; fi ;\
	  done
	-@if [ -s mpid/ch_shmem/p2ptest/Makefile ] ; then \
	    echo "cleaning mpid/ch_shmem/p2ptest" ; \
	    (cd mpid/ch_shmem/p2ptest ; $(MAKE) clean ) ; fi
	-@if [ -s mpid/tests/Makefile ] ; then \
	    (cd mpid/tests ; $(MAKE) clean ) ; fi
cleanslate: clean
	(cd util ; if [ -s Makefile ] ; then $(MAKE) clean ; fi )
#
# distclean removes mpirun etc as well as the libraries.
distclean: cleanslate
	/bin/rm -f *~ *.ln bin/mpirun bin/mpirun.args bin/mpirun.ch_p4 \
			   o bin/mpirun.ch_shmem bin/mpirun.pg bin/mpiman \
			    bin/mpireconfig bin/mpicc bin/mpiCC bin/mpif77 \
			    bin/mpif90 bin/mpiinstall bin/upshot bin/jumpshot \
			    bin/startdaemons /bin/config.status \
			    installtest/Makefile 
	if [ -s util/Makefile ] ; then \
	    (cd util ; /bin/rm -f chkmachine chkserv Makefile ) ; fi 
	(cd util/machines ; \
	    /bin/rm -f machines.IRIX* machines.sun* machines.solaris* \
	    machines.cray* machines.CRAY* machines.LINUX machines.rs600 \
	    machines.alpha machines.hp* )
	/bin/rm -f doc/port doc/portbuild doc/portperf doc/porttest
	if [ -d mpid/server -a -s mpid/server/Makefile ] ; then \
	       (cd mpid/server ; $(MAKE) distclean) ; fi
	if [ -d jumpshot ] ; then \
	  /bin/rm -f jumpshot/confdefs.h jumpshot/config.log \
	  jumpshot/config.cache jumpshot/config.status ; fi
	if [ -d mpe -a -s mpe/Makefile -a "@NOMPE@" = 0 ] ; then \
	    (cd mpe ; $(MAKE) MAKE=$(MAKE) distclean ) ; fi
	if [ -s f90modules/Makefile ] ; then \
	    (cd f90modules ; $(MAKE) distclean ) ; fi
	/bin/rm -f lib/*.[oa]
	/bin/rm -f lib/*.so.*
	/bin/rm -f lib/*.so
	/bin/rm -f lib/shared/*
	/bin/rm -f include/mpidefs.h include/mpif.h
	/bin/rm -f bin/mpi* 
	/bin/rm -f ID
	for dir in $(DEVICES) ; do echo cleaning $$dir ; \
	     if [ -d $$dir ] ; then \
	       (cd $$dir ; if [ -s Makefile ] ; then $(MAKE) clean ; fi ) ; \
	     fi ; \
	done
	if [ -s mpid/ch_p4/Makefile ] ; then \
	    (cd mpid/ch_p4 ; $(MAKE) distclean ) ; fi
	if [ -s mpid/ch_p4mpd/Makefile ] ; then \
	    (cd mpid/ch_p4mpd ; $(MAKE) distclean ) ; fi
	if [ -s mpid/ch_shmem/Makefile ] ; then \
	    (cd mpid/ch_shmem ; $(MAKE) distclean ) ; fi
	if [ -s mpid/ch_mpl/Makefile ] ; then \
	    (cd mpid/ch_mpl ; $(MAKE) distclean ) ; fi
	if [ -d mpid/tests -a -s mpid/tests/Makefile ] ; then \
	    (cd mpid/tests ; $(MAKE) distclean ) ; fi
	if [ -s mpid/ch_p4mpd/p4mpd/Makefile ] ; then \
	    (cd  mpid/ch_p4mpd/p4mpd ; $(MAKE) realclean ) ; fi
	if [ -s romio/Makefile ] ; then \
	    (cd  romio ; $(MAKE) cleanall ) ; fi
	if [ -d MPI-2-C++ -a -s MPI-2-C++/Makefile -a "@buildcpp@" = 1 ] ; then \
	    (cd MPI-2-C++ ; $(MAKE) distclean ) ; fi
	for dir in $(DIRS) ;\
	  do \
	  echo removing Makefile in $$dir ;\
	  (cd $$dir ; /bin/rm -f Makefile) ;\
	  done
	if [ -s examples/test/runtests ] ; then \
	    /bin/rm -f examples/test/runtests ; fi
	if [ -s examples/test/coll/runtests ] ; then \
	    /bin/rm -f examples/test/coll/runtests ; fi
	if [ -s examples/test/context/runtests ] ; then \
	    /bin/rm -f examples/test/context/runtests ; fi
	if [ -s examples/test/env/runtests ] ; then \
	    /bin/rm -f examples/test/env/runtests ; fi
	if [ -s examples/test/profile/runtests ] ; then \
	    /bin/rm -f examples/test/profile/runtests ; fi
	if [ -s examples/test/pt2pt/runtests ] ; then \
	    /bin/rm -f examples/test/pt2pt/runtests ; fi
	if [ -s examples/test/topol/runtests ] ; then \
	    /bin/rm -f examples/test/topol/runtests ; fi
	if [ -s examples/test/config.status ] ; then \
	      /bin/rm -f examples/test/config.status ; fi
	if [ -s src/env/Makefile ] ; then \
	    /bin/rm -f src/env/mpehname.c  src/env/farg.f ; fi
	/bin/rm -f Makefile config.log config.status 
#
# Make an ID database from a suitable subset of the sources
# (Get mkid from sunsite if you want to use this)
#
ID: frc
	find include src/coll src/context src/dmpi src/env src/pt2pt \
		src/topol src/util src/infoexport \
	mpid/ch2 mpid/$(DEVICE) mpid/util -name "*.[hc]" -print | mkid -v -

frc:



INSTALLDIR = /usr/local/mpi
#
# The install target really needs to use some for of 'install' program that
# will create directories, set modes and owners, etc.  Alas, such a function
# is not standard.
# Note that clean removes mpirun (!) and mpiinstall (!) so we need to make
# sure that it is around before doing the install
# Make sure that we use our OWN copy of mpiinstall, because the created
# copy goes into the same directory as the source file.
# We also name it "mympiinstall" to ensure that we don't find the "wrong"
# directory
./bin/mpiinstall: ${binbuild_dir}/mpireconfig ${top_srcdir}/util/mpiinstall.in
	if [ ! -s util/mympiinstall.in ] ; then \
	    cp ${top_srcdir}/util/mpiinstall.in util/mympiinstall.in ; fi
	@-(${binbuild_dir}/mpireconfig util/mympiinstall ; \
	rm -f ${binbuild_dir}/mpiinstall ; \
	sed -e 1d util/mympiinstall > ${binbuild_dir}/mpiinstall ; \
	chmod a+x ${binbuild_dir}/mpiinstall )

# Steps in preinstall:
# 1-Remove the old config.status and copy new one; this allows mpireconfig to
#   work with the current configuration.
# 2-Move the mpichconf.h file to where it will be used for the build.
#   Having it the final install directory allows us to see what was defined
# 3-Copy the scripts to the bindir
# 4-Copy mpidefs.h to includedir
# 5-Copy mpif.h to includedir
# Still to do: build mpif.h with MPICH and ROMIO contributions here.
# We do NOT use top_srcdir for the derived files, because they are created in 
# the current directory by configure
# These are done by configure for includebuild_dir.  includedir should be
# done only during installation
#	-cp include/mpidefs.h ${includedir}/mpidefs.h
#	-cp include/mpif.h ${includedir}/mpif.h
# We need to resurrect this for the actual install
#		true cp ${binbuild_dir}/$$file ${bindir}/$$file ;
preinstall:
	rm -f ${binbuild_dir}/config.status 
	cp config.status ${binbuild_dir}
	cp mpichconf.h ${includebuild_dir}
	cp ${top_srcdir}/mpichconf.h.in ${includebuild_dir}
	for file in mpicc mpiCC mpif77 mpif90 mpiinstall ; do \
	    if test -s util/$$file ; then \
	        rm -f ${binbuild_dir}/$$file ; \
		mv util/$$file ${binbuild_dir}/$$file ;\
	    fi ;\
	done

# Eventually, this should have preinstall as a source.
install: mpirun ./bin/mpiinstall
	@if [ ! -x ./bin/mpiinstall ] ; then echo "No mpiinstall script!" ; fi
	./bin/mpiinstall -prefix=$(PREFIX)

installlib: mpirun ./bin/mpiinstall
	./bin/mpiinstall -prefix=$(PREFIX) -libonly -device=$(DEVICE)

#
# Install adds ALL of the examples to the installation area
# This is an initial version.
install-all: install
	(/bin/rm $(PREFIX)/examples/*)
	-$(CPRP) -r examples $(PREFIX)
	# Update the makefiles
	(cd $(PREFIX)/examples ; \
		$(bindir)/mpireconfig Makefile ; \
		for dir in `find . -type d -print` ; do \
			(cd $$dir ; \
			if [ -s Makefile.in ] ; then \
				$(bindir)/mpireconfig Makefile ; \
			fi ) ; \
		done \
	)

etags:
	etags include/*.h mpid/$(DEVICE)/*.h $(CODEDIRS)

