.TH Threads 5 "8/23/1995" " " "ADI"
.SH NAME
Threads in the ADI - Support for multithreaded applications

MPI is thread-friendly in that the MPI specification does not specify
anything that is not thread safe.  However, the MPI specification does not
mandate any particular thread support.  It is our intent that the MPICH
ADI provide a thread-safe version; this section details the current
state of that interface.  This is currently untested.

.SH COMMUNICATOR-BASED LOCKS
Some operations on a communicator must be single threaded.  These
macros can be defined to provide the appropriate locks.
The first parameter (
.I ctx
) is the ADI context (often ignored); the
second is the communictor to lock.

.PD 0
.TP
.B MPID_THREAD_LOCK(ctx,comm) 
- Lock a thread in a communicator
.PD 1
.PD 0
.TP
.B MPID_THREAD_UNLOCK(ctx,comm) 
- Unlock a thread in a communicator
.PD 1
.PD 0
.TP
.B MPID_THREAD_LOCK_INIT(ctx,comm) 
- Initialize a thread in a communicator
.PD 1
.PD 0
.TP
.B MPID_THREAD_LOCK_FINISH(ctx,comm) 
- Free a thread in a communicator
.PD 1

.SH DATASTRUCTURE-BASED LOCKS
These four are for locking individual data-structures.  The data-structure
should contain something like
.nf
   typedef struct {
      MPID_THREAD_DS_LOCK_DECLARE
      other stuff
      } foo;
.fi

and then use
.nf
   foo *p;
   MPID_THREAD_DS_LOCK(p)
   MPID_THREAD_DS_UNLOCK(p)
.fi


.PD 0
.TP
.B MPID_THREAD_DS_LOCK_DECLARE 
- The declaration of the lock
.PD 1
.PD 0
.TP
.B MPID_THREAD_DS_LOCK_INIT(p) 
- Initializes the lock for datastructure 
.I p

.PD 1
.PD 0
.TP
.B MPID_THREAD_DS_LOCK(p) 
- Lock datastructure 
.I p

.PD 1
.PD 0
.TP
.B MPID_THREAD_DS_UNLOCK(p) 
- Unlock datastructure 
.I p

.PD 1

