/*
 *  $Id: dmpi.c,v 1.31 1995/09/13 21:44:42 gropp Exp $
 *
 *  (C) 1993 by Argonne National Laboratory and Mississipi State University.
 *      See COPYRIGHT in top-level directory.
 */

#ifndef lint
static char vcid[] = "$Id: dmpi.c,v 1.31 1995/09/13 21:44:42 gropp Exp $";
#endif /* lint */

/*  dmpi.c - routines in mpir that are called by the device */

#include "dmpi.h"
#include "mpiimpl.h"
#include "mpisys.h"

#define MPIR_MIN(a,b) (a) < (b) ? (a) : (b)
#define DEVICE_PREFERS_MEMCPY 1

/* called by device when a message arrives.  Returns 1 if there is posted
 * receive, 0 otherwise.
 *
 * This puts the responsibility for searching the unexpected queue and
 * posted-receive queues on the device.  If it is operating asynchronously
 * with the user code, the device must provide the necessary locking mechanism.
 */

void DMPI_msg_arrived( src, tag, context_id, dmpi_recv_handle, foundflag )
int               src, tag, *foundflag;
MPIR_CONTEXT      context_id;
MPIR_RHANDLE      **dmpi_recv_handle;
{
    int          found;
    MPIR_RHANDLE *handleptr;

    MPID_THREAD_DS_LOCK(&MPIR_posted_recvs)
    MPIR_search_posted_queue( src, tag, context_id, &found, 1, 
			      dmpi_recv_handle);
    MPID_THREAD_DS_UNLOCK(&MPIR_posted_recvs);
    if ( found )
    {
	*foundflag = 1;	
	/* note this overwrites any wild-card values in the posted handle */
	handleptr         	= *dmpi_recv_handle;
	handleptr->source 	= src;
	handleptr->tag  	= tag;
	/* count is set in the put and get routines */
    }
    else
    {
	/* allocate handle and put in unexpected queue */
	*dmpi_recv_handle       = 
	    ( MPIR_RHANDLE * ) MPIR_SBalloc ( MPIR_rhandles );
	handleptr         	= *dmpi_recv_handle;
	if (!handleptr) {
	    MPIR_ERROR( MPI_COMM_WORLD, MPI_ERR_EXHAUSTED, 
		        "Could not dynamically allocate internal handle" );
	    }
	handleptr->handle_type  = MPIR_RECV;
	handleptr->source 	= src;
	handleptr->tag  	= tag;
	handleptr->contextid    = context_id;
	handleptr->datatype     = MPI_BYTE;
	DMPI_Clr_recv_completed( handleptr );
	MPID_Alloc_recv_handle( handleptr->comm->ADIctx,
			        &(handleptr->dev_rhandle) );
	
	MPID_THREAD_DS_LOCK(&MPIR_unexpected_recvs);	
	MPIR_enqueue( &MPIR_unexpected_recvs, (void * ) *dmpi_recv_handle,
                      MPIR_QSHANDLE );
	MPID_THREAD_DS_UNLOCK(&MPIR_unexpected_recvs);
	*foundflag = 0;
    }
}




#ifdef MPID_HAS_HETERO
/* Returns 2 if the data needs XDR conversion,
           1 if the data needs byteswapping,
	   0 if none of the above... 
   This is also used for receives, where "dest" is source, and may 
   be MPI_ANY_SOURCE, in which case the "worst-case" is chosen 
   (XDR).

   Eventually, there should be a comm argument to this (for PACK) 
   and a separate Source_needs_conversion (with comm) so that
   each communicator can store heterogeneity information.
*/
int 
MPIR_Dest_needs_conversion(dest)
int dest;
{
  if (dest < 0) return 2;
  if ( (MPID_Dest_byte_order(MPIR_tid) == MPID_H_XDR) ||
       (MPID_Dest_byte_order(dest) == MPID_H_XDR))
    return 2;
  else if (MPID_Dest_byte_order(MPIR_tid) != MPID_Dest_byte_order(dest))
    return 1;
  else
    return 0;
}


int 
MPIR_Comm_needs_conversion(comm)
MPI_Comm comm;
{
  int i;
  for (i = 0; i < comm->local_group->np; i++) {
    if (MPIR_Dest_needs_conversion(comm->local_group->lrank_to_grank[i]))
      return 2;
  }
  return 0;
}
#endif



/*
   Let the device tell the API that a handle can be freed (this handle
   was generated by an unexpected receive and inserted by DMPI_msg_arrived.
 */
void DMPI_free_unexpected( dmpi_recv_handle  )
MPIR_RHANDLE      *dmpi_recv_handle;
{
MPID_Free_recv_handle( dmpi_recv_handle->comm->ADIctx, 
		       &dmpi_recv_handle->dev_rhandle );
MPIR_SBfree( MPIR_rhandles, dmpi_recv_handle );
}

/*
   This sets up the buffers for a send.  The logic is:
   if can use in place, setup buffer for that, 
   else use MPI_PACK.

   Note that in the homogeneous case with contiguous data, we can inline
   this routine and the receive counterpart.  It can always handle 
   contiguous messages, but may be bypassed by the macro below.

   A macro of the form (passed the actual shandle structure) could be used:
   MPIR_Send_setup_contig( request, shandle ) \
   if (shandle.datatype->is_contig) {\
   shandle.active       = 1;\
   shandle.dev_shandle.bytes_as_contig =\
   shandle.count * shandle.datatype->size;\
   if (shandle.dev_shandle.bytes_as_contig > 0 && shandle.bufadd == 0)\
       mpi_errno = MPI_ERR_BUFFER;\
   shandle.dev_shandle.start = shandle.bufadd;\
   shandle.bufpos		 = 0;}\
   else{mpi_errno = MPIR_Send_setup( request );} 

 */
int MPIR_Send_setup(request)
MPI_Request *request;
{
  register MPIR_SHANDLE *shandle;
  register int mpi_errno = MPI_SUCCESS;
  int dest_type;

  shandle = &(*request)->shandle;
  if (shandle->dest == MPI_PROC_NULL) return mpi_errno;

  shandle->active       = 1;

  if (shandle->datatype->is_contig)
#ifdef MPID_HAS_HETERO
    if ((MPID_IS_HETERO == 1) &&
	(dest_type = MPIR_Dest_needs_conversion(shandle->dest))) {
      /* This is a heterogeneous case - can't send from the user's
	 buffer because we have to swap or xdr encoded. 
	 This would be faster if the 
	 device swapped as it copied, but this is a MPIR level 
	 heterogeneous implementation. 
       */
#ifdef FOO	
      if (shandle->count > 0 && shandle->bufadd == 0) {
	  return MPI_ERR_BUFFER;
	  }
      shandle->dev_shandle.bytes_as_contig =
	  MPIR_Mem_convert_len( dest_type, shandle->datatype, shandle->count );
      shandle->bufpos = (char *)MALLOC(shandle->dev_shandle.bytes_as_contig);

      shandle->dev_shandle.start = shandle->bufpos;
      /* Should check that the result len is not larger than allocated! */
      shandle->dev_shandle.bytes_as_contig = 
	  MPIR_Type_convert_copy( shandle->comm, shandle->dev_shandle.start,
				 shandle->dev_shandle.bytes_as_contig,
			     shandle->bufadd, shandle->datatype, 
			     shandle->count, shandle->dest,
			     &shandle->msgrep);
#endif
    /* Heterogeneous case handled in MPIR_Pack and MPIR_Pack_Hvector */
    if (mpi_errno = 
	MPIR_PackMessage(shandle->bufadd, shandle->count, 
			 shandle->datatype, shandle->dest, *request )) {
      MPIR_ERROR( MPI_COMM_WORLD, mpi_errno, 
		 "Could not pack message in MPIR_Send_setup" );
    }
    } else 
#endif
    {
#ifdef MPID_HAS_HETERO
      shandle->msgrep = MPIR_MSGREP_RECEIVER;
#endif
      shandle->dev_shandle.bytes_as_contig =
	shandle->count * shandle->datatype->size;
      if (shandle->dev_shandle.bytes_as_contig > 0 && shandle->bufadd == 0)
	  mpi_errno = MPI_ERR_BUFFER;
      shandle->dev_shandle.start = shandle->bufadd;
      shandle->bufpos		 = 0;
    }
  else
#ifdef MPID_PACK_IN_ADVANCE
  {
    /* Heterogeneous case handled in MPIR_Pack and MPIR_Pack_Hvector */
    if (mpi_errno = 
	MPIR_PackMessage(shandle->bufadd, shandle->count, 
			 shandle->datatype, shandle->dest, *request )) {
      MPIR_ERROR( MPI_COMM_WORLD, mpi_errno, 
		 "Could not pack message in MPIR_Send_setup" );
    }
  }
#else
  {
    shandle->dev_shandle.start = 0; /* Heterogeneous case handled in 
				       get_into_contig for short messages.
				       This breaks on long messages because
				       the p4 device passes a -1 for maxlen
				       to get_from_contig XXX...*/
  }
#endif
  return mpi_errno;

}


int 
MPIR_SendBufferFree( request )
MPI_Request request;
{
  FREE( request->chandle.bufpos );
  request->chandle.bufpos = 0;
  return MPI_SUCCESS;
}


/* 
   This handles setting up a receive request; primarily handling the
   allocation of a receive buffer for aggressive receives.

   NOTE: If the rendevous protocol is used, then in the heterogeneous 
   case, we don't need to do this aggressive (in space) buffer allocation.
 */
int 
MPIR_Receive_setup(request)
MPI_Request *request;
{
  MPIR_RHANDLE *rhandle;
  int mpi_errno = MPI_SUCCESS;
  int dest_type;

  rhandle = &(*request)->rhandle;
  if (rhandle->source == MPI_PROC_NULL) return mpi_errno;
  rhandle->active       = 1;

  /* Even for contiguous data, if heterogeneous, we may need to 
     allocate a larger buffer ... */

  if (rhandle->datatype->is_contig) {
#if defined(MPID_HAS_HETERO)
    if (MPID_IS_HETERO == 1 && 
	(dest_type = MPIR_Dest_needs_conversion(rhandle->source))) {
      /* This is a heterogeneous case - we MAY need a longer buffer, 
	 depending on whether XDR may be used in this communicator 
	 and whether the source is known... */
	if (rhandle->count > 0 && rhandle->bufadd == 0) 
	    return MPI_ERR_BUFFER;
	rhandle->dev_rhandle.bytes_as_contig =
	  MPIR_Mem_convert_len( dest_type, rhandle->datatype, rhandle->count );
	/* This is needed only if a non-rendevous, non-packetized approach
	   is used */
	if (rhandle->dev_rhandle.bytes_as_contig) {
	    rhandle->bufpos = 
		(char *)MALLOC(rhandle->dev_rhandle.bytes_as_contig);
	    if (!rhandle->bufpos) 
		return MPI_ERR_EXHAUSTED;
	    }
	else
	    rhandle->bufpos = 0;
	rhandle->dev_rhandle.start = rhandle->bufpos;
	/* printf( "Receive buffer size is %d for count of %d\n", 
	         rhandle->dev_rhandle.bytes_as_contig, rhandle->count ); */
    } else 
#endif
    {
    rhandle->dev_rhandle.start = rhandle->bufadd;
    rhandle->dev_rhandle.bytes_as_contig =
      rhandle->count * rhandle->datatype->extent;
    if (rhandle->dev_rhandle.bytes_as_contig > 0 && 
	rhandle->bufadd == 0) 
	mpi_errno = MPI_ERR_BUFFER;
    rhandle->bufpos                      = 0;
    }
    }
#ifdef MPID_RETURN_PACKED
    /* This will also need to know how to handle heterogeneous 
       communications */
  else {
    if (mpi_errno = 
	MPIR_SetupUnPackMessage( rhandle->bufadd, rhandle->count, 
				rhandle->datatype, rhandle->source, 
				*request )) {
      MPIR_ERROR( MPI_COMM_WORLD, mpi_errno, 
		 "Could not pack message in MPIR_Receive_setup" );
    }
  }
#else
  else 
    rhandle->dev_rhandle.start = 0;
#endif

  return mpi_errno;
}

#if 0
/*
   This is drawn directly from the code in src/pt2pt/unpack; both should be
   modified together.
 */
int MPIR_PrintDatatype ( fp, count, type, in_offset, out_offset )
FILE         *fp;
int          count;
MPI_Datatype type;
int          in_offset, out_offset;
{
  int i,j,k;
  int pad = 0;
  int mpi_errno = MPI_SUCCESS;
  int tmp_offset;

  if (in_offset == 0 && out_offset == 0) 
      fprintf( fp, "Commands to unpack datatype:\n" );
  /* Unpack contiguous data */
  if (type->is_contig) {
      fprintf( fp, "Contiguous type:" );
      fprintf( fp, " Copy %d <- %d for %d bytes\n", out_offset, in_offset,
	       type->size * count );
      return mpi_errno;
      }

  /* For each of the count arguments, unpack data */
  switch (type->dte_type) {

  /* Contiguous types */
  case MPIR_CONTIG:
        fprintf( fp, "MPIR_CONTIG:\n" );
	mpi_errno = MPIR_PrintDatatype ( fp, count * type->count, 
					 type->old_type, 
					 in_offset, out_offset );
	break;

  /* Vector types */
  case MPIR_VECTOR:
  case MPIR_HVECTOR:
	fprintf( fp, "MPIR_(H)VECTOR:\n" );
	if (count > 1)
	  pad = (type->align - (type->size % type->align)) % type->align;
	tmp_offset = out_offset;
	for (i=0; i<count; i++) {
	  out_offset = tmp_offset;
	  for (j=0; j<type->count; j++) {
		if (mpi_errno = MPIR_PrintDatatype ( fp, type->blocklen, 
					 type->old_type, 
				       in_offset, out_offset )) 
		    return mpi_errno;
		out_offset  += (type->stride);
		if ((j+1) != type->count)
		  in_offset += 
		      ((type->blocklen * type->old_type->size) + type->pad);
	  }
	  in_offset += ((type->blocklen * type->old_type->size) + pad);
	  tmp_offset += type->extent;
	}
	break;

  /* Indexed types */
  case MPIR_INDEXED:
  case MPIR_HINDEXED:
	fprintf( fp, "MPIR_(H)INDEXED:\n" );
	if (count > 1)
	  pad = (type->align - (type->size % type->align)) % type->align;
	for (i=0; i<count; i++) {
	  for (j=0;j<type->count; j++) {
		tmp_offset  = out_offset + type->indices[j];
		if (mpi_errno = MPIR_PrintDatatype (fp, type->blocklens[j], 
					 type->old_type, 
					 in_offset, tmp_offset)) 
		    return mpi_errno;
		if ((j+1) != type->count)
		  in_offset += 
		    ((type->blocklens[j]*type->old_type->size)+type->pad);
	  }
	  in_offset += ((type->blocklens[j]*type->old_type->size) + pad);
	  out_offset += type->extent;
	}
	break;

  /* Struct type */
  case MPIR_STRUCT:
	fprintf( fp, "MPIR_(H)STRUCT:\n" );
	if (count > 1)
	  pad = (type->align - (type->size % type->align)) % type->align;
	for (i=0; i<count; i++) {
	  for (j=0;j<type->count; j++) {
		tmp_offset  = out_offset + type->indices[j];
		if (mpi_errno = MPIR_PrintDatatype( fp, type->blocklens[j],
					type->old_types[j], 
				       in_offset, tmp_offset)) 
		    return mpi_errno;
		if ((j+1) != type->count)
		  in_offset += 
		      ((type->blocklens[j] * type->old_types[j]->size) +
						 type->pads[j]);
	  }
	  in_offset+=((type->blocklens[type->count-1]*
				   type->old_types[type->count-1]->size)+pad);
	  out_offset +=type->extent;
	}
	break;

  default:
	mpi_errno = MPI_ERR_TYPE;
	break;
  }

  /* Everything fell through, must have been successful */
  return mpi_errno;
}

int MPIR_PrintDatatypePack ( fp, count, type, in_offset, out_offset )
FILE *fp;
int count;
MPI_Datatype type;
int  in_offset, out_offset;
{
  int i,j,k;
  int pad = 0;
  int mpi_errno = MPI_SUCCESS;
  int tmp_offset;

  if (in_offset == 0 && out_offset == 0) 
      fprintf( fp, "Commands to pack datatype:\n" );
  /* Pack contiguous data */

  /* At this point, if the type is contiguous, it should be
	 a basic type, so we could pack it with something other
	 than memcpy */
	    
  if (type->is_contig) {
      fprintf( fp, "Contiguous type:" );
      fprintf( fp, " Copy %d <- %d for %d bytes\n", out_offset, in_offset,
	       type->size * count );
      return mpi_errno;
  }


  /* For each of the count arguments, pack data */
  switch (type->dte_type) {

  /* Contiguous types */
  case MPIR_CONTIG:
        fprintf( fp, "MPIR_CONTIG:\n" );
	mpi_errno = MPIR_PrintDatatypePack ( fp, count * type->count, 
					     type->old_type, 
					     in_offset, out_offset );
	break;

  /* Vector types */
  case MPIR_VECTOR:
  case MPIR_HVECTOR:
	fprintf( fp, "MPIR_(H)VECTOR:\n" );
	if (count > 1)
	  pad = (type->align - (type->size % type->align)) % type->align;
	tmp_offset = in_offset;
	for (i=0; i<count; i++) {
	  in_offset = tmp_offset;
	  for (j=0; j<type->count; j++) {
		if (mpi_errno = MPIR_PrintDatatypePack ( fp, type->blocklen, 
							type->old_type, 
					       in_offset, out_offset)) break;
		in_offset  += (type->stride);
		if ((j+1) != type->count)
		  out_offset += 
		      ((type->blocklen * type->old_type->size) + type->pad);
	  }
	  out_offset += ((type->blocklen * type->old_type->size) + pad);
	  tmp_offset += type->extent;
	}
	break;

  /* Indexed types */
  case MPIR_INDEXED:
  case MPIR_HINDEXED:
	fprintf( fp, "MPIR_(H)INDEXED:\n" );
	if (count > 1)
	  pad = (type->align - (type->size % type->align)) % type->align;
	for (i=0; i<count; i++) {
	  for (j=0;j<type->count; j++) {
		tmp_offset  = in_offset + type->indices[j];
		if (mpi_errno = MPIR_PrintDatatypePack (fp, 
							type->blocklens[j], 
				       type->old_type, 
						in_offset, out_offset)) break;
		out_offset += (type->blocklens[j]*type->old_type->size);
		if ((j+1) != type->count)
		  in_offset += type->pad;
	  }
	  out_offset += pad;
	  in_offset += type->extent;
	}
	break;

  /* Struct type */
  case MPIR_STRUCT:
	fprintf( fp, "MPIR_(H)STRUCT:\n" );
	if (count > 1)
	  pad = (type->align - (type->size % type->align)) % type->align;
	for (i=0; i<count; i++) {
	  for (j=0;j<type->count; j++) {
		tmp_offset  = in_offset + type->indices[j];
		if (mpi_errno = MPIR_PrintDatatypePack(fp,type->blocklens[j],
		      type->old_types[j], in_offset, tmp_offset)) break;
		if ((j+1) != type->count)
		  out_offset += ((type->blocklens[j] * 
				 type->old_types[j]->size) +
						 type->pads[j]);
	  }
	  out_offset+=((type->blocklens[type->count-1]*
				   type->old_types[type->count-1]->size)+pad);
	  in_offset +=type->extent;
	}
	break;

  default:
	mpi_errno = MPI_ERR_TYPE;
	break;
  }

  /* Everything fell through, must have been successful */
  return mpi_errno;
}
#endif
