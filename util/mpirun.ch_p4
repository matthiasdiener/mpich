#! /bin/sh
#
if [ -z "$MPIR_HOME" ] ; then 
    MPIR_HOME=/home/gropp/mpich
fi
if [ "$MPIR_HOME" = "#""MPIR_HOME""#" ] ; then
    MPIR_HOME=`pwd`/..
fi
MPIRUN_HOME=$MPIR_HOME/bin
if [ -z "$argsset" ] ; then
   . $MPIRUN_HOME/mpirun.args
   argsset=1
fi
#
if [ -n "$MPI_P4SSPORT" ] ; then
    if [ "$MPI_USEP4SSPORT" = "yes" -o "$MPI_USEP4SSPORT" = "YES" ] ; then
        p4ssport=$MPI_P4SSPORT
    fi
fi
# Make sure that the application is in the .p4apps file.  Note that 
# progname is already an absolute path
if [ -n "$p4ssport" ] ; then
    if [ -z "$HOME" ] ; then
	echo "Cannot determine location of home directory (in HOME)"
	exit 1
    fi
    if [ -r $HOME/.p4apps ] ; then
        grep $progname $HOME/.p4apps > /dev/null 2>&1
        if [ $? != 0 ] ; then 
	    echo "$progname" >> $HOME/.p4apps
            chmod 600 $HOME/.p4apps
	fi
    else
	echo "$progname" >> $HOME/.p4apps
        chmod 600 $HOME/.p4apps
    fi
    cmdLineArgs="$cmdLineArgs -p4ssport $p4ssport"
fi
#
# Construct the procgroup file
. $MPIRUN_HOME/mpirun.pg
# machinelist has the hosts
# archuselist has the architectures
#
# We use this form instead of "local 0" in-case the user is trying to
# select a second network whose names are not those returned by
# "hostname".  For example, a system with a DEC Gigiswitch, Myricom 
# network, or IP over the IBM SP2 switch (HPS).
prognamemain=$progname
if [ -z "$p4pgfile"  ] ; then
    p4pgfile="$PWD_TRIAL/PI$$"
    echo "Test" > $p4pgfile
    if [ ! -s $p4pgfile ] ; then
	# May not be able to write there.  Try the user's home directory
	p4pgfile=$HOME/PI$$
    else
	/bin/rm -rf $p4pgfile
    fi
    procNum=1
#    archval=`echo $archuselist | cut -d' ' -f1`
    archval=$archlocal
    proginstance=`echo $progname | sed "s/%a/$archval/g"`
    prognamemain=$proginstance
    if [ $just_testing = 1 ] ; then
       echo "Procgroup file:"
       if [ $nolocal = 0 ] ; then
	    echo "$HOST 0 $proginstance"
       else 
	    echo "$machinehead 0 $proginstance"
            procNum=2
       fi
    else
       if [ $nolocal = 0 ] ; then
	    echo "$HOST 0 $proginstance" > $p4pgfile
       else
	    echo "$machinehead 0 $proginstance" > $p4pgfile
            procNum=2
       fi
    fi
    cnt=1
    for machine in $machinelist ; do 
	if [ $procNum = 2 ] ; then 
	    procNum=1; cnt=`expr $cnt + 1`; continue ; 
	fi
	archval=`echo $archuselist | cut -d' ' -f$cnt`
	cnt=`expr $cnt + 1`
	proginstance=`echo $progname | sed "s/%a/$archval/g"`
        echo $machine 1 $proginstance >> $p4pgfile
    done

    # make sure the procgroup file was written
    if [ $just_testing = 0 -a \! -r "$p4pgfile" ] ; then
        echo Failed to write "$p4pgfile".  Exiting.
        exit 1
    fi

    if [ $just_testing = 0 -a $mpirun_verbose = 1 ] ; then
      echo Created "$p4pgfile"
    fi
fi
#
# On nfs systems, it is possible that a recently created executable may 
# not be visable yet to other systems, causing problems when you attempt
# to start a job.  As a partial fix for this, we do a sync.  It would help,
# of course, if NFS worked correctly.
#
/bin/sync > /dev/null 2>&1
#
startpgm="eval"
if [ "$debugger" != "" ] ; then
    dbgfile=$PWD_TRIAL/PId$$
    echo "Test" > $dbgfile
    if [ -s $dbgfile ] ; then
	/bin/rm -f $dbgfile
    else
        dbgfile=$HOME/PId$$
    fi
    # If gdb has an equivalent, the documentation is well hidden.
    #  - .gdbinit - and the documentation IS well hidden.  Fortunately,
    # the .gbdinit file is read; gdb provides the -nx (instead of -x)
    # command if you don't want to read the default init file.
    if [ "$debugger" = "dbx" -a -r $HOME/.dbxinit ] ; then
	cat $HOME/.dbxinit > $dbgfile
    fi
# handle USR1 pass for gdb; add an initial break 
    if [ "$debugger" = "gdb" ] ; then
	echo "handle USR1 nostop pass" >> $dbgfile
	eco "br MPI_Init" >> $dbgfile
    else 
        echo "ignore USR1" >> $dbgfile
	echo "stop in MPI_Init" >> $dbgfile
    fi
	cat >> $dbgfile <<.
# Use this command to start your programm:
run  $cmdLineArgs -p4pg $p4pgfile
.
	startpgm="$debugger $progname $commandfile $dbgfile"
fi
#
if [ $just_testing = 1 ] ; then
  echo ""
  if [ $nolocal = 1 ] ; then
	echo $rshcmd $machinehead $prognamemain  $cmdLineArgs -p4pg "$p4pgfile"
  else
	echo $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
  fi
else
  if [ $nolocal = 1 ] ; then
    if [ "$debugger" != "" ] ; then
	  $rshcmd $machinehead $debugger $commandfile $dbgfile $prognamemain
    else
	  $rshcmd $machinehead $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
    fi
  else
    if [ "$debugger" != "" ] ; then
	    $debugger $commandfile $dbgfile $prognamemain
    else
	    $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
    fi
  fi # nolocal
  if [ $leavePGFile = 1 ] ; then
	echo "P4 procgroup file is $p4pgfile."
  else
    /bin/rm "$p4pgfile"
  fi
fi #just testing




