#! /bin/sh
#
if [ -z "$MPIR_HOME" ] ; then 
    MPIR_HOME=/Net/antireo/antireo9/MPI/mpich
fi
if [ "$MPIR_HOME" = "#""MPIR_HOME""#" ] ; then
    MPIR_HOME=`pwd`/..
fi
if [ "lib/sun4/ch_p4" = "#""MPIRUN_BIN""#" ] ; then 
    MPIRUN_HOME=$MPIR_HOME/bin
else
    MPIRUN_HOME=$MPIR_HOME/lib/sun4/ch_p4
fi
if [ -z "$argsset" ] ; then
   . $MPIRUN_HOME/mpirun.args
   argsset=1
fi
#
if [ -n "$MPI_P4SSPORT" ] ; then
    if [ "$MPI_USEP4SSPORT" = "yes" -o "$MPI_USEP4SSPORT" = "YES" ] ; then
        p4ssport=$MPI_P4SSPORT
    fi
fi
# Make sure that the application is in the .p4apps file.  Note that 
# progname is already an absolute path
if [ -n "$p4ssport" ] ; then
    if [ -z "$HOME" ] ; then
	echo "Cannot determine location of home directory (in HOME)"
	exit 1
    fi
    if [ -r $HOME/.p4apps ] ; then
        grep $progname $HOME/.p4apps > /dev/null 2>&1
        if [ $? != 0 ] ; then 
	    echo "$progname" >> $HOME/.p4apps
            chmod 600 $HOME/.p4apps
	fi
    else
	echo "$progname" >> $HOME/.p4apps
        chmod 600 $HOME/.p4apps
    fi
    cmdLineArgs="$cmdLineArgs -p4ssport $p4ssport"
fi
#
# Construct the procgroup file
. $MPIRUN_HOME/mpirun.pg
# machinelist has the hosts
# archuselist has the architectures
#
# We use this form instead of "local 0" in-case the user is trying to
# select a second network whose names are not those returned by
# "hostname".  For example, a system with a DEC Gigiswitch, Myricom 
# network, or IP over the IBM SP2 switch (HPS).
prognamemain=$progname
if [ -z "$p4pgfile"  ] ; then
    p4pgfile="$PWD_TRIAL/PI$$"
    echo "Test" > $p4pgfile
    if [ ! -s $p4pgfile ] ; then
	# May not be able to write there.  Try the user's home directory
	p4pgfile=$HOME/PI$$
    else
	/bin/rm -rf $p4pgfile
    fi
    procNum=1
#    archval=`echo $archuselist | cut -d' ' -f1`
    archval=$archlocal
    proginstance=`echo $progname | sed "s/%a/$archval/g"`
    prognamemain=$proginstance
    if [ $just_testing = 1 ] ; then
       echo "Procgroup file:"
       if [ $nolocal = 0 ] ; then
	    echo "$MPI_HOST 0 $proginstance"
       else 
	    echo "$machinehead 0 $proginstance"
            procNum=2
       fi
    else
       if [ $nolocal = 0 ] ; then
	    if [ -z "$MPI_HOST" ] ; then
		echo "No value for MPI_HOST!"
	        exit 1
	    fi
	    echo "$MPI_HOST 0 $proginstance" > $p4pgfile
       else
	    echo "$machinehead 0 $proginstance" > $p4pgfile
            procNum=2
       fi
    fi
    cnt=1
    for machine in $machinelist ; do 
	if [ $procNum = 2 ] ; then 
	    procNum=1; cnt=`expr $cnt + 1`; continue ; 
	fi
	archval=`echo $archuselist | cut -d' ' -f$cnt`
	cnt=`expr $cnt + 1`
	proginstance=`echo $progname | sed "s/%a/$archval/g"`
        echo $machine 1 $proginstance >> $p4pgfile
    done

    # make sure the procgroup file was written
    if [ $just_testing = 0 -a \! -r "$p4pgfile" ] ; then
        echo Failed to write "$p4pgfile".  Exiting.
        exit 1
    fi

    if [ $just_testing = 0 -a $mpirun_verbose = 1 ] ; then
      echo Created "$p4pgfile"
    fi
fi
#
# On nfs systems, it is possible that a recently created executable may 
# not be visible yet to other systems, causing problems when you attempt
# to start a job.  As a partial fix for this, we do a sync.  It would help,
# of course, if NFS worked correctly.
#
/bin/sync > /dev/null 2>&1
#

#
# Handle debuggers
#
#startpgm="eval"
startpgm="$prognamemain $cmdLineArgs -p4pg $p4pgfile"
if [ "$debugger" != "" ] ; then
    if [ "$debugger" = "totalview" ] ; then
        if [ "$TOTALVIEW" = "" ] ; then
	   TOTALVIEW="totalview"
        fi
        startpgm="$TOTALVIEW $prognamemain -a $cmdLineArgs -p4pg $p4pgfile -mpichtv"	        
    else
        dbgfile=$PWD_TRIAL/PId$$
        echo "Test" > $dbgfile
        if [ -s $dbgfile ] ; then
	    /bin/rm -f $dbgfile
        else
            dbgfile=$HOME/PId$$
        fi
        # If gdb has an equivalent, the documentation is well hidden.
        #  - .gdbinit - and the documentation IS well hidden.  Fortunately,
        # the .gbdinit file is read; gdb provides the -nx (instead of -x)
        # command if you don't want to read the default init file.
        if [ "$debugger" = "dbx" -a -r $HOME/.dbxinit ] ; then
	    cat $HOME/.dbxinit > $dbgfile
        fi
        # Regretably, xxgdb does NOT provide this argument (even though it
        # claims to).
    #    if [ "$debugger" = "xxgdb" -a -r $HOME/.gdbinit ] ; then
    #	cat $HOME/.gdbini > $dbgfile
    #    fi
        # handle USR1 pass for gdb; add an initial break 
        if [ "$debugger" = "gdb" -o "$debugger" = "xxgdb" ] ; then
	    echo "handle SIGUSR1 nostop pass" >> $dbgfile
	    echo "br MPI_Init" >> $dbgfile
	    echo "set args $cmdLineArgs -p4pg $p4pgfile" >> $dbgfile
	    echo "run" >> $dbgfile
        else 
            echo "ignore USR1" >> $dbgfile
            # This may not work, depending on when the symbol table is read.
            # An alternative is to use the startup file to load the 
            # program with "debug $prognamemain" ,followed with this, followed
	    # with run command args.
	    echo "debug $prognamemain" >> $dbgfile
   	    echo "stop in MPI_Init" >> $dbgfile
	    echo "run $cmdLineArgs -p4pg $p4pgfile" >> $dbgfile
        fi
    #	cat >> $dbgfile <<.
    ## Use this command to start your programm:
    #run  $cmdLineArgs -p4pg $p4pgfile
    #.
	    commandfile=`echo $commandfile | sed -e s@%f@$dbgfile@g`
	    startpgm="$debugger $commandfile $prognamemain"
    fi
fi
#
# Pass to the program that the device is ch_p4
#
MPIRUN_DEVICE="ch_p4"
export MPIRUN_DEVICE
#
# Build a suitable command for the whole thing
#
if [ $just_testing = 1 ] ; then
  doitall="echo"
else
  doitall=""
fi
#
# Add rsh'ery if requested
#
if [ $nolocal = 1 ] ; then
    doitall="$doitall $rshcmd $machinehead"
fi

$doitall $startpgm

#else
#  if [ $nolocal = 1 ] ; then
#    if [ "$debugger" != "" ] ; then
#	  $rshcmd $machinehead $debugger $commandfile $prognamemain
#    else
#	  $rshcmd $machinehead $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
#    fi
#  else
#   if [ "$debugger" != "" ] ; then
#	    $debugger $commandfile $prognamemain
#    else
#	    $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
#    fi
#  fi # nolocal
if [ $just_testing != 1 ] ; then
  if [ $leavePGFile = 1 ] ; then
	echo "P4 procgroup file is $p4pgfile."
  else
    /bin/rm "$p4pgfile"
  fi
fi #just testing
