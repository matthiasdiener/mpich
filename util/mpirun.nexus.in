#! /bin/sh

#
# Based largely on the mpirun.ch_p4.in file.
#
#
# The following makes a statement that is true of ALL versions of MPIRUN, 
# and hence is redundent.
#
#echo "Notice:  This is not the using the full features of the Nexus" 2>&1
#echo "Notice:  runtime.   To do so, you should try to run the program" 2>&1
#echo "Notice:  directly instead." 2>&1

#
# If this program was started up without the arguments being passed, we
# must first set up the arguments
#
if [ -z "$MPIR_HOME" ] ; then
  MPIR_HOME=#MPIR_HOME#
fi
if [ "$MPIR_HOME" = "#""MPIR_HOME""#" ] ; then
  MPIR_HOME=`pwd`/..
fi
if [ "#MPIRUN_BIN#" = "#""MPIRUN_BIN""#" ] ; then 
    MPIRUN_HOME=$MPIR_HOME/bin
else
    MPIRUN_HOME=$MPIR_HOME/#MPIRUN_BIN#
fi
if [ -z "$argsset" ] ; then
  . $MPIRUN_HOME/mpirun.args
  argsset=1
fi

#
# This section is mostly snarfed from mpirun.anlspx
#
if [ -d /etc/FRAMES -a -d /mcs ] ; then
    on_anlsp=1
else
    on_anlsp=0
fi


#
# Make sure that the application is in the .server_apps file.
# This is really only necessary if the secure server is running, but
# it doesn't hurt too badly.
#
if [ -z "$HOME" ] ; then
  echo "Cannot determine location of home directory (in HOME)"
  exit 1
fi
if [ -r $HOME/.server_apps ] ; then
  grep $progname $HOME/.server_apps > /dev/null 2>&1
  if [ $? != 0 ] ; then
    echo "$progname" >> $HOME/.server_apps
    chmod 600 $HOME/.server_apps
  fi
else # $HOME/.server_apps
  echo "$progname" >> $HOME/.server_apps
  chmod 600 $HOME/.server_apps
fi

#
# Construct a startup file.  If one is not used, use the same file that
# p4 uses to create one.  This only applies to non-ANL SP usages, since
# we expect the SP to use MPL instead of TCP, so a startup file is not
# needed.
#
if [ "$on_anlsp" != "1" ] ; then
    if [ "x$nexuspgfile" = "x" ] ; then
        . $MPIRUN_HOME/mpirun.pg
        prognamemain=$progname
        nexuspgfile="$PWD_TRIAL/startup.$$"
        archval=$archlocal
        proginstance=`echo $progname | sed "s/%a/$archval/g"`
        prognamemain=$proginstance
        if [ $just_testing = 1 ] ; then
          echo "Startup file:"
          echo "$MPI_HOST startup_exe=$proginstance"
        else
          echo "$MPI_HOST startup_exe=$proginstance" > $nexuspgfile
        fi
        cnt=1
        for machine in $machinelist ; do
          archval=`echo $archuselist | cut -d' ' -f$cnt`
          cnt=`expr $cnt + 1`
          proginstance=`echo $progname | sed "s/%a/$archval/g"`
          if [ $just_testing = 1 ] ; then
	    echo "$machine#$cnt startup_exe=$proginstance"
          else
	    echo "$machine#$cnt startup_exe=$proginstance" >> $nexuspgfile
          fi
        done
        #
        # Make sure the startup file was written
        #
        if [ $just_testing = 0 -a \! -r "$nexuspgfile" ] ; then
          echo "Failed to write $nexuspgfile.  Exiting."
          exit 1
        fi
    fi

    NexusArgs="-s $nexuspgfile $NexusArgs"
fi

#
# Use a rdb file (if necessary)
#
if [ "x$nexusdbfile" != "x" ] ; then
  NexusArgs="-dbfile $nexusdbfile $NexusArgs"
fi

if [ "$debugger" = "dbx" ] ; then
  NexusArgs="-debug_command $MPIRUN_HOME/rundbx -debug_display $DISPLAY $NexusArgs"
fi
if [ "$debugger" = "gdb" ] ; then
  NexusArgs="-debug_command $MPIRUN_HOME/rungdb -debug_display $DISPLAY $NexusArgs"
fi

#
# Somehow get the right options to Nexus without munching the options to
# the program.  If the user typed something like
#
#    mpirun -np 2 a.out foo -mpi -stack 50000
#
# the $cmdLineArgs becomes "foo -mpi -stack 50000", so the easiest way
# to add arguments is at the beginning surrounded by a -mpi/-mpi_end
# pair.  This makes the current $cmdLineArgs equal to
# "foo -mpi -s startupfile -mpi_end -mpi -stack 5000", because we always
# use a startup file.
#
cmdLineArgs="-mpi $NexusArgs -mpi_end $cmdLineArgs"

if [ $on_anlsp = 1 ] ; then
    . $MPIRUN_HOME/mpirun.anlspx
else
    #
    # Check for non-supported options:
    #    nolocal
    #    e
    #    nopoll
    #    maxtime
    #    cac
    #

    #
    # Set up the debugger (if necessary)
    #
    if [ "x$debugger" != "x" ] ; then
      debuggerfile="$PWD_TRIAL/debugger.$$"
      # If gdb has an equivalent, the documentation is well hidden.
      if [ "$debugger" = "dbx" -a -r $HOME/.dbxinit ] ; then
        cat $HOME/.dbxinit > $debuggerfile
      fi
      cat >> $debuggerfile <<EOF
# ignore USR1
# Use this command to start your program:
run $cmdLineArgs 
EOF
      startpgm="$debugger $progname $commandfile $debuggerfile"
    else # debugger
      startpgm="$progname $cmdLineArgs"
    fi # debugger

    #
    # Start program (if necessary)
    #
    if [ $just_testing = 1 ] ; then
      echo ""
      echo $startpgm
    else # just_testing
      $startpgm
      if [ $leavePGFile = 1 ] ; then
        echo "Startup file is $nexuspgfile."
      else
        /bin/rm "$nexuspgfile"
      fi
    fi # just_testing
fi # on_anlsp
