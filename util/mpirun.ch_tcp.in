#! /bin/sh
#
DEFAULT_ARCH=#DEFAULT_ARCH#
if [ -z "$MPIR_HOME" ] ; then 
    MPIR_HOME=#MPIR_HOME#
fi
if [ "$MPIR_HOME" = "#""MPIR_HOME""#" ] ; then
    MPIR_HOME=`pwd`/..
fi
if [ "#MPIRUN_BIN#" = "#""MPIRUN_BIN""#" ] ; then 
    MPIRUN_HOME=$MPIR_HOME/bin
else
    MPIRUN_HOME=$MPIR_HOME/#MPIRUN_BIN#
fi
if [ -z "$argsset" ] ; then
   . $MPIRUN_HOME/mpirun.args
   argsset=1
fi
#
#
# Construct the procgroup file in the format accepted by the execer
. $MPIRUN_HOME/mpirun.pg
# machinelist has the hosts
# archuselist has the architectures
#
prognamemain=$progname
if [ -z "$tcppgfile"  ] ; then
    tcppgfile="$PWD_TRIAL/PG$$"
    # echo 'machinelist: ' $machinelist
    # echo 'archuselist: ' $archuselist
    procNum=1
    archval=$archlocal
    proginstance=`echo $progname | sed "s/%a/$archval/g"`
    prognamemain=$proginstance
    cnt=1
    listport=`expr 5000 + $$ + $cnt`
    echo hostname=$MPI_HOST progname=$proginstance listport=$listport progargs=\"$cmdLineArgs\" > $tcppgfile
    for machine in $machinelist ; do 
	archval=`echo $archuselist | cut -d' ' -f$cnt`
	cnt=`expr $cnt + 1`
	proginstance=`echo $progname | sed "s/%a/$archval/g"`
        listport=`expr 5000 + $$ + $cnt`
        echo hostname=$machine progname=$proginstance listport=$listport progargs=\"$cmdLineArgs\" >> $tcppgfile
    done
    # leavePGFile=1
    # make sure the procgroup file was written
    if [ $just_testing = 0 -a \! -r "$tcppgfile" ] ; then
        echo Failed to write "$tcppgfile".  Exiting.
        exit 1
    fi

    if [ $just_testing = 0 -a $mpirun_verbose = 1 ] ; then
      echo Created "$tcppgfile"
    fi
fi
#
# On nfs systems, it is possible that a recently created executable may 
# not be visable yet to other systems, causing problems when you attempt
# to start a job.  As a partial fix for this, we do a sync.  It would help,
# of course, if NFS worked correctly.
#
#SYNCLOC# > /dev/null 2>&1
#
startpgm="eval"
if [ "$debugger" != "" ] ; then
    # If gdb has an equivalent, the documentation is well hidden.
    if [ "$debugger" = "dbx" -a -r $HOME/.dbxinit ] ; then
	cat $HOME/.dbxinit > $PWD_TRIAL/PId$$
    fi
	cat >> $PWD_TRIAL/PId$$ <<.
ignore USR1
# Use this command to start your programm:
run  $cmdLineArgs -p4pg $p4pgfile
.
	startpgm="$debugger $progname $commandfile $PWD_TRIAL/PId$$"
fi
#
#
# Pass to the program that the device is ch_p4
#
MPIRUN_DEVICE="ch_tcp"
export MPIRUN_DEVICE
if [ $just_testing = 1 ] ; then
  echo ""
  if [ $nolocal = 1 ] ; then
	echo $rshcmd $machinehead $prognamemain  $cmdLineArgs -p4pg "$p4pgfile"
  else
	echo $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
  fi
else
  if [ $nolocal = 1 ] ; then
    if [ "$debugger" != "" ] ; then
	  $rshcmd $machinehead $debugger $commandfile $PWD_TRIAL/PId$$ $prognamemain
    else
	  $rshcmd $machinehead $prognamemain $cmdLineArgs -p4pg "$p4pgfile"
    fi
  else
    if [ "$debugger" != "" ] ; then
	    $debugger $commandfile $PWD_TRIAL/PId$$ $prognamemain
    else
####### here is where we run the newexecer to start the program ##########
            $MPIR_HOME/lib/$DEFAULT_ARCH/ch_tcp/newexecer "$tcppgfile"
    fi
  fi # nolocal
  if [ $leavePGFile = 1 ] ; then
	echo "tcp procgroup file is $tcppgfile."
  else
    /bin/rm "$tcppgfile"
  fi
fi #just testing




