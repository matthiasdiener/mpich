#!/bin/csh -f

# MPIRUN
# This script tries to start jobs on whatever kind of machine you're on.
# Strategy - This program is built with a default device it uses in
# certain ways. The user can override this default from the command line.
#
# Note that the -f is important to ensure that commands needed by csh are
# not aliased to commands with the same name and different behavior.
#
#
# THIS PROGRAM IS OBSOLETE.  SEE mpirun.*.in, PARTICULARLY mpirun.sh.in .
#
#set verbose
set MPIR_HOME = #MPIR_HOME#
set EXECER = #EXECER_DIR#/execer
set MEIKO_RUN = prun
set SP1_RUN = /usr/lpp/euih/eui/cotb0
set jobid=$$
set progname=''
set fake_progname=''
set np=1
set arch=''
set default_arch='#DEFAULT_ARCH#'
set machine = '#DEFAULT_MACHINE#'
set default_device='#DEFAULT_DEVICE#'
set execer_machine=1
set cmdLineArgs=''
set cmdLineArgsExecer=''
set cmdline=''
set CAC=''
set use_execer = 0
set mpirun_verbose = 0
set nolocal = 0
set leavePGFile = 0
set p4pgfile = ''
set p4ssport = ''
set just_testing = 0
set machineFile = ''
set debugger=""
set commandfile=""
set rmcommandfile=""
set rshcmd=#RSH_COMMAND#
set mvhome=0
set mvback=''
set Machines = "chameleon meiko paragon p4 sp1 ibmspx anlspx ksr sgi_mp ipsc860 inteldelta cray_t3d execer smp symm_ptx"
set max_time = 15
#
# Special, system specific values
#
# polling_mode is for systems that can select between polling and 
# interrupt-driven operation.  Currently, only IBM POE is so supported
# (TMC CMMD has some support for this choice of mode)
set polling_mode = 1

# Parse command line arguments
# The ultimate goal is to determine what kind of parallel machine this
# is we are running on. Then we know how to start jobs...

set j = 1
while ("$j" <= "$#argv")
  set arg = "$argv[$j]"
  switch ("$arg")
    case -mr_arch:
    case -arch:
      @ j++
      set arch = "$argv[$j]"
      breaksw
    case -mr_np:
    case -np:
      @ j++
      set np = "$argv[$j]"
      set nodigits = `echo $np | sed 's/^[0-9]*$//'`
      if (($nodigits != "") || ($np < 1)) then
        echo np: $np is an invalid number of processors.  Exiting.
        exit 1
      endif
      breaksw
    case -mr_machine:
    case -machine:
      @ j++
      set machine = "$argv[$j]"
      breaksw
    case -mr_machinefile:
    case -machinefile:
      @ j++
      set machineFile = "$argv[$j]"
      breaksw
    case -mr_device:
    case -device:
      @ j++
      set default_device = "$argv[$j]"
      breaksw
    case -mr_nolocal:
    case -nolocal:
      set nolocal = 1
      breaksw
    case -mr_h:
    case -h:
      goto PrintHelp
      breaksw
    case -mr_e:
    case -e:
      set use_execer = 1
      breaksw
    case -mr_pg:
    case -pg:
      set use_execer = 0
      breaksw
    case -mr_leave_pg:
    case -mr_keep_pg:
    case -leave_pg:
    case -keep_pg:
      set leavePGFile = 1
      breaksw
    case -p4pg:
      if ($np > 1) then
	echo "-p4pg and -np are mutually exclusive; -np $np being ignored."
        set np = 1
      endif
      @ j++
      set p4pgfile = "$argv[$j]"
      set leavePGFile = 1
      breaksw
    case -p4ssport:
      @ j++
      set p4ssport = "$argv[$j]"
      if ($p4ssport == "0" && $?MPI_P4SSPORT) then
	set p4ssport = $MPI_P4SSPORT
      endif
      breaksw
    case -mr_v:
    case -v:
      set mpirun_verbose = 1
      breaksw
    case -mr_t:
    case -t:
      set just_testing = 1
      breaksw
    case -mr_dbx:
    case -dbx:
      set debugger = "dbx"
      set commandfile = "-sr"
      breaksw
    case -mr_gdb:
    case -gdb:
      set debugger = "gdb"
      set commandfile = "-x"
      breaksw
#    case -mr_xdbx:
#    case -xdbx:
#      set debugger = "xdbx"
#      breaksw
    case -mr_nopoll:
    case -nopoll:
	set polling_mode = 0
	breaksw
    case -mr_maxtime:
    case -maxtime
	@ j++
        set max_time = "$argv[$j]"
        breaksw
    case -mr_mvhome:
    case -mvhome:
        set mvhome = 1
        breaksw
    case -mvback:
	@ j++
	set mvback = "$argv[$j]"
	breaksw
    case -cac:
	@ j++
        set CAC = "$argv[$j]"
        breaksw
    case -echo:
	# this is for debugging
	set echo
	breaksw
    case -usage:
    case -help:
    case -?:
      # Accept these for help until the program name is provided.
      if ("$progname" == "") goto PrintHelp
      breaksw
    default:
      # The first unrecognized argument is assumed to be the name of
      # the program, but only if it is executable
      if ( "$progname" == "" && "$fake_progname" == "" && \
		! -e "${argv[$j]}" ) then
	set fake_progname = $argv[$j]
      else if ("$progname" == "" && -e "${argv[$j]}" ) then 
	set progname = $argv[$j]
	@ j++
        # any following unrecognized arguments are assumed to be arguments
        # to be passed to the program, as well as all future args
	# We can't use use_execer here to decide how to store the
	# arguments, since we may later change it (see the switch on arch)
	# Thus we store the args in tow forms
	while ("$j" <= "$#argv")
	  set arg = "$argv[$j]"
          set cmdLineArgsExecer = "$cmdLineArgsExecer -arg=${argv[$j]}"
          set cmdLineArgs = "$cmdLineArgs ${argv[$j]}"
	  @ j++
        end
      else
	echo "Warning: Command line arguments for program should be given"
        echo "after the program name.  Assuming that ${argv[$j]} is a"
        echo "command line argument for the program."
        set cmdLineArgsExecer = "$cmdLineArgsExecer -arg=${argv[$j]}"
        set cmdLineArgs = "$cmdLineArgs ${argv[$j]}"
        endif	
      endif
      breaksw
  endsw
  @ j++
end

if ($?MPI_USEP4SSPORT && $?MPI_P4SSPORT) then
    if ($MPI_USEP4SSPORT == "yes" || $MPI_USEP4SSPORT == "YES") then
        set p4ssport = $MPI_P4SSPORT
    endif
endif

# We need at least the program name

if ("$progname" == "") then
  echo "Missing: program name"
  if ("$fake_progname" != "") then
      echo "Program $fake_progname either does not exist, is not "
      echo "executable, or is an erroneous argument to mpirun."
  endif
  exit 1
endif

# Try to find the architecture.  Note that many systems do not have 
# arch, and that some systems (RS6000's for example) use "uname -m" 
# to return difficult to interpret info (RS6000s return a string of 
# digits that encodes the particular RS6000 model).
      
#
# Eventually we'll want to use "which" to try and find a version of 
# arch...
if ("$arch" == "") then
  if ( -e /bin/arch) then
      set ARCH=`/bin/arch` 
  else if ( -e /usr/local/bin/arch) then
      set ARCH=`/usr/local/bin/arch` 
  else if ( -e /usr/ucb/arch) then
      set ARCH=`/usr/ucb/arch` 
  else
      set ARCH=`uname -s`
      if ("$ARCH" == "AIX") then
        set ARCH = "AIX"
      else if ("$ARCH" == "ULTRIX") then
        set ARCH = `/bin/uname -m`
        if ("$ARCH" == "RISC") then
            set ARCH = "dec5000"
        endif
      else if ("$ARCH" == "HP-UX") then
	set ARCH = "HP-UX"
      else if ("$ARCH" == "IRIX64") then
	set ARCH = "IRIX"
      else if ("$ARCH" == "Linux") then
        true
      else if ("$ARCH" != "IRIX") then 
        set ARCH = `/bin/uname -m`
      endif
  endif

  # archlist contains a list of synonyms for the arch; this is needed for
  # the machines file (which has one choice of extension).
  set archlist = "$arch"
  switch ("$ARCH")
    case sun4:
    case sun4m:
    case sun4c:
      # There are others
      set Version = `/bin/uname -r`
      # In "improving" SunOS, the useful feature of "substr" was withdrawn 
      # from expr.  Can't let the users have life too easy, can we?  This 
      # means that we can't just use 
      #   set MajorVersion = `expr substr $Version 1 1`
      # because it won't work on Solaris systems.  The following should work on
      # both:
      set MajorVersion = `expr "$Version" : "\(.\)"`
      if ("$MajorVersion" ==  5) then
	# It really is solaris, but we don't care
        set arch="solaris"
      else
        set arch="sun4"
      endif
      set archlist = "$arch"
      breaksw
    case "cray":
    case "CRAY Y-MP":
      set arch="CRAY"
      breaksw
    case alpha:
      set arch="alpha"
      breaksw
    case hpux:
    case hp9000s735:
    case HP-UX:
      set arch=HP-UX
      set archlist = "hpux hp9000s700 hp9000s735 HP-UX"
      breaksw
    case NeXT:
      set arch=NeXT
      breaksw
    case AIX:
      set arch=rs6000
      breaksw
    case IRIX:
    case sgi:
      set arch="IRIX"
      set archlist = "IRIX sgi"
      breaksw
    case freebsd:
      set arch="freebsd"
      breaksw
    case paragon:
      set arch="paragon"
      breaksw
    case ksr:
      set arch="ksr"
      breaksw
    case i386:
    case symm_ptx:
      set arch="symm_ptx"
      set archlist = "i386 symm_ptr"
      breaksw
    case IP19:
    case IP21:
      set arch="sgi_mp"
      set archlist = "sgi_mp IP19 IP21"
      breaksw
    case ipsc860:
    case i860:
    case ipsc:
      set arch="ipsc860"
      set archlist = "ipsc860 i860 ipsc"
      breaksw
    default:
      echo "Cannot determine machine architecture. Use the '-arch <arch>'"
      echo "flag or the '-machine <machine_name>' flag. Defaulting"
      echo "to $default_arch"
      set arch=$default_arch
      breaksw
  endsw
endif
if ( "$archlist" == "" ) then
    set archlist = "$arch"
endif
#
# Some last-minute fixups
#
# 
# Warning: Some systems (OSF 1 at least) have a command called dbx
# with different command-line arguments.  In particular, it needs
# -c here (and that does not implement the remove part of the -sr).
#
# Turns out that this doesn't matter so much, because the dbx is terribly,
# terribly crippled.  
#
if ("$debugger" == "dbx" && "$arch" == "alpha") then
    set commandfile = "-c"
    set rmcommandfile = "/bin/rm -f"
endif
#
# Try to find the machine
if ("$machine" == "") then 
  switch ($arch)
    case sun4:
    case solaris:
      # This device should only exits on sun4s that are actually
      # MEIKO machines.
      if ( -e /dev/elan ) then
	set machine="meiko"
      else
      if ("$default_device" == "chameleon") then
	set machine="chameleon"
      else
      if (("$default_device" == "ch_p4") && ($use_execer == 0)) then
	set machine="p4"
      else
        set machine="execer"
      endif
      endif
      endif
      breaksw
    case cray:
    case CRAY:
    case HP-UX:
    case NeXT:
    case alpha:
    case IRIX:
    case freebsd:
      if ("$default_device" == "chameleon") then
	set machine="chameleon"
      else if (("$default_device" == "ch_p4") && ($use_execer == 0)) then
	set machine="p4"
      else
        set machine="execer"
      endif
      breaksw
    case rs6000:
      # This only works on the ANL sp system
      echo `hostname` | grep spnode > /dev/null
      if ($status == 0) then
        # This is the correct version to use once we're on a node
	set machine="ibmspx"
      else if (-d /etc/FRAMES && -d /mcs) then
        set machine="anlspx"
      else if ("$default_device" == "chameleon") then
	set machine="chameleon"
      else if (("$default_device" == "ch_p4") && ($use_execer == 0)) then
	set machine="p4"
      else if (("$default_device" == "ch_p4") && ($use_execer == 1)) then
	set machine="execer"
      else if (-e /usr/lpp/euih/eui) then
        set machine="sp1"
      else if (-e /usr/bin/poe || -e /usr/lpp/poe/bin/poe) then
        # should work for other users
        set machine="ibmspx"
      else
	 echo "Can't determine the type of the machine this is."
         echo "Set it with -machine <machine_type>."
      endif
      breaksw
    case paragon:
      set machine="paragon"
      breaksw
    case ipsc860:
    case i860:
    case ipsc:
      set machine="ipsc860"
      breaksw
    case ksr:
      set machine="ksr"
      breaksw
    case symm_ptx:
    case i386:
      set machine="symm_ptx"
      breaksw
    case sgi_mp:
      set machine="sgi_mp"
      breaksw
    case cray_t3d:
      set machine="cray_t3d"
      breaksw
    default:
      echo "Can't determine the type of the machine this is."
      echo "Set it with -machine <machine_type>."
      breaksw
  endsw
endif

# Fill out relative program pathnames

# Get the current directory
if ($?PWD == 1) then
    set PWD_TRIAL = $PWD
else
    set PWD_TRIAL = `pwd`
endif
if ( "$PWD_TRIAL" != "" ) then
    set PWD_TRIAL = `pwd | sed -e 's%/tmp_mnt/%/%g'`
    if ( ! -d $PWD_TRIAL )  then 
        echo "Warning: your default path uses the automounter; this may"
        echo "cause some problems if you use other NFS-connected systems."
        set PWD_TRIAL = `pwd`
    endif
endif

set tail=`echo $progname | sed 's/\/.*//'` 
if ("$tail" == "") then
  #echo Absolute path, don't need to change anything
else
  #echo Relative path
  set progname = "$PWD_TRIAL/$progname"
endif

# Get value of host
if ( $?HOST == 0 ) then
    set HOST = ""
    if ($arch == "ipsc860") then
	set HOST = `hostname`
    else
	set HOSTNAMEPGM = "`which hostname | head -1`"
        if (-e "$HOSTNAMEPGM") set HOST = "`hostname`"
	
    endif
    # Note that uname -n may not produce a usable hostname.  Any suggestions?
    if ("$HOST" == "") set HOST = "`uname -n`"
endif

if ($mpirun_verbose) then
  echo "running $progname on $np ${arch} ${machine} processors"
endif

# Make sure that the application is in the .p4apps file.  Note that 
# progname is already an absolute path
if ("$p4ssport" != "") then
    if (-e ~/.p4apps) then
        grep $progname ~/.p4apps >& /dev/null
        if ($status != 0) then 
	    echo "$progname" >> ~/.p4apps
            chmod 600 ~/.p4apps
	endif
    else
	echo "$progname" >> ~/.p4apps
        chmod 600 ~/.p4apps
    endif
    set cmdLineArgs = "$cmdLineArgs -p4ssport $p4ssport"
endif
#
if (("$machine" == "execer") || ("$machine" == "p4")) then
  if ($nolocal) then
    #echo don\'t run local instance
    # if the job is not to be run locally, then don't include this machine
    # in the list
    set procFound = 0
  else
    # echo run local instance
    if ("$machine" == "execer") then
      set cmdline = "$cmdline -host=${HOST} -pgm=${progname} -numprocs=1 $cmdLineArgsExecer"
    endif
    set procFound = 1
  endif

  if ("$machineFile" == "") then
    # If on the ANL SPx, use getjid to get the machine list...
    if ("$machine" == "ibmspx" && -e /usr/local/bin/getjid) then
	set machineFile = "/sphome/$LOGNAME/SPnodes.`/usr/local/bin/getjid`"
    else
        foreach march ($archlist)
            set machineFile = "${MPIR_HOME}/util/machines/machines.${march}"
	    if ( -e $machineFile ) break
	end
    endif
  endif

  if (!(-e "$machineFile" && -r "$machineFile")) then
    if ($nolocal != 0 || $np != 1) then
        echo Cannot read $machineFile.  Exiting.
	echo Looked for files with extension $archlist.
        exit 1
    endif
  endif

  if ($nolocal == 0) then
      set machinesfound=(`head -${np} $machineFile`)
  else
      if ($np > 1) then
      # Remove host from the list of available machines....
      set machinesfound=(`cat $machineFile | grep -v $HOST | head -${np}`)
      else
      set machinesfound=""
      endif
  endif

  @ nfound = $#machinesfound + $procFound
  if ($nfound < $np) then
    echo "Only $nfound ${arch}'s available.  Exiting."
    exit 1
  endif

  # Get the machine list

  set machinelist = ()
  set machineNum = 1
  # KeepHost suggested by Marc A. Viredaz; allows the same machine
  # to be listed multiple times in the machines file.
  set KeepHost = 0
  while ("$procFound" < "$np")
    set machineName = "${machinesfound[$machineNum]}"
    if ($mpirun_verbose) then
      echo "running on $machineName"
    endif
    if ("$machine" == "execer") then
      if ("$nolocal" || $KeepHost || ("$machineName" != "$HOST")) then
	set cmdline = "$cmdline -host=${machineName} -pgm=${progname} -numprocs=1 $cmdLineArgsExecer"
	@ procFound++
      endif
    else
      if ($nolocal || $KeepHost || ("$machineName" != "$HOST")) then
	set machinelist = ($machinelist $machineName)
	@ procFound++
      endif
    endif
    # If we see $HOST again, allow it to be used.
    if ("$machineName" == "$HOST") set KeepHost = 1
    @ machineNum++
  end
endif

switch ($machine)
  case meiko:
    # Note that the file /opt/MEIKOcs2/<machinename>/machine.des contains
    # detailed information on the structure of the machine (i.e., 
    # which nodes have disks, vector boards, etc).
    if ($just_testing) then
      if ("$debugger" != "") then
          echo "totalview prun -a -n$np $progname $cmdLineArgs"
      else
          echo ${MEIKO_RUN} -n $np $progname $cmdLineArgs  
      endif
    else
      if ("$debugger" != "") then
          totalview prun -a -n$np $progname $cmdLineArgs
      else
          ${MEIKO_RUN} -n $np $progname $cmdLineArgs 
      endif
    endif
    breaksw
  case ksr:
    if ("$p4pgfile" == "") then
        @ np--
        set p4pgfile = "$PWD_TRIAL/PI$$"
        if ($just_testing) then
          echo "local $np $progname"
        else
          echo "local $np $progname" >  "$p4pgfile"
        endif
        @ np++
    if ($just_testing) then
      echo $progname $cmdLineArgs -p4pg "$p4pgfile"
    else
      $progname $cmdLineArgs -p4pg "$p4pgfile"
      if ($leavePGFile) then
        echo "P4 procgroup file is $p4pgfile"
      else
        /bin/rm "$p4pgfile"
      endif
    endif
    breaksw
  case sgi_mp:
    if ("$p4pgfile" == "") then
	set p4pgfile = "$PWD_TRIAL/PI$$"
        @ np--
        if ($just_testing) then
            echo "local $np $progname"
        else
            echo "local $np $progname" >  "$p4pgfile"
        endif
        @ np++
    endif
    if ($just_testing) then
      echo $progname $cmdLineArgs -p4pg "$p4pgfile"
    else
      $progname $cmdLineArgs -p4pg "$p4pgfile"
      if ($leavePGFile) then
        echo "P4 procgroup file is $p4pgfile."
      else
        /bin/rm "$p4pgfile"
      endif
    endif
    breaksw
  case symm_ptx:
    if ("$p4pgfile" == "") then
	set p4pgfile = "$PWD_TRIAL/PI$$"
        @ np--
        if ($just_testing) then
            echo "local $np $progname"
        else
            echo "local $np $progname" >  "$p4pgfile"
        endif
        @ np++
    endif
    if ($just_testing) then
      echo $progname $cmdLineArgs -p4pg "$p4pgfile"
    else
      $progname $cmdLineArgs -p4pg "$p4pgfile"
      if ($leavePGFile) then
        echo "P4 procgroup file is $p4pgfile."
      else
        /bin/rm "$p4pgfile"
      endif
    endif
    breaksw
  case cray_t3d:
    # Untested.  Only does the interactive (non-NQS submission)
    if ($just_testing) then
        echo $progname -npes $np $cmdLineArgs
    else
        $progname -npes $np $cmdLineArgs
    endif
    breaksw
  case ibmspx:
    # This only works on SPx running release 2 software and with
    # the high-performance switch.  Note that we need to parameterize
    # the hostlist somehow.
    # See /cave3/vroom-51/bash/sp1/sp2.hosts for MM machine hosts,
    # /sphome/gropp/mpich/examples/test/pt2pt/hostlist for DIS hosts
    # use 
    #   MP_EUILIB ip 
    # for ip over the switch
    # Other variables to consider:
    # setenv MP_PMDLOG yes
    # setenv PWD $PWD_TRIAL
    # setenv MP_INFOLEVEL 1 
    # setenv MP_INFOLEVEL 20
    # setenv MP_CSS_INTERRUPT ?
    # MP_PULSE must be 0 to get performance (some problem with defaults
    # in GA code)
    # setenv MP_PULSE 0
    # Note that if the executable is not on a file system mounted 
    # on a node, you may get a strange error message.
    if ($just_testing) then
        echo setenv MP_EUILIB us
	echo setenv MP_RMPOOL 0
        echo setenv MP_HOSTFILE $machineFile
        echo setenv MP_PROCS $np
	echo setenv MP_INFOLEVEL 0
        echo setenv MP_PULSE 0
	if ($polling_mode == 0) echo setenv MP_CSS_INTERRUPT yes
        echo poe $progname $cmdLineArgs
    else
        setenv MP_EUILIB us
	setenv MP_RMPOOL 0
        setenv MP_HOSTFILE $machineFile
        setenv MP_PROCS $np
	setenv MP_INFOLEVEL 0
        setenv MP_PULSE 0
	if ($polling_mode == 0) setenv MP_CSS_INTERRUPT yes
        poe $progname $cmdLineArgs
    endif
    breaksw
  case sp1:
    # This is for the old MPL/p or EUI-H environment
    if ($just_testing) then
      echo ${SP1_RUN} $progname $np $cmdLineArgs
    else
      ${SP1_RUN} $progname $np $cmdLineArgs
    endif
    breaksw
  case anlspx:
    # This if for the ANL SP1/2, using the ANL "spsubmit" program.
    # Users of "loadleveler" will probably want something like this
    # Create a new file
    if ($mvhome == 1) then
        set localpgm = `basename $progname`
	# if mvhome set, and the executable does NOT exist, then
	# remove it when we exit
	if ( -e /sphome/$LOGNAME/$localpgm ) then
	    set rmhome = 0
	else
	    set rmhome = 1
	endif 
	if ($just_testing) then
	    echo cp $progname /sphome/$LOGNAME/$localpgm
	else
	    # If you don't remove the file first, sometimes the 
	    # WRONG FILE (the OLD ONE) is found by the system.
	    /bin/rm -f /sphome/$LOGNAME/$localpgm
	    if (-e /sphome/$LOGNAME/$localpgm) then
	        echo "Could not move $progname to /sphome/$LOGNAME/$localpgm"
		if (-d /sphome/$LOGNAME/$localpgm) then
		   echo "Destination is a directory!"
		endif
	        exit 1
	    endif
	    cp $progname /sphome/$LOGNAME/$localpgm
	endif
	set PWD_LOCAL = /sphome/$LOGNAME
    else
	set rmhome = 0
	set localpgm = $progname
	set PWD_LOCAL = $PWD_TRIAL
    endif
    /bin/rm -f $PWD_LOCAL/PIrun
    /bin/rm -f /sphome/$LOGNAME/job.output
    cat >$PWD_LOCAL/PIrun <<.
#! /bin/sh
JID=\`/usr/local/bin/getjid\`
trap "sprelease \$JID"
cd $PWD_LOCAL
MP_EUILIB=us
MP_RMPOOL=0
MP_HOSTFILE=/sphome/$LOGNAME/SPnodes.\$JID    
MP_PROCS=$np
MP_INFOLEVEL=0
MP_HOLD_STDIN=YES
MP_PULSE=0
export MP_EUILIB
export MP_RMPOOL
export MP_HOSTFILE
export MP_PROCS
export MP_INFOLEVEL
export MP_HOLD_STDIN
export MP_PULSE
if [ $polling_mode = 0 ] ; then
   MP_CSS_INTERRUPT=YES
   export MP_CSS_INTERRUPT
fi
/bin/rm -f /sphome/$LOGNAME/job.output
if [ $mpirun_verbose = 1 ] ; then
    echo "About to run poe ... " >> /sphome/$LOGNAME/job.output
fi
poe $localpgm $cmdLineArgs >> /sphome/$LOGNAME/job.output 2>&1
if [ $mpirun_verbose = 1 ] ; then
    echo "Poe exited ..." >> /sphome/$LOGNAME/job.output
fi
sprelease \$JID
exit 0
.
    chmod a+x $PWD_LOCAL/PIrun
    # Determine CAC
    if ("$CAC" == "") then
       set CAC = `whatcac | head -1 | cut -d' ' -f 9 | sed -e s/\"//g -e s/://`
    endif
    if ($just_testing) then
	echo "spsubmit2 -nomail <<."
	echo $CAC
	echo $max_time
	echo $np
	echo B
	echo M
	echo n
	echo $PWD_LOCAL/PIrun
	echo 
	echo C
	echo .
        echo spwait
	if ($rmhome == 1) then
	    echo "/bin/rm /sphome/$LOGNAME/$localpgm"
	endif
	if ("$mvback" != "") then
	    echo "(cd $PWD_LOCAL ; cp $mvback $PWD_TRIAL ; /bin/rm $mvback )"
        endif
    else
        # Send output to /dev/null in case we're trying to 
        # use this to match up output
	set JID = `/usr/local/bin/getjid`
	if "$JID" != "" then 
	    echo "Can not start SP job while one is in the queue"
	    echo "Job $JID was found"
	    exit 1
	endif
	spsubmit2 -nomail <<. >& /dev/null 
$CAC
$max_time
$np
B
M
n
$PWD_LOCAL/PIrun

C
.
	set JID = `/usr/local/bin/getjid`
	spwait
	if ($rmhome == 1) then
	   /bin/rm /sphome/$LOGNAME/$localpgm
	endif
	/bin/rm -f /sphome/$LOGNAME/SPnodes.$JID
	if ("$mvback" != "") then
	    (cd $PWD_LOCAL ; cp $mvback $PWD_TRIAL ; /bin/rm $mvback )
        endif
	if (-e /sphome/$LOGNAME/job.output) then 
	    cat /sphome/$LOGNAME/job.output
	else
	    echo "No output file!  Job did not run! "
	endif
    endif
    breaksw
  case paragon:
    if ($just_testing) then
      echo $progname -sz $np $cmdLineArgs
    else
      $progname -sz $np $cmdLineArgs
    endif
    breaksw
  case inteldelta:
    # This script must actually be run ON the Delta (more accurately, 
    # on a Delta service node), which this does by invoking rsh.
    # If the rsh fails, check your permissions.
    # A similiar script could be used on Intel i860 systems
    # UNTESTED
    if ($just_testing) then
      echo '$rshcmd delta1 mexec -t"'"$np"'" -f ' $progname $cmdLineArgs
    else
      $rshcmd delta1 mexec -t"$np" -f $progname $cmdLineArgs
    endif
    breaksw
  case i860:
  case ipsc860:
    if ($just_testing) then
      echo "getcube -t $np"
      echo "load $progname $cmdLineArgs"
      echo "waitcube"
      echo "relcube"
    else
      getcube -t $np
      if ($status != 0) then
	 echo "Requested number of nodes not available"
      else
         load $progname $cmdLineArgs
         waitcube
         relcube
      endif
    endif
    breaksw

  case chameleon:
    if ($just_testing) then
      echo $progname -np $np $cmdLineArgs
    else
      $progname -np $np $cmdLineArgs
    endif
    breaksw
  case execer:
    set PWD_LOCAL = $HOME
    if ($just_testing) then
      echo $EXECER "-jobid=$jobid" $cmdline
      if ("$mvback" != "") then
	 echo "(cd $PWD_LOCAL ; cp $mvback $PWD_TRIAL ; /bin/rm $mvback )"
      endif
    else
      $EXECER "-jobid=$jobid" $cmdline
      if ("$mvback" != "") then
	  (cd $PWD_LOCAL ; cp $mvback $PWD_TRIAL ; /bin/rm $mvback )
      endif
    endif
    breaksw
  case p4:
    # We use this form instead of "local 0" in-case the user is trying to
    # select a second network whose names are not those returned by
    # "hostname".  For example, a system with a DEC Gigiswitch, Myricom 
    # network, or IP over the IBM SP2 switch (HPS).
    if ("$p4pgfile" == "") then
	set p4pgfile = "$PWD_TRIAL/PI$$"
        if ($just_testing) then
           echo "Procgroup file:"
           if ($nolocal) then
	      echo "$machinelist[1] 0 $progname"
           else 
	      echo "$HOST 0 $progname"
           endif
        else
           if ($nolocal) then
	       echo "$machinelist[1] 0 $progname" > "$p4pgfile"
           else 
	       echo "$HOST 0 $progname" > "$p4pgfile"
           endif
        endif

        if ($nolocal) then
           set procNum = 2
        else
           set procNum = 1
        endif

        while ($procNum <= ${#machinelist})
           if ($just_testing) then
	       echo "${machinelist[$procNum]} 1 $progname"
           else
	       echo "${machinelist[$procNum]} 1 $progname" >> "$p4pgfile"
           endif
           @ procNum++
        end

        # make sure the procgroup file was written
        if (!($just_testing) && \
	    !(-e "$p4pgfile" && -r "$p4pgfile")) then
            echo Failed to write "$p4pgfile".  Exiting.
            exit 1
        endif

        if (!($just_testing) && $mpirun_verbose) then
          echo Created "$p4pgfile"
        endif
    endif

    set startpgm = "eval"
    if ("$debugger" != "") then
	cat > $PWD_TRIAL/PId$$ <<.
# Use this command to start your programm:
run  $cmdLineArgs -p4pg $p4pgfile
.
	set startpgm = "$debugger $progname $commandfile $PWD_TRIAL/PId$$"
    endif
    #
    if ($just_testing) then
      echo ""
      if ($nolocal) then
	echo $rshcmd ${machinelist[1]} $progname  $cmdLineArgs -p4pg "$p4pgfile"
      else
	echo $progname  $cmdLineArgs -p4pg "$p4pgfile"
      endif
    else
      if ($nolocal) then
        if ("$debugger" != "") then
	  $rshcmd ${machinelist[1]} $debugger $commandfile $PWD_TRIAL/PId$$ $progname 
        else
	  $rshcmd ${machinelist[1]} $progname $cmdLineArgs -p4pg "$p4pgfile"
	endif
      else
        if ("$debugger" != "") then
	    $debugger $commandfile $PWD_TRIAL/PId$$ $progname
	else
	    $progname  $cmdLineArgs -p4pg "$p4pgfile"
	endif
      endif # nolocal
      if ($leavePGFile) then
	echo "P4 procgroup file is $p4pgfile."
      else
        /bin/rm "$p4pgfile"
      endif
    endif #just testing
    breaksw

  case smp:
    # ch_shmem device
    if ($just_testing) then
      if ("$debugger" != "") then
          echo $debugger $progname
      else
          echo $progname $cmdLineArgs -np $np
      endif
    else
      if ("$debugger" != "") then 
	  cat > $PWD_TRIAL/PId$$ <<.
run -np $np $cmdLineArgs
.
	  $debugger $progname $commandfile $PWD_TRIAL/PId$$
      else
          $progname $cmdLineArgs -np $np
      endif
    endif
    breaksw

  # case smt: thread version of smp code

  default:
    echo "This machine ($machine) is not yet supported."
    echo Exiting.
    exit 1
    breaksw
endsw

exit 0

PrintHelp:
cat <<EOF
mpirun [mpirun_options...] <progname> [options...]

  mpirun_options:
    -arch <architecture>
            specify the architecture (must have matching machines.<arch>
            file in ${MPIR_HOME}/util/machines) if using the execer
    -h      This help
    -machine <machine name>
            use startup procedure for <machine name>
            Currently supported:
EOF
foreach machine ($Machines)
  echo "              $machine"
end
cat <<EOF

    -machinefile <machine-file name>
            Take the list of possible machines to run on from the
            file <machine-file name>
    -np <np>
            specify the number of processors to run on
    -nolocal
            don't run on the local machine (only works for 
            p4 and ch_p4 jobs)
    -e      Use execer to start the program on workstation
            clusters
    -pg     Use a procgroup file to start the p4 programs, not execer
            (default)
    -leave_pg
            Don't delete the P4 procgroup file after running
    -p4pg filename
            Use the given p4 procgroup file instead of creating one.
            Overrides -np and -nolocal, selects -leave_pg.
    -p4ssport num
            Use the p4 secure server with port number num to start the
            programs.  If num is 0, use the value of the 
            environment variable MPI_P4SSPORT.  Using the server can
            speed up process startup.  If MPI_USEP4SSPORT as well as
            MPI_P4SSPORT are set, then that has the effect of giving
            mpirun the -p4ssport 0 parameters.
    -t      Testing - do not actually run, just print what would be
            executed
    -v      Verbose - throw in some comments
    -dbx    Start the first process under dbx where possible
    -gdb    Start the first process under gdb where possible
             (on the Meiko, selecting either -dbx or -gdb starts prun
             under totalview instead)
    -nopoll Do not use a polling-mode communication.
            Available only on IBM SPx.
    -mvhome Move the executable to the home directory.  This 
            is needed when all file systems are not cross-mounted
            Currently only used by anlspx
    -mvback files
            Move the indicated files back to the current directory.
            Needed only when using -mvhome; has no effect otherwise.
    -maxtime min
            Maximum job run time in minutes.  Currently used only
            by anlspx.  Default value is $max_time
    -cac name
            CAC for ANL scheduler.  Currently used only by anlspx.
            If not provided will choose some valid CAC.

On exit, mpirun returns a status of zero unless mpirun detected a problem, in
which case it returns a non-zero status (currently, all are one, but this 
may change in the future).

EOF

#    -xdbx   Start the first process under xdbx where possible

exit
