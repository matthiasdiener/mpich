#! /bin/sh

#
# Based largely on the mpirun.ch_p4.in file.
#
#
# The following makes a statement that is true of ALL versions of MPIRUN, 
# and hence is redundent.
#
#echo "Notice:  This is not the using the full features of the Nexus" 2>&1
#echo "Notice:  runtime.   To do so, you should try to run the program" 2>&1
#echo "Notice:  directly instead." 2>&1

my_subjob_idx=0

createRslJob() {
    my_np=$1
    my_cnt=$2
    my_cmdLineArgs=$3
    my_dirname=$4
    my_progname=$5
    my_stage_file=$6

    while read line; do
        contact="`echo \"$line\" | cut -d'\"' -f2`"
        count="`echo \"$line\"  | cut -d'\"' -f3 | sed -e 's/ //g'`"
	
	if [ "$count" -eq 0 ]; then
	    count=1
	fi

	if [ `expr $count + $my_cnt` -gt $my_np ]; then
	    count=`expr $my_np - $my_cnt`;
	fi

	echo "( &(resourceManagerContact=\"$contact\") "
	echo "   (count=$count)"
	echo "   (label=\"subjob $my_cnt\")"
        echo "   (environment=(GLOBUS_DUROC_SUBJOB_INDEX $my_subjob_idx))"
#
# Need to test that $my_cmdLineArgs is non-empty AND that it is
# not equal to a single space because mpirun.args will set $my_cmdLineArgs
# to a single space when there are no args.  This only seems to
# happen on DEC ALPHAs.
#
        if [ -n "$my_cmdLineArgs" -a "$my_cmdLineArgs" != ' ' ]; then
	    echo "   (arguments=$my_cmdLineArgs)"
	fi
	if [ $my_stage_file -eq 0 ]; then
	    echo "   (directory=$my_dirname)"
	    echo "   (executable=$my_progname)"
	else
	    echo "   (executable=\$(GLOBUSRUN_GASS_URL)$my_progname)"
	fi
	echo ")"

	my_cnt=`expr $my_cnt + $count`
        my_subjob_idx=`expr $my_subjob_idx + 1`
        if [ $my_cnt -eq $my_np ]; then
	    break;
	fi
    done;

    return $my_cnt
}
#
# If this program was started up without the arguments being passed, we
# must first set up the arguments
#
if [ -z "$MPIR_HOME" ] ; then
  MPIR_HOME=#MPIR_HOME#
fi
if [ "$MPIR_HOME" = "#""MPIR_HOME""#" ] ; then
  MPIR_HOME=`pwd`/..
fi
if [ "#MPIRUN_BIN#" = "#""MPIRUN_BIN""#" ] ; then 
    MPIRUN_HOME=$MPIR_HOME/bin
else
    MPIRUN_HOME=$MPIR_HOME/#MPIRUN_BIN#
fi
if [ -z "$argsset" ] ; then
  . $MPIRUN_HOME/mpirun.args
  argsset=1
fi

globus_cleanup_files=""
globus_machine_file=""
globusrun_rsl_file=""
globus_stage_file=0
globus_dump_rsl=0
#
# "-globusrsl <filename>" sets $globuspgfile=<filename>
# "-machinefile <filename>" sets $machineFile=<filename>
#

#parse -globusargs "aa bb cc" arguments
if [ ! -z "$globusargs" ]; then
    set $globusargs
fi
while [ ! -z "$1" ]; do
    case $1 in
    stage)
	globus_stage_file=1
	;;
    nostage)
	globus_stage_file=0
	;;
    dumprsl)
	globus_dump_rsl=1
	;;
    esac
    shift
done

if [ -n "$globuspgfile" ] ; then
    globusrun_rsl_file=$globuspgfile

else

    if [ -n "$machineFile" ] ; then
        globus_machine_file=$machineFile
    elif [ -r "machines" ] ; then
        globus_machine_file="machines"
    elif [ -r "$MPIRUN_HOME/machines" ] ; then
        globus_machine_file="$MPIRUN_HOME/machines"
    elif [ -n "$MPIRUN_GLOBUS_CONTACTSTRING" ] ; then
        echo "\"$MPIRUN_GLOBUS_CONTACTSTRING\"" > mpirun.machines
        globus_cleanup_files="$globus_cleanup_files mpirun.machines"
        globus_machine_file=mpirun.machines
    else
        #
        # Machines file not found.
        #
        echo "ERROR: You must specify which machines to run on with one of the following:"
        echo "       \"-globusrsl filename\" argument"
        echo "       \"-machinefile filename\" argument"
        echo "       A file named \"machines\" in the current directory"
        echo "       A file named \"machines\" in $MPIRUN_HOME"
        echo "       MPIRUN_GLOBUS_CONTACTSTRING environment variable"
        exit 1
    fi

    if [ -z "$globus_machine_file" -a ! -r "$globus_machine_file" ] ; then
        echo "ERROR: machines file \($globus_machine_file\) is not readable"
        exit 1
    fi

    #
    # use ldap to find complete manager contact information
    #
    rm -f mpirun.machines.$$
    globus_cleanup_files="$globus_cleanup_files mpirun.machines.$$"
    if [ -x "#GLOBUSDIR#/tools/bin/globus-hostname2contacts" ]; then
	cat $globus_machine_file | \
	while read line
        do
		if [ `echo $line | grep -c '"'` -eq 0 ]; then
			contact=`echo $line | awk '{print $1}'`;
			count=`echo $line | awk '{print $2}'`;
		else
			contact="`echo \"$line\" | awk -F'\"' '{print $2}'`"
			count=`echo $line | awk -F'"' '{print $3}' | sed -e s'/ //g'`
		fi

		if [  `echo $contact | grep -c ':'` -eq 0 ]; then
			contact=`#GLOBUSDIR#/tools/bin/globus-hostname2contacts $contact | head -1`
			if [ -z "$contact" ]; then
				echo "ERROR: Cannot resolve incomplete contact string in machines file: $line"
				exit 1
			fi
		fi

		echo "\"$contact\"" "$count" >> mpirun.machines.$$
	done
        globus_machine_file=mpirun.machines.$$
      else
        echo "WARNING: Cannot resolve incomplete contact strings. Trying anyway."
    fi

    #
    # Construct an RSL file from $globus_machine_file
    #
    globusrun_rsl_file=mpirun.rsl
    if [ "$leavePGFile" != "1" ] ; then
        globus_cleanup_files="$globus_cleanup_files $globusrun_rsl_file"
    fi

    echo "+" > $globusrun_rsl_file
    dirname=`dirname $progname`;

    cnt=0
    while [ $cnt -lt $np ]; do
	createRslJob "$np" "$cnt" "$cmdLineArgs" "$dirname" "$progname" "$globus_stage_file" \
	    < $globus_machine_file >> $globusrun_rsl_file
	cnt=$?

       if [ $cnt -ge $np ] ; then
           break
       fi

    done
fi

#
# Run globusrun with the rsl file
#
if [ "$globus_dump_rsl" = "1" ] ; then
    cat $globusrun_rsl_file
else
    if [ -x "#GLOBUSDIR#/tools/bin/globusrun" ]; then
	#GLOBUSDIR#/tools/bin/globusrun -mpirun 1 -w -f $globusrun_rsl_file
    else
	echo "ERROR: mpirun could not find" #GLOBUSDIR#/tools/bin/globusrun
    fi
fi

if [ -n "$globus_cleanup_files" ] ; then
    rm -f $globus_cleanup_files
fi
