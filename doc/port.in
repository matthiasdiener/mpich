#! /bin/sh
# This script is generated by configure for the purpose of reporting on
# the port of MPICH to a new architecture
#
# To simplify testing and a few special cases, this script takes a few options
# -author="name"        Use instead of 'whoami'
# -nomake               Do not run make
# -noperf               Do not run performance tests
# -file=name            Output LaTeX file (default is doc/doc1.tex)
author="`whoami`"
nomake=0
noperf=0
filename="doc/doc1.tex"
for arg in $* ; do
    case $arg in 
	-author=* )
	author="`echo $arg|sed 's/-author=//'`"
	;;
	-file=* )
	filename=`echo $arg|sed 's/-file=//'`
	;;
 	-nomake )
	nomake=1
	;;
 	-noperf )
	noperf=1
	;;
	*)
	echo "Unknown argument $arg"
	exit 1
	;;
    esac
done
#
############################################################################
# Some initial comments...
# sh is not reliable about processing redirects of stdin within if...else..fi
# For such cases, we place the output text within a routine, defined
# outside of the if..else..fi, and called conditionally.
############################################################################
############################################################################
/bin/rm -f $filename
############################################################################
# Create the preamble...
############################################################################
cat >> $filename <<.
\documentstyle[latexinfo,epsf]{article}
\begin{document}
\title{Porting the MPICH MPI implementation to the @ARCH@ system}
\author{$author}
\maketitle
\section{Introduction}
This document describes the porting of the Argonne National 
Laboratory/Mississippi State University portable implementation of MPI
to the @ARCH@ system.  

The MPICH implementation relies on a abstract device interface (ADI) for its
portability.  There are many possible implementation of this device; the one
used in this effort was @DEVICE@.

\section{Configuration}
This version of MPICH was configured with arguments {\tt @CONFIGURE_ARGS@}.
The configure script determined the various flags and programs to use; the
choices are described below.
.
############################################################################
# C Compiler options
############################################################################
cflags=" with flags {\tt @CFLAGS@}"
if test -z "@CFLAGS@" -o "@CFLAGS@" = " " ; then
   cflags=""
fi
cat >> $filename <<.
The C compiler used was {\tt @CC@}$cflags.
The linker for C programs is {\tt @CLINKER@}.
.
if test "@cross_compiling@" = 1 ; then
    cat >> $filename <<.
These are cross-compilers; some features that require running a program could
not be determined by the configure script.
.
fi
if test -n "@DEVCFLAGS@" ; then
    cat >> $filename <<.

Special flags were required to compile the ADI part of the code.  These 
flags were {\tt @DEVCFLAGS@}.
.
fi
if test -n "@INCLUDE_PATH@" ; then
    cat >> $filename <<.
A special include path of {\tt @INCLUDE_PATH@} was required.
.
fi
if test -n "@OPTFLAGS@" ; then
    cat >> $filename <<.
The flags {\tt @OPTFLAGS@} were used to control code optimization for the
compilers.
.
fi
############################################################################
# Fortran Compiler options
############################################################################
if test "@HAS_FORTRAN@" = 1 ; then
   fflags=" with flags {\tt @FFLAGS@}"
   if test -z "@FFLAGS@" ; then
      fflags=""
   fi
   cat >> $filename <<.
The Fortran compiler used was {\tt @F77@}$fflags.
The linker for Fortran programs is {\tt @FLINKER@}.
.
fi
############################################################################
# Other flags.  Eventually, these should be folded into the text
############################################################################
if test "@AR@" != "ar clr" ; then
    cat >> $filename <<.
This system required a special version of the object file archive program.
The program and options used were {\tt @AR@}.
.
fi
if test "@RANLIB@" = "true" ; then
echo "This system does not use {\\tt ranlib}" >> $filename
fi
if test "@CPRP@" != "cp" ; then
    cat >> $filename <<.
The {\tt cp} program on this system does not support the {\tt -r} or {\tt -p}
flags.  The program {\tt @CPRP@} is used instead.
.
fi
############################################################################
# User interface (compiler, linker, etc)
############################################################################
cat >> $filename <<.
\subsection{Special user flags and options}
On some systems, the user must set special options either when compiling or
when linking.  This section describes which special features must be used
when making MPI programs.
.
if test -n "@USER_CFLAGS@" ; then
    cat >> $filename <<.
Users compiling with C must use the flags {\tt @USER_CFLAGS@}.
.
fi
if test -n "@USER_INCLUDE_PATH@" ; then
    cat >> $filename <<.
Users compiling with C must add the include path {\tt @USER_INCLUDE_PATH@}.
.
fi
cat >> $filename <<.
C programs are linked by using the arguments {\tt @LIB_PATH@ @LIB_LIST@} with 
the C linker {\tt @CLINKER@}.
.
if test "@HAS_FORTRAN@" = 1 ; then
    cat >> $filename <<.
Fortran programs are linked by using the arguments 
{\tt @FLIB_PATH@ @LIB_LIST@} with the Fortran linker {\tt @FLINKER@}.   
.
fi
############################################################################
# Device - specific information
############################################################################
cat >> $filename <<.
\subsection{ADI Device}
MPICH uses a portable, flexible, and powerful {\em abstract device interface}
or ADI to 
perform the actual transmission of messages between processes.  Currently,
there is one base version of this device in {\tt mpid/chameleon}; versions
customized to specific message-passing systems are derived from these with
special text-transformation programs.  There are a number of configure options
that apply to all of the current versions.
.

if test "@NODEVDEBUG@" = 1 ; then
    cat >> $filename <<.

This version of the ADI was compiled without the ability to generate debugging
output when the command-line option -mpichdebug is used.
.
fi

if test "@USERNDV@" = 1 ; then
    cat >> $filename <<.

This version of the ADI was compiled to use a rendevous protocol for long
messages.  This protocol provides more reliable support for systems with
buffer limitations, and better performance when the underlying system 
software uses an eager protocol.
.
fi

if test "@PREPOST@" = 1 ; then
    cat >> $filename <<.

This version of the ADI pre-posts the receive used for control packets.
This can lead to better performance in some situations, particularly those
where most messages use the short message protocol.  This should only be
used when the underlying message-passing system provides non-blocking 
receives.
.
fi

if test "@PREALLOC@" = 1 ; then
    cat >> $filename <<.

This version of the ADI pre-allocates the storage for control packets.  This
is helpful primarily when the ch_p4 device is used and most messages are 
sent with the short message protocol.
.
fi

if test "@VARPKT@" = 1 ; then
    cat >> $filename <<.

This version of the ADI allows the user to change the cross-over point 
between the short and long message protocol with the {\tt -mpipktsize nn}
command-line option.
.
fi

if test "@COMPRESSEDPKT@" = 1 ; then
    cat >> $filename <<.

This version of the ADI uses a compressed format for the data in the envelope
part of the control packet.  This is appropriate for systems with slow
networks.
.
fi

if test -n "@PKTSIZE@" ; then
    cat >> $filename <<.

This version of the ADI has set the cross-over point from short to long
message protocols at $PKTSIZE.
.

fi
############################################################################
# Information on specific devices
############################################################################
if test "@DEVICE@" = "ch_p4" ; then 
    cat >> $filename <<.

This version of the ADI uses p4 \cite{p4} with CFLAGS = {\tt @P4_MDEPCFLAGS@}.
To p4, the name of the architecture of this system is {\tt @P4_ARCH@}. 
.
fi
#
#
chameleon_text1() {
cat >> $filename <<.

This version of the ADI uses the Chameleon device.  This device supports
many types of parallel environments.  

Chameleon is available in debugging (BOPT=g), production (BOPT=O) and 
profiling versions (BOPT=Opg).  The version used here is BOPT=@BOPT@.
The directory containing Chameleon is @TOOLS_DIR@.  

Chameleon uses makefile includes to provide a simple way to build the 
Chameleon libraries for multiple architectures.  The Chameleon ADI uses 
{\tt @DEVICE_MAKE_INCLUDE@} as the source of the makefile includes.
.
}

unknown_dev_text() {
cat >> $filename <<.

This version of the ADI uses $nametype calls.
.
}
#

if test "@DEVICE@" = "chameleon" ; then
    chameleon_text1;
    if test -n "@COMM@" ; then 
        echo "The COMM=@COMM@ transport layer was used." >> $filename
        if test "@COMM@" = "p4" ; then
	echo "The directory for p4 used was {\\tt @P4_DIR@}." >> $filename 
	fi
    else
        echo "The native MPP transport layer was used." >> $filename
    fi
else
    nametype=`echo @DEVICE@ | sed 's/ch_//g'`
    unknown_dev_text;
fi
if test -n "@GETNAME_DEFS@" ; then
    cat >> $filename <<.
This version of the ADI uses standard Unix system calls to get the name of the
processor.  The precise calls are selected in the ADI with the C definitions 
{\tt @GETNAME_DEFS@}.
.
fi

############################################################################
# MPE Libraries
############################################################################
if test -n "@MPE_DIR@" ; then
    cat >> $filename <<.
\section{MPE Libraries}
The MPICH implementation comes with several MPI libraries that provide
profiling, sequential sections, and optionally graphics.  This collection of
routines is called the MPE library.  Programs that use MPE routines must be
linked with {\tt @MPE_LIBS@} in addition to the MPI libraries.
.
#
    if test -n "@MPE_GRAPHICS@" ; then
        cat >> $filename <<.

The MPE libraries used {\tt @X_INC@} for the X11 includes and {\tt @X_LIB@}
for the X11 libraries.
.
    else
        cat >> $filename <<.

The MPE libraries did not include the X11 graphics routines.
.
    fi
fi
############################################################################
# All of the other items just to remind us...
############################################################################
cat >> $filename <<.
\subsection{Other configure variables}

There are a large number of configure variables.  This table sumarizes the
variables not described elsewhere and their values.

\begin{center}
\begin{tabular}{ll}
MPIR_HOME & @MPIR_HOME@ \\\\
PREFIX & @PREFIX@ \\\\
CPP_DIR & @CPP_DIR@ \\\\
CPP_COMPILER & @CPP_COMPILER@ \\\\
\end{tabular}
\end{center}
.
############################################################################
# Do the build and comment on it...
############################################################################
# Next, we run the make and time used to do the port
starthour=`date +%H`
startmin=`date +%M`
makefailed=0
if test $nomake = 0 ; then
    make >make.log 2>&1
    if [ $? != 0 ] ; then
	makefailed=1
    fi
fi
endhour=`date +%H`
endmin=`date +%M`
if test $endhour -lt $starthour ; then
    endhour=`expr $endhour + 24`
fi
totaltime=`expr $endhour \* 60 + $endmin - $starthour \* 60 - $startmin`
hours=`expr $totaltime / 60`
mins=`expr $totaltime - $hours \* 60`
if test $mins -lt 10 ; then
    mins="0$mins"
fi
if test $hours -lt 2 ; then
    if test $hours -lt 1 ; then
        hours=""
    else
        hours="one hour"
    fi
else
    hours="$hours hours"
fi
if test $mins -lt 2 ; then
    if test $mins -lt 1 ; then
        mins=""
    else
        mins="one minute"
    fi
else
    mins="$mins minutes"
fi
if test -n "$hours" ; then
    mins="and $mins"
fi
if test $nomake = 0 ; then 
    cat >>$filename <<.
\section{Building MPICH}
MPICH was built using the @MAKE@ program.
It took $hours $mins to run make to build the MPI libraries.
.
    #
    # Extract the error messages from the make.log file
    /bin/rm -rf doc/doc1make.log
    util/finderrors make.log > doc/doc1make.log
    if test -s doc/doc1make.log ; then
        echo "\\par Error messages from make" >> $filename
        echo '\begin{verbatim}' >> $filename
        cat doc/doc1make.log >> $filename
        echo '\end{verbatim}'   >> $filename
    else
        echo "\\par Make detected no errors during the build." >> $filename
    fi
    if test $makefailed = 1 ; then
        echo "The make failed to complete." >> $filename
    fi
else
    cat >>$filename <<.
\section{Building MPICH}
MPICH was not built using the the automated build and document program.
.
fi
#
############################################################################
# Performance of the system
############################################################################
#
############################################################################
# Run the performance tests
############################################################################
#
# i860's don't have which...
if test $noperf = 0 -a $makefailed = 0 ; then
gnuplotloc=`which gnuplot`

# We can generate the output graphs...
( cd examples/perftest ; /bin/rm -f maketst.log ; \
  make mpptest > maketst.log 2>&1 ; \
mpirun -mr_np 2 mpptest -gnuplot -tgoal 0.1 -auto > short.gpl ; \
echo "set terminal postscript eps" | cat - short.gpl > .foo ; \
echo "exit" | cat .foo - | sed /pause/d | \
sed -e 's/mppout/short-data/g' > short.gpl ; \
mv mppout.gpl short-data.gpl ; \
mpirun -mr_np 2 mpptest -gnuplot -tgoal 0.2 -auto -reps 100 \
    -size 16384 65536 1024 > long.gpl ; \
echo "set terminal postscript eps" | cat - long.gpl > .foo ; \
echo "exit" | cat .foo - | sed /pause/d | \
sed -e 's/mppout/long-data/g' > long.gpl ; \
mv mppout.gpl long-data.gpl ; \
)
    if test -f "$gnuplotloc" ; then
        (cd examples/perftest ; \
	/bin/rm -f short.eps long.eps ; \
        gnuplot short.gpl > short.eps ; \
        gnuplot long.gpl > long.eps ; \
        mv short.eps ../../doc ; mv long.eps ../../doc ; )
    fi
fi
if test $makefailed = 0 ; then
#
# Extract the performance numbers
if test -s examples/perftest/short.gpl ; then
    latency="`grep 'startup' examples/perftest/short.gpl | cut -d' ' -f 4,5`"
    latency="For short messages, the latency is $latency."
else
    latency=""
fi
if test -s examples/perftest/long.gpl ; then
    rate="`grep 'startup' examples/perftest/long.gpl | cut -d' ' -f 10,11`"
    rate="For long messages, the transfer rate is $rate."
else
    rate=""
fi

cat >> $filename <<.
\section{Performance}
The performance of a message passing system is often measured in terms of the
bandwidth and latency for a point-to-point message.  This section reports the
performance of the MPICH version of MPI for a simple ping-pong test between
two nodes.  The time reported is one-half the round-trip time.  
Figure \ref{fig-short} shows the performance for short messages.  The dashed
line represents a least-squares (or linear regression) fit to the data with
model \(s + r x\), where \(x\) is the length of the message in bytes, \(s\)
is the latency, and \(r\) is the time to transfer a byte (the inverse of the
transfer rate).  The coefficients for this model are shown in the upper
right-hand corner.  $latency
.

if test -f "$gnuplotloc" ; then
    cat >> $filename <<.

\begin{figure}
\centerline{\epsfbox{short.eps}}
\caption{Time for short messages}\label{fig-short}
\end{figure}

In Figure \ref{fig-long} we show the time taken by messages of intermediate
length.  These results give a better idea of the effective bandwidth for many
applications.  $rate
Care should, however, be taken when using these results, since
some systems do not reach there full (asymptotic) bandwidth until very large
messages are used. 
In addition, these results measure only the performance of the MPICH
implementation of MPI, not the achievable performance of the MPI standard.


\begin{figure}
\centerline{\epsfbox{long.eps}}
\caption{Time for long messages}\label{fig-long}
\end{figure}
.
fi
fi
#
#
# We should also run and digest the correctness tests....
#
# 
############################################################################
# Finish the document off
############################################################################
cat >> $filename <<.
\end{document}
.
