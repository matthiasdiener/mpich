#! /bin/sh
# This script is generated by configure for the purpose of reporting on
# the port of MPICH to a new architecture. This does ONLY the performance
# test runs.
#
# To simplify testing and a few special cases, this script takes a few options
# -author="name"        Use instead of 'whoami'
# -nomake               Do not run make
# -noperf               Do not run performance tests
# -file=name            Output LaTeX file (default is doc/doc1.tex)
# -plotonly             Run gnuplot only to create output files
author="`whoami`"
nomake=0
noperf=0
plotonly=0
filename="doc/doc1perf.tex"
fileroot="doc1"
for arg in "$@" ; do
    case $arg in 
	-author=* )
	author="`echo $arg|sed 's/-author=//'`"
	;;
	-file=* )
	filebase=`echo $arg|sed 's/-file=//'`
        filename="${filebase}perf.tex"
	fileroot="`basename $filebase`"
	;;
 	-nomake )
	nomake=1
	;;
 	-noperf )
	noperf=1
	;;
	-plotonly )
	plotonly=1
	;;
	*)
	if test -n "$arg" ; then
	    echo "portperf: Unknown argument ($arg)"
	    exit 1
	fi
	;;
    esac
done
#
# RefineGnuplotfile outputname (e.g., RefineGnuplotfile long)
RefineGnuplotfile() {
    if test ! -s mppout.gpl ; then 
        echo "Failed to run performance test!"
    else
	echo "set terminal postscript eps" | cat - $1.gpl > .foo
	echo "exit" | cat .foo - | sed /pause/d | \
		sed -e "s/mppout/$1-data/g" > $1.gpl
	mv mppout.gpl $1-data.gpl 
    fi
    }

Bverbatim() {
cat >>$1 <<.
\begin{verbatim}
.
}
Everbatim() {
cat >>$1 <<.
\end{verbatim}
.
}

# Remove the old filename
/bin/rm -f $filename
if test -z "@MPE_DIR@" ; then 
    cat >> $filename <<.
\section{Performance}
The performance test programs require the MPE library.  Reconfigure MPICH
with {\tt -mpe} and rebuild MPICH (you should be able to just run make in the
{\tt mpe} directory, then re-run {\tt port}, adding the {\tt -nomake} 
option).
.
    exit 0
fi
#
############################################################################
# Some initial comments...
# sh is not reliable about processing redirects of stdin within if...else..fi
# For such cases, we place the output text within a routine, defined
# outside of the if..else..fi, and called conditionally.
############################################################################
############################################################################
# Performance of the system
############################################################################
#
############################################################################
# Run the performance tests
############################################################################
#
# i860's don't have which...
if test $noperf = 0 ; then
    gnuplotloc=`which gnuplot`

    # We can generate the output graphs...
   if test "$plotonly" = 0 ; then
	curdir=`pwd`
	cd examples/perftest
	/bin/rm -f maketst.log 
 	make mpptest goptest > maketst.log 2>&1
	
 	if test ! -x mpptest ; then 
	    echo "Failed to build performance test program!" >> $filename
	    echo "Output of \\code{make mpptest goptest} is" >> $filename
	    Bverbatim $filename
	    cat maketst.log >> $filename
	    Everbatim $filename
	    exit 1
	fi
	/bin/rm -rf short.gpl short.err 
	mpirun -np 2 -mvhome -mvback mppout.gpl -arch=@ARCH@ mpptest -gnuplot \
		-tgoal 0.1 -auto -givdy > short.gpl 2>short.err
	RefineGnuplotfile "short"
	#
	/bin/rm -rf long.gpl long.err 
	mpirun -np 2 -mvhome -mvback mppout.gpl -arch=@ARCH@ mpptest -gnuplot \
	   -tgoal 0.2 -auto -reps 25 -size 16384 65536 1024 -givedy \
		> long.gpl 2>long.err
	RefineGnuplotfile "long"
	#
	# The collective routines need to aggregate over several values of
	# -np ... 
#	/bin/rm -f sync.gpl sync.out
#	for np in 2 4 8 16 ; do
#	    mpirun -np $np -mvhome -mvback mppout.gpl -arch=@ARCH@ goptest \
#			-gnuplot -sync > sync.gpl
#	    cat mppout.gpl >> sync.out
#	done
#        mv sync.out mppout.gpl
#	RefineGnuplotfile "sync"
#	#
#	mpirun -np 4 -mvhome -mvback mppout.gpl -arch=@ARCH@ goptest -gnuplot \
#		-dsum > dsum4.gpl
#	RefineGnuplotfile "dsum4"
#	mpirun -np 8 -mvhome -mvback mppout.gpl -arch=@ARCH@ goptest -gnuplot \
#		-dsum > dsum8.gpl
#	RefineGnuplotfile "dsum8"
#	#
#	mpirun -np 4 -mvhome -mvback mppout.gpl -arch=@ARCH@ mpptest -gnuplot \
#		-bisect -givedy > bisect.gpl
#	RefineGnuplotfile "bisect"
	cd $curdir
    fi
    # 
    # Test that we generated the data.  If not, try to determine why
    #
    if test ! -s examples/perftest/short-data.gpl -o \
            ! -s examples/perftest/long-data.gpl ; then
	echo "Could not generate the performance test data!" >> $filename
	if test -s examples/perftest/short.gpl ; then 
	    echo "The output from the short message test was" >> $filename
	    Bverbatim $filename
	    cat examples/perftest/short.gpl >> $filename
	    Everbatim $filename
	else
	    echo "There was no output from the short message test!" >> \
		$filename
	fi
	if test -s examples/perftest/long.gpl ; then 
	    echo "The output from the long message test was" >> $filename
	    Bverbatim $filename
	    cat examples/perftest/long.gpl >> $filename
	    Everbatim $filename
	else
	    echo "There was no output from the long message test!" >> \
		$filename
	fi
        echo \
	"The output of the make to build the performance test program was" \
			>> $filename
    	Bverbatim $filename
   	cat examples/perftest/maketst.log >> $filename
    	Everbatim $filename
    	if test -s examples/perftest/short.err ; then
	    echo "The error output of short message test was" >> $filename
            Bverbatim $filename
	    cat examples/perftest/short.err >>$filename
  	    Everbatim $filename
    	fi
    	if test -s examples/perftest/long.err ; then
	    echo "The error output of long message test was" >> $filename
            Bverbatim $filename
	    cat examples/perftest/long.err >>$filename
  	    Everbatim $filename
    	fi
        exit 0
    elif test -f "$gnuplotloc" ; then
        (cd examples/perftest ; \
	/bin/rm -f short.eps long.eps ; \
        gnuplot short.gpl > short.eps ; \
        gnuplot long.gpl > long.eps ; \
        /bin/rm -f ../../doc/short.eps ../../doc/long.eps ; \
        mv short.eps ../../doc ; mv long.eps ../../doc ; )
    fi
fi
if test "$plotonly" = 1 ; then
    exit 0
fi
#
# Extract the performance numbers
if test -s examples/perftest/short.gpl ; then
    latency="`grep 'startup' examples/perftest/short.gpl | cut -d' ' -f 4,5`"
    latency="For short messages, the latency is $latency."
else
    latency=""
fi
if test -s examples/perftest/long.gpl ; then
    rate="`grep 'startup' examples/perftest/long.gpl | cut -d' ' -f 10,11`"
    rate="For long messages, the transfer rate is $rate."
else
    rate=""
fi

cat >> $filename <<.
\section{Performance}
The performance of a message passing system is often measured in terms of the
bandwidth and latency for a point-to-point message.  This section reports the
performance of the MPICH version of MPI for a simple ping-pong test between
two nodes.  The time reported is one-half the round-trip time.  
Figure \ref{fig-short} shows the performance for short messages.  The dashed
line represents a least-squares (or linear regression) fit to the data with
model \(s + r x\), where \(x\) is the length of the message in bytes, \(s\)
is the latency, and \(r\) is the time to transfer a byte (the inverse of the
transfer rate).  The coefficients for this model are shown in the upper
right-hand corner.  $latency
.

if test -f "$gnuplotloc" ; then
    cat >> $filename <<.

\begin{figure}
\centerline{\epsfbox{short.eps}}
\caption{Time for short messages}\label{fig-short}
\end{figure}

In Figure \ref{fig-long} we show the time taken by messages of intermediate
length.  These results give a better idea of the effective bandwidth for many
applications.  $rate
Care should, however, be taken when using these results, since
some systems do not reach there full (asymptotic) bandwidth until very large
messages are used. 
In addition, these results measure only the performance of the MPICH
implementation of MPI, not the achievable performance of the MPI standard.


\begin{figure}
\centerline{\epsfbox{long.eps}}
\caption{Time for long messages}\label{fig-long}
\end{figure}
.
fi
