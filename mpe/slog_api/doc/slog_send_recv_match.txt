
For example, we want to match MPI_Send and MPI_Recv, and we want to draw
an arrow from the beginning of MPI_Send to the end of MPI_Recv.
Since there are bebits in UTE file format, so we basically need to match
MPI_Send's (1,0) or (1,1) interval with MPI_Recv's (0,1) or (1,1) interval.

So basically we need to maintain a stack for the type of arrow between
MPI_Send() and MPI_recv(), I will call this: stack(MPI_Send, MPI_recv).  
Since the UTE bebit intervals can be considered as a stream from 
SLOG's prespective.  And remember all interval records have to be 
passed to SLOG_API in increasing endtime order.

Scan the stream of UTE bebit intervals data
   if ( MPI_Send's (1,0) interval or (1,1) interval )
      put the starttime of the arrow, the arrow-end's (node, cpu, thread)
      on the stack(MPI_Send, MPI_Recv).  Here you could set the starttime 
      of the arrow as endtime of MPI_Send's (1,0) interval or the starttime of
      MPI_Send's (1,1) interval.  And also put the (node, cpu, thread) of
      the MPI_Send onto the stack(MPI_Send, MPI_Recv).  Then pass the 
      MPI_Send to the SLOG_API, then process next interval from the stream.

   else if ( MPI_Recv's (0,1) interval or (1,1) interval )
      check if there is any unmatched MPI_Send() on the 
      stack(MPI_Send, MPI_Recv).  If so, check which MPI_Send on the
      stack matches the MPI_Recv().  Here you probably try to match
      commID and seqID, or some sort of global message ID.  When there is
      a match, pop the MPI_Send out of the stack and assemble an slog arrow
      interval record.  Now you need to set the endtime of the arrow
      as either the starttime of the MPI_Recv's (0,1) interval
      or the endtime of the MPI_Recv's (1,1) interval.  Then
      pass the arrow and MPI_Recv interval record to the SLOG.
      The order of which to pass first depends on which has earlier
      endtime.

   else
      process next interval from the stream

----------
For Isend, Irecv, Waitsome, Waitall, Testsome, Testall, you need to
decide where the arrows should be draw from and end at.  Rusty and Bill
should give you more info on this kind of matching.
-----------

Also you need to define "Forward Arrow" and "Backward Arrow" in
display profile and record definition table through SLOG_PROF_XXXX()
and SLOG_RDEF_XXXX().  "Backward Arrow" is an arrow which points backward
in time, it is an artifact when the clock is NOT synchronized.  Check   
slog-jumpshot3/slog_api/src/ts_incrEQendtime_resfnEQyes.c for example.

    /*  Create the Indexes for Message Record's display profile  */
    ierr = SLOG_PROF_AddIntvlInfo( slog, SLOG_IntvlType4OffDiagRec,
                                   SLOG_Bebit4OffDiagRec, SLOG_Bebit4OffDiagRec,
                                   "Message", "Forward Arrow", "white", 0 );

    /*  Create the Indexes for Message Record's Definition  */
    ierr = SLOG_RDEF_AddRecDef( slog, SLOG_IntvlType4OffDiagRec,
                                SLOG_Bebit4OffDiagRec, SLOG_Bebit4OffDiagRec,
                                0, 0 );

    SLOG_IntvlType4OffDiagRec is the interval type for an arrow and is
    NOT a predefined number in slog_api.  So you can define any number you
    like.  But the words "forward" and "backward" are keywords in the
    labels, otherwise jumpshot-3 would confuse which interval type to
    be used as arrows.  You don't have to define "Backward Arrow" if
    you know for sure there is NOT backward arrow in slogfile.

A.Chan

