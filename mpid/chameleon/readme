This directory contains the Chameleon implementation of the MPI device layer.
This is a simple implementation, providing only the most rudimentary functions.
This is an example of how simple an MPI implemenation can be, with MPI code
from the reference implementation handling the details of communicators, 
derived data types, and other things.  

We only assume that we can send and receive packets of data between
processors.  We DO assume that a non-trivial amount of buffering is
provided by the message-passing system.  If this is not true, then
different strategies should be investigated (in the CMMD case, you can
use active messages, interrupt-driven receives, or the "nonblock" versions. 

The following provides general documentation for the ADI routines, in a 
format that can be converted into man, LaTeX, and WWW pages.

/*D
      Chameleon-MPI transport (device) implementation

      This simple Chameleon implementation is meant to work with
      most message passing systems and does not rely on large amounts
      of message buffering.  Messages are sent in one or two packets, depending
      on the length.  If the message is short (< MPID_PKT_DATA_SIZE), then
      the header and message are placed into a single message and sent
      together.  Long messages are sent without copying the message by
      sending the header in a separate packet. 

      This Chameleon implementation depends on adequate buffering by the
      message-passing system.  Because there is no asynchronous notification
      of messages in Chameleon (because most transport layers do not provide
      this important functionality), it is difficult to implement a
      packet-based system (i.e., one that divides messages into multiple 
      packets and manages all buffering).

      Comments on the implementation:

      There are many things that can be done to improve the performance of
      the implementation of the ADI on various platforms.  Some of these 
      have been added to the current implementation with ifdef's (see the
      MPICH configure for more discussion of what is currently available).
      
D*/

/*D
    MPID_Check_device - Checks for pending operations, handles if found

    Input Parameter:
.   blocking - Indicates whether the operation is blocking or not.  The
               values MPID_BLOCKING and MPID_NOT_BLOCKING can be used.
.   ctx      - ADI context returned by MPID_Init

    Synopsis:
    void MPID_Check_device( void * ctx, int blocking )

    Notes:
    This routine should be called by the API frequently IF the ADI requires
    it.  For example, if the ADI is not a separate thread and does not use
    signals to operate asynchronously.  

    Some ADI routines may also use this to process pending ADI events.
D*/

/*D
    MPID_Cancel - Cancels a pending communication operation

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   r - pointer to an API message request 

    Synopsis:
    void MPID_Cancel( void * ctx, MPIR_CHANDLE *r )

    Notes:
    The actual freeing of internal space must be done with the appropriate
    MPID_FREE_SEND/RECV_HANDLE calls.  

    This routine may have little effect.  If the message has already been
    delivered, it has no effect.  
D*/

/*D
    MPID_Myrank - Provides the rank of the calling process

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
	
    Output Parameter:
.   rank - rank, in the range 0 to Mysize-1 (see MPID_Mysize) of the calling
    process among all of the processes.

    Synopsis:
    void MPID_Myrank( void * ctx, int *rank )
D*/

/*D
    MPID_Mysize - Provides the number of processes

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init

    Output Parameter:
.   size - number of processes in the set of processes. 

    Synopsis:
    void MPID_Mysize( void * ctx, int *size )
D*/

/*D
    MPID_Init - Initializes the ADI

    Input Parameters:
.   argc - Pointer to an integer containing the number of arguments
.   argv - Pointer to the argument vector

    Returns:
    Pointer that may be passed back to these routines (context).

    Synopsis:
    void *MPID_Init( int *argc, char ***argv )

    Notes:
    If called from a C program with main(argc,argv), the correct calling
    sequence is MPID_Init(&argc,&argv).

    This routine may (or may not) also initialize the parallel processes 
    themselves.  That is, when this routine is called, it may create the
    requested number of parallel processes, or it may simply make use of
    an already existing set.  What the case is, and how the number of 
    processes is specified, is specific to any particular implementation 
    and environment.

    As an example, the Chameleon version of the ADI has these properties
.vb
   Transport Layer             -   MPID_Init starts processes
   ---------------------------------------------------------------
   p4, pvm, EUIH               -   yes
   Paragon                     -   depends on Paragon 
   Intel i860, Delta, CM5, POE -   no
.ve

    The pointer returned by this routine may be null; it is provided to allow
    for multiple, simultaneous ADI's.  For example, if the pointer returned
    contains a structure with pointers to the ADI routines, and the macros
    for the operations choose the actual function from this structure, then
    a single user-application can easily switch between ADIs, depending,
    for example, on the MPI Communicator in use.   
D*/

/*D
    MPID_HAS_HETERO - Indicates that heterogeneous processors may be present

    Notes:
    This is a macro that is defined when the ADI supports heterogeneous
    processing elements.  APIs that are to operate in a heterogeneous
    environment need to ensure that message are properly prepared.
    See also ????? (heterogeneous support), MPID_IS_HETERO
D*/

/*D
    MPID_IS_HETERO - Indicates that heterogeneous processors are present

    Notes:
    This is a global variable that can be used to determine if an ADI
    that could contain heterogeneous processors actually does.  For example,
    if the ADI can connect disimilar workstations but the active collection
    contains only similar workstations, then MPID_HAS_HETERO would be 
    defined, but MPID_IS_HETERO would be false.

    See also ??? (heterogeneous support)
D*/

/*D
    MPID_Procinfo - Data structure that contains information on the 
    processes

    Notes:
    This structure is undergoing development.   See MPID_Dest_byte_order.
D*/

/*D
   MPID_Dest_byte_order - Gives the byte ordering of the destination process

   Input Parameter:
.  dest - Rank in MPI_COMM_WORLD of the destination process

   Return Value:
   One of 
. MPID_H_NONE - Unknown
. MPID_H_LSB  - Least significant byte first
. MPID_H_MSB  - Most significant byte first
. MPID_H_XDR  - Unknown; use XDR to exchange data
D*/

/*D 
    MPID_Abort - Terminates a parallel program

    Input Parameter:
.   code - Value to return to invocation environment as exit status
.   ctx      - ADI context returned by MPID_Init

    Synopsis:
    void MPID_Abort( void * ctx, int code )

    Notes:
    This call terminates all processes in a parallel program.

    It is not always possible to return code as the status.
D*/

/*D
    MPID_End - Ends the operation of the ADI

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init

    Synopsis:
    void MPID_End( void * ctx )

    Notes:
    This routine must be called at the end of the parallel part of a program.
    Normally, this is just before the program exits.  Once MPID_End is called,
    no other MPID routines, including MPID_Init, may be called.
D*/

/*D
    MPID_Node_name - Provides the name of the processor

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   len  - Length of "name" argument

    Output Parameter:
.   name - Name of the processor on which this call took place.  It should
           identify the specific hardware when possible
 
    Synopsis:
    void MPID_Node_name( void * ctx, char *name, int len )
D*/

/*D
    MPID_Wtime - Returns the time, relative to some arbitrary point

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init

    Synopsis:
    double MPID_Wtime( void * ctx )

    Notes:
    This routine may return a different value on eacy processor even 
    when called at the same "time".  The only quantity that is meaningful
    is the difference between two results of MPID_Wtime.  The resolution 
    of this time is provide by MPID_Wtick; while MPID_Wtime should provide
    a high-resolution time, this is not required or guarenteed. 

    The time measured is elapsed or wall-clock time, not CPU time.
D*/

/*D
    MPID_Wtick - Returns the resolution of the timer MPID_Wtime

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init

    Synopsis:
    double MPID_Wtick( void * ctx )

D*/

/*D
    MPID_Iprobe - Returns whether a message of the specified type is 
                  available

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   tag - Message tag
.   source - Message source (sending processor).  Measured in terms of
             rank of the communicator
.   context_id - Context id value of communicator.

    Output Parameters:
.   found - Set to true if a message is available, false otherwise
.   status - MPI status object; has values set if found is true

    Synopsis:
    int MPID_Iprobe( void * ctx, int tag, int source, int context_id, 
                     int *found, MPI_Status *status )
D*/

/*D
    MPID_Probe - Returns status for a matching message; waits if message is
                 not available.

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   tag - Message tag
.   source - Message source (sending processor).  Measured in terms of
             rank of the communicator
.   context_id - Context id value of communicator.

    Output Parameters:
.   status - MPI status object; has values set if found is true

    Synopsis:
    int MPID_Probe( void * ctx, int tag, int source, int context_id, 
                     MPI_Status *status )
D*/

/*D
    MPID_Init_communicator - Initializes a new communictors

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   comm     - MPI Communicator

    Synopsis:
    int MPID_Init_communicator( void * ctx, MPI_Comm comm )

    Notes:
    Not yet used.

    This interface is intended to let the ADI optimize for various collective
    operations by detecting whether special features are available.
    Note that MPI_Pack is a collective operation in the sense that the
    result must be valid for all members of a communicator; by letting the
    ADI initialize a communicator, it can pre-determine if, for example,
    all members use the same data-representation. 

    For future extensions for collective operations and shared-memory
    systems, this entry could allocate data-structures for performing
    various operations.
D*/

/*D
    MPID_Flags - Describes the run-time data collection and debugging flags

    Notes:
    The MPID/ADI implementation collects a number of statistics and provides a
    variety of debugging options.

    This interface is currently under development
D*/

/*D
    MPID_Message_protocol - Describes the message prototcol used by the 
	Chameleon ADI

    Notes:
    All messages are sent with a short header message.  In addition,
    long messages may be sent separately, in-order to make best use of
    vendor-provided message-passing interfaces.

    In the receive code, there are routines to extract the data from short
    and long messages (MPID_extract_short, MPID_extract_long).  In addition,
    nonblocking versions of the long message version (MPID_nextract_long,
    MPID_wextract_long) are also available.

    In the send code, the routines are MPID_post_send_short and
    MPID_post_send_long.  MPID_post_send_long may use nonblocking operations.
D*/

/*D
    MPID_Check_incoming

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   blocking - Indicates whether the operation is blocking or not.  The
               values MPID_BLOCKING and MPID_NOT_BLOCKING can be used.

    Returns:
    -1 if nonblocking and no messages pending

    Synopsis:
    int MPID_Check_incoming( void * ctx, MPID_BLOCKING_TYPE blocking )

    Notes:
    This routine handles testing for a single incoming message.
D*/

/*D
    MPID_Blocking_recv - Performs a blocking receive

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_recv_handle - API's receive handle
   
   Synopsis:
   int MPID_Blocking_recv( void * ctx, MPIR_RHANDLE *dmpi_recv_handle ) 

D*/

/*D
    MPID_Blocking_send - Performs a blocking send

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_send_handle - API's send handle
   
   Synopsis:
   int MPID_Blocking_send( void * ctx, MPIR_SHANDLE *dmpi_send_handle ) 

D*/

/*D
    MPID_Blocking_send_ready - Performs a ready blocking send

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_send_handle - API's send handle
   
   Synopsis:
   int MPID_Blocking_send_ready( void * ctx, MPIR_SHANDLE *dmpi_send_handle ) 

   Notes:
   This may be implemented as MPID_Blocking_send

D*/

/*D
    MPID_Alloc_send_handle - Allocates and initializes device send handle

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   a - Address of device send handle in API's send structure

    Synopsis:
    void MPID_Alloc_send_handle( void * ctx, MPID_SHANDLE *mpid_send_handle )

    Notes:
    In systems where the device handle is statically allocated, this 
    routine may be used to initialize the fields of that handle.  In
    particular, it may set fields such as "completed" to false.
D*/

/*D
    MPID_Alloc_recv_handle - Allocates and initializes device recv handle

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   a - Address of device recv handle in API's send structure

    Synopsis:
    void MPID_Alloc_recv_handle( void * ctx, MPID_SHANDLE *mpid_recv_handle )

    Notes:
    In systems where the device handle is statically allocated, this 
    routine may be used to initialize the fields of that handle.  In
    particular, it may set fields such as "completed" to false.
D*/

/*D
    MPID_Free_send_handle - Frees device send handle

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   a - Address of device send handle in API's send structure

    Synopsis:
    void MPID_Free_send_handle( void * ctx, MPID_SHANDLE *mpid_send_handle )

    Notes:
    In systems where the device handle is statically allocated, this 
    routine may be used to free any areas that may have been created
    by the send operation.
D*/

/*D
    MPID_Free_recv_handle - Frees device recv handle

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   a - Address of device recv handle in API's recv structure

    Synopsis:
    void MPID_Free_recv_handle( void * ctx, MPID_RHANDLE *mpid_recv_handle )

    Notes:
    In systems where the device handle is statically allocated, this 
    routine may be used to free any areas that may have been created
    by the recv operation.
D*/

/*D
    MPID_Reuse_send_handle - Reinitializes device send handle

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   a - Address of device send handle in API's send structure

    Synopsis:
    void MPID_Reuse_send_handle( void * ctx, MPID_SHANDLE *mpid_send_handle )

    Notes:
    In systems where the device handle is statically allocated, this 
    routine may be used to reset fields such as "completed" to false.
    This routine is used for persistent message-passing requests
D*/

/*D
    MPID_Reuse_recv_handle - Reinitializes device recv handle

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.   a - Address of device recv handle in API's send structure

    Synopsis:
    void MPID_Reuse_recv_handle( void * ctx, MPID_RHANDLE *mpid_recv_handle )

    Notes:
    In systems where the device handle is statically allocated, this 
    routine may be used to reset fields such as "completed" to false.
    This routine is used for persistent message-passing requests
D*/

/*D
    MPID_Post_send - Starts a send of a message 

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_recv_handle - API's send handle
   
   Synopsis:
   int MPID_Post_send( void * ctx, MPIR_SHANDLE *dmpi_send_handle ) 

   Notes:
   This routine only begins the send.  MPID_Complete_send must be called
   to finish the send, even if it was a blocking operation
D*/

/*D
    MPID_Post_send_sync - Starts a send of a message with synchronous mode

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_recv_handle - API's send handle
   
   Synopsis:
   int MPID_Post_send_sync( void * ctx, MPIR_SHANDLE *dmpi_send_handle ) 

   Notes:
   This routine only begins the send.  MPID_Complete_send must be called
   to finish the send, even if it was a blocking operation.  This send
   will not complete until the destination BEGINS the matching receive.
D*/

/*D
    MPID_Post_send_ready - Starts a send of a message with ready mode

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_recv_handle - API's send handle
   
   Synopsis:
   int MPID_Post_send_ready( void * ctx, MPIR_SHANDLE *dmpi_send_handle ) 

   Notes:
   This routine only begins the send.  MPID_Complete_send must be called
   to finish the send, even if it was a blocking operation.  The matching
   receive should already be posted.

   It is legal to implement this with MPID_Post_send.
D*/

/*D
    MPID_Complete_send - Completes a send of a message

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_send_handle - API's send handle

   Synopsis:
   int MPID_Complete_send( void * ctx, MPIR_SHANDLE *dmpi_send_handle )

   Notes:
   This routine completes a send begun with MPID_Post_send.
D*/

/*D
   MPID_Test_send - Tests for the completion of a send request

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_send_handle - API's send handle

   Return value:
   True (!= 0) if the request has completed, False (0) otherwise.

   Notes:
   Unimplemented at present
D*/

/*D
   MPID_Test_recv - Tests for the completion of a recv request

   Input Parameter:
.   ctx      - ADI context returned by MPID_Init
.  dmpi_recv_handle - API's recv handle

   Return value:
   True (!= 0) if the request has completed, False (0) otherwise.

   Notes:
   Unimplemented at present
D*/

/*D
    MPID_RETURN_PACKED - Indicates that the ADI prefers to return a single 
                         buffer

    Notes:
    This is a macro that indicates that the data will be returned in the 
    data-area specified by the "start" field of the device handle.  If the
    message is not contiguous, the API is responsible for unpacking the 
    message (with the routines MPIR_SetupUnPackMessage and MPIR_UnPackMessage)
D*/

/*D
    MPID_PACK_IN_ADVANCE - Indicates that the ADI prefers to be given a single 
                         buffer

    Notes:
    This is a macro that indicates that the data will be provided in the 
    data-area specified by the "start" field of the device handle.  If the
    message is not contiguous, the API is responsible for packing the 
    message (it may use MPIR_PackMessage and MPIR_EndPackMessage).

    More advanced ADI implementations may inform the calling routines (the 
    API code) that the ADI can handle more complicated data, such as
    MPID_DOES_STRIDED.  The exact interface for this has not been
    determined.
D*/

/*D
    MPID_Version_name - Provides a text string describing the version of the
	ADI

    Input Parameter:
.   ctx      - ADI context returned by MPID_Init

    Output Parameter:
.   name - Name of the version of the ADI.  Must be a string of at least
    128 characters
 
    Synopsis:
    void MPID_Version_name( void * ctx, char *name )

D*/

/*D
    MPID_Dest_byte_order - Returns the byte ordering desired by the
    destination

    Input Parameter:
.   dest - Absolute rank or destination

    Returns:
    One of MPID_H_NONE, MPID_H_LSB, MPID_H_MSB, MPID_H_XDR

    Synopsis:
    int MPID_Dest_byte_order( int dest )

D*/

/*D
	Collective - Support in the ADI for collective operations

    Discussion:
    On some systems, there is special hardware for some collective operations.
    On others, there are special techniques that can be applied to 
    significantly speed up some collective operations.

    It is not necessary to support ANY collective operations within the ADI.
    However, the ADI does provide a way for the ADI to perform some 
    operations.  In addition, these operations may be provided for just
    MPI_COMM_WORLD or for any communicator.

    The ADI provides for the following classes of collective operations
.   MPID_Barrier - Barrier
.   MPID_Reduce_op_type - Reduction (op == sum, prod, etc, type = double, 
    int, etc).  Define MPID_Reduce if ANY are defined
.   MPID_Scan_op_type - Scan reduction.  Define MPID_Scan if ANY are 
    defined.
.   MPID_Bcast - Broadcast (1 to all)
.   MPID_AlltoAll - All to all

    These routines all handle a SINGLE ELEMENT, since this is an
    important and common case.  

    Since these may require the creation of special data structures, the
    ADI routine MPID_Comm_init must be called before these may be used.
    MPID_Comm_free must be called when a communicator is destroyed to
    ensure that any resources are returned.

    All of these "routines" are actually macros, allowing the API code
    to contain code like

.vb
   #ifdef MPID_Barrier
   if (comm->AdiBarrier) MPID_Barrier( comm->AdiCtx, comm );
   else 
   #endif
   {
   ... code using pt-2-pt
   }
.ve
   
    Not yet decided: are the reduction and scan reduced to a single root 
    or to all (I'd prefer to all).
D*/

/*D 
    MPID_Reduce_sum_int - Reduce a single int value by sum on all 
    processes

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   sendbuf  - Contribution from each process
.   comm     - MPI Communicator

    Output Parameter:
.   recvbuf  - Contains (on ALL processes) the output value

    Synopsis:
    void MPID_Reduce_sum_int( void *ctx, int *sendbuf, int *recvbuf, 
			      MPI_Comm comm )

D*/    

/*D 
    MPID_Reduce_sum_double - Reduce a single double value by sum on all 
    processes

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   sendbuf  - Contribution from each process
.   comm     - MPI Communicator

    Output Parameter:
.   recvbuf  - Contains (on ALL processes) the output value

    Synopsis:
    void MPID_Reduce_sum_double( void *ctx, double *sendbuf, double *recvbuf, 
			      MPI_Comm comm )

D*/    

/*D 
    MPID_Barrier - Performs a barrier synchronization

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   comm     - MPI Communicator

    Synopsis:
    void MPID_Barrier( void *ctx, MPI_Comm comm )
D*/    

/*D
    MPID_Comm_init - Initializes the ADI's use of a communicator

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   parent   - MPI Communicator of parent
.   comm     - MPI Communicator

    Synopsis:
    void MPID_Comm_init( void *ctx, MPI_Comm comm )

    Notes:
    This routine is responsible for initializing any data areas needed 
    to perform any ADI-supported collective operations (such as MPID_Barrier).
    In addition, this routine is collective in the parent communicator.
    If the parent is NULL, comm must be MPI_COMM_WORLD and all
    processes must call this routine.
D*/

/*D
    MPID_Comm_free - Frees the ADI's use of a communicator

    Input Parameters:
.   ctx      - ADI context returned by MPID_Init
.   comm     - MPI Communicator

    Synopsis:
    void MPID_Comm_free( void *ctx, MPI_Comm comm )

    Notes:
    This routine is responsible for freeing any data areas needed 
    to perform any ADI-supported collective operations (such as MPID_Barrier).
D*/
