%&latex

%
% "The PORTS0 Interface"
% The PORTS Consortium
%
% rcsid = "$Header: /nfs/globus1/src/master/ports0/docs/spec/ports0.tex,v 1.3 1995/01/27 19:57:22 tuecke Exp $"
%

\documentstyle[12pt,epsf]{article}
\textwidth 14.0cm
\textheight 21.5cm
\voffset -1in

\def\versionnumber{0.3}
\def\versiondate{January 27, 1995}

%\textwidth  16cm
%\textheight 23cm
%\voffset = -1.8in
%\hoffset = -0.5in

\def\SEC{{\bf \S}}
\def\APP{Appendix~}

\newcommand{\ports}{PORTS}
\newcommand{\portszero}{PORTS0}

\title{The PORTS0 Interface}

\author{The PORTS Consortium}

\date{Version \versionnumber\\
\versiondate}

\def\portsabstract{
The \ports\ (POrtable RunTime System) group was established to address
the problems of constructing a common runtime system to be used as a
compiler target for various task- and data-parallel languages.  One
result of this group's efforts is the definition of an applications
programming interface, the \ports\ level-zero interface (\portszero).
This interface comprises lightweight thread functions and a core set of
reentrant library routines.  This report describes the \portszero\
interface.}

\begin{document}

\pagenumbering{roman}
\setcounter{page}{1}

\maketitle
\portsabstract
\thispagestyle{empty}
\newpage

\tableofcontents
\newpage

\pagenumbering{arabic}
\setcounter{page}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

The \ports\ level-zero interface (called \portszero)
comprises a set of functions for lightweight thread management
and for reentrant memory management and file I/O.  The thread
management routines are modeled after a subset of the POSIX thread
interface, while the reentrant functions are modeled after standard C
library routines.  This set of functions is the first set of functions
to be agreed upon by the \ports\ (POrtable RunTime System) group as
necessary parts of a complete runtime system for parallel languages
and tools.

This document briefly describes the \portszero\ interface.  More
information on the \ports\ group can be found on the World Wide Web at
URL\linebreak {\tt http://www.cs.uoregon.edu/paracomp/ports}.  An
implementation of the \portszero\ interface, which was jointly
developed at Argonne National Laboratory and California Institute of
Technology, is available by anonymous ftp from {\tt
ftp://ftp.mcs.anl.gov/pub/ports}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Initialization and Shutdown}

\portszero\ provides an initialization and a shutdown routine.  These
functions should be called before and after any other \portszero\
routines are used, respectively.

Any program that uses \portszero\ functions must include the file
``{\tt ports0.h}''.  This file contains functions prototypes and
symbol definitions for the
\portszero\ interface.


\subsection{\tt ports0\_init()}
\begin{verbatim}
int ports0_init(int *argc,
                char **argv[],
                char *package_id)
\end{verbatim}

Initialize the \portszero\ library.  This function must be called
before any other \portszero\ functions are called.

The value zero is returned if initialization is successful, and
nonzero is returned if initialization fails.

The arguments in {\tt argc} and {\tt argv} are scanned by {\tt
ports\_init()}, and any arguments that are recognized by \portszero\ will
be removed by modifying {\tt argc} and {\tt argv}.

The {\tt package\_id} string is used as a prefix to all \portszero\
arguments.  For example, if {\tt package\_id} is ``foo'', then each
\ports\ arguments either will begin with ``-foo\_'' or will be
positioned between ``-foo'' and ``-foo\_end'' arguments.  Hence, an
argument to specify the default stack size can be specified either as
``-foo\_stack 1024'' or ``-foo -stack 1024 -foo\_end''.

While all \ports\ arguments will have a {\tt package\_id} prefix, this
does not imply that all arguments prefixed by {\tt package\_id} are
\portszero\ arguments.  Some of them may be for the system that is using
\portszero.  Therefore, not all arguments with a {\tt package\_id}
prefix will necessarily be removed from {\tt argc} and {\tt argv} when
{\tt ports0\_init()} returns.  Only those arguments that are actually
recognized by \portszero\ will be removed.  The {\tt package\_id} simply
allows \portszero\ and the system using it to have consistent argument
naming.


\subsection{\tt ports0\_shutdown()}
\begin{verbatim}
int ports0_start()
\end{verbatim}

Shut down the \portszero\ library.  This function must be called before
the program using \portszero\ terminates.  No other \portszero\
functions may be called after {\tt ports0\_shutdown()}.

Return zero if shutdown is successful, otherwise nonzero.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Thread Management}

\portszero\ threads are modeled after a subset of POSIX threads (IEEE
standard P1003.4a draft 8).  The semantics of the \portszero\ routines
are identical to the corresponding POSIX thread routines, unless
otherwise noted.  This section briefly describes each of the \portszero\
thread routines.  Please refer to the POSIX thread standard for more
details. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Thread Control}

\portszero\ provides the following functions for basic thread control:

\begin{itemize}
\item {\tt ports0\_threadattr\_init}: initialize a thread attribute
\item {\tt ports0\_threadattr\_destory}: destroy a thread attribute
\item {\tt ports0\_threadattr\_setstacksize}: set the stack size in a
thread attribute 
\item {\tt ports0\_threadattr\_getstacksize}: get the stack size from
a thread attribute
\item {\tt ports0\_thread\_create}: create a thread
\item {\tt ports0\_thread\_exit}: terminate the current thread 
\item {\tt ports0\_thread\_yield}: yield the processor to
another thread
\item {\tt ports0\_thread\_self}: return the thread ID of the calling
thread
\item {\tt ports0\_thread\_equal}: compare two thread IDs
\item {\tt ports0\_thread\_once}: for dynamic module initialization
\end{itemize}


\subsubsection{\tt ports0\_threadattr\_init()}
\begin{verbatim}
int ports0_threadattr_init(ports0_threadattr_t *attr)
\end{verbatim}

Initialize {\tt attr} to have the default thread attributes.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_threadattr\_destroy()}
\begin{verbatim}
int ports0_threadattr_destroy(ports0_threadattr_t *attr)
\end{verbatim}

Destroy the thread attributes object, {\tt attr}.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_threadattr\_setstacksize()}
\begin{verbatim}
int ports0_threadattr_setstacksize(ports0_threadattr_t *attr,
                                   size_t stacksize)
\end{verbatim}

Set the stack size value in the thread attributes object, {\tt attr}.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_threadattr\_getstacksize()}
\begin{verbatim}
int ports0_threadattr_getstacksize(ports0_threadattr_t *attr,
                                   size_t *stacksize)
\end{verbatim}

Get the stack size value from the thread attributes object, {\tt
attr}, and place it into the address pointed to by {\tt stacksize}.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_thread\_create()}
\begin{verbatim}
typedef void *(*ports0_thread_func_t)(void *user_arg);

int ports0_thread_create(ports0_thread_t *thread,
                         ports0_threadattr_t *attr,
                         void *(*func)(void *),
                         void *user_arg)
\end{verbatim}

Create a new thread that invokes the supplied function {\tt func} with
one argument {\tt user\_arg}.  The thread ID for the newly created
thread is placed in {\tt thread}.  The {\tt attr} argument specifies
the attributes for the thread.  Default attributes will be used if
{\tt attr} is {\tt NULL}.

Return zero if successful, otherwise nonzero.

Note: There is no equivalent to {\tt pthread\_join()} in \portszero.  All
\portszero\ threads are automatically detached when they are created.
This is a departure from POSIX thread semantics.


\subsubsection{\tt ports0\_thread\_exit()}
\begin{verbatim}
void ports0_thread_exit(void *status)
\end{verbatim}

Terminate the calling thread.  Returning from the user thread function
will implicitly terminate the thread.

Note: The {\tt status} argument is not used, since \portszero\ does not
support an equivalent to {\tt pthread\_join()}.


\subsubsection{\tt ports0\_thread\_yield()}
\begin{verbatim}
void ports0_thread_yield()
\end{verbatim}

Yield the processor to another thread.


\subsubsection{\tt ports0\_thread\_self()}
\begin{verbatim}
ports0_thread_t ports0_thread_self()
\end{verbatim}

Return the thread ID of the calling thread.


\subsubsection{\tt ports0\_thread\_equal()}
\begin{verbatim}
int ports0_thread_equal(ports0_thread_t t1,
                        ports0_thread_t t2)
\end{verbatim}

Compare the two thread IDs {\tt t1} and {\tt t2}. 

Return nonzero if the threads are the same, otherwise zero.


\subsubsection{\tt ports0\_thread\_once()}
\begin{verbatim}
ports0_thread_once_t once_control = PORTS0_THREAD_ONCE_INIT;

int ports0_thread_once(ports0_thread_once_t *once_control,
                       void (*init_routine)() )
\end{verbatim}

The first call to {\tt ports0\_thread\_once()} by any thread in a
process, with a given {\tt once\_control}, will result in a call to
the supplied {\tt init\_routine()} with no arguments.  Subsequent
calls to {\tt ports0\_thread\_once()} will not call the {\tt
init\_routine()}.  On return of {\tt ports0\_thread\_once()} it is
guaranteed that {\tt init\_routine()} has completed.  The {\tt
once\_control} parameter is used to determine whether the associated
initialization routine has been called.

Return zero upon successful completion, otherwise nonzero.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Thread-specific Data}

\portszero\ provides the following functions for thread-specific data:

\begin{itemize}
\item {\tt ports0\_thread\_key\_create}: create a thread-specific data
key
\item {\tt ports0\_thread\_key\_delete}: delete a thread-specific data
key
\item {\tt ports0\_thread\_setspecific}: associate a value with a
thread-specific data key
\item {\tt ports0\_thread\_getspecific}: retrieve the value associated
with a thread-specific data key
\end{itemize}

\subsubsection{\tt ports0\_thread\_key\_create()}
\begin{verbatim}
typedef void (*ports0_thread_key_destructor_func_t)(void *value);

int ports0_thread_key_create(
                ports0_thread_key_t *key,
                void (*destructor_func)(void*))
\end{verbatim}

Create a thread-specific data key that is visible to all threads in
the process, and place that key in the {\tt key} argument. 

Although the same key may be used by different threads, the values
bound to the key by {\tt ports0\_thread\_setspecific()} are maintained
on a per-thread basis.  The value associated with a new key is {\tt
NULL} in all active threads and will be initialized to {\tt NULL} in
all threads that are subsequently created.  If {\tt destructor\_func}
is not {\tt NULL}, then upon termination of the thread if the value
for this key is not {\tt NULL}, the function pointed to by {\tt
destructor\_func} is called with the current value for the key as its
argument.

Return zero upon successful completion, otherwise nonzero.  A return
of EAGAIN indicates that the key name space is exhausted.

\subsubsection{\tt ports0\_thread\_key\_delete()}
\begin{verbatim}
int ports0_thread_key_delete(ports0_thread_key_t key)
\end{verbatim}

Delete the thread-specific data {\tt key}. 

The destructor fuction associated with this key is {\em not} called.
Subsequent use of this key will result in undefined behavior.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_thread\_setspecific()}
\begin{verbatim}
int ports0_thread_setspecific(ports0_thread_key_t key,
                              void *value)
\end{verbatim}

Set the value associated with the thread-specific data {\tt key} to
{\tt value}. 

Different threads may bind different values to the same key.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_thread\_getspecific()}
\begin{verbatim}
int ports0_thread_getspecific(ports0_thread_key_t key,
                              void **value)
\end{verbatim}

Get the thread-specific data value associated with {\tt key}, and
return it in the {\tt value} argument.

Return zero upon successful completion, otherwise nonzero.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mutual Exclusion and Synchronization}

Mutual exclusion and synchronization between threads are provided by
the following operations:
\begin{itemize}
\item {\tt ports0\_mutexattr\_init}: initialize a mutex attribute
\item {\tt ports0\_mutexattr\_destroy}: destroy a mutex attribute
\item {\tt ports0\_mutex\_init}: initialize a mutual exclusion lock
\item {\tt ports0\_mutex\_destroy}: destroy a lock
\item {\tt ports0\_mutex\_lock}: obtain a mutually exclusive access to lock
\item {\tt ports0\_mutex\_trylock}: attempt to obtain a mutually
exclusive access to lock
\item {\tt ports0\_mutex\_unlock}: release a lock
\item {\tt ports0\_condattr\_init}: initialize a condition attribute
\item {\tt ports0\_condattr\_destroy}: destroy a condition attribute
\item {\tt ports0\_cond\_init}: initialize a condition variable
\item {\tt ports0\_cond\_destroy}: destroy a condition variable
\item {\tt ports0\_cond\_wait}: wait for a condition
\item {\tt ports0\_cond\_signal}: signal a condition
\item {\tt ports0\_cond\_broadcast}: signal to all waiting for a condition
\end{itemize}


\subsubsection{\tt ports0\_mutexattr\_init()}
\begin{verbatim}
int ports0_mutexattr_init(ports0_mutexattr_t *attr)
\end{verbatim}

Initialize {\tt attr} to have the default mutex attributes.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_mutexattr\_destroy()}
\begin{verbatim}
int ports0_mutexattr_destroy(ports0_mutexattr_t *attr)
\end{verbatim}

Destroy the mutex attributes object, {\tt attr}.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_mutex\_init()}
\begin{verbatim}
int ports0_mutex_init(ports0_mutex_t *mutex,
                      ports0_mutexattr_t *attr)
\end{verbatim}

Initialize the mutual exclusion lock, {\tt mutex}. 

The attributes for the mutex are specified by {\tt attr}.  Default
attributes will be used if {\tt attr} is {\tt NULL}.  The result of
calling {\tt ports0\_mutex\_lock()} or {\tt ports0\_mutex\_unlock()}
on a mutex that has not been initialized is undefined.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_mutex\_destroy()}
\begin{verbatim}
int ports0_mutex_destroy(ports0_mutex_t *mutex)
\end{verbatim}

Destroy the {\tt mutex} that was initialized with {\tt
ports0\_mutex\_init()}.

The result of calling {\tt ports0\_mutex\_lock()} or {\tt
ports0\_mutex\_unlock()} on a mutex that has been destroyed is
undefined.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_mutex\_lock()}
\begin{verbatim}
int ports0_mutex_lock(ports0_mutex_t *mutex)
\end{verbatim}

Block until the mutual exclusion lock, {\tt mutex}, is acquired.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_mutex\_trylock()}
\begin{verbatim}
int ports0_mutex_trylock(ports0_mutex_t *mutex)
\end{verbatim}

Attempt to acquire the mutual exclusion lock, {\tt mutex}. 

Returen 0 if successful.  If {\tt mutex} has already been acquired,
then do not acquire the lock, and return EBUSY.


\subsubsection{\tt ports0\_mutex\_unlock()}
\begin{verbatim}
int ports0_mutex_unlock(ports0_mutex_t *mutex)
\end{verbatim}

Unlock the mutual exclusion lock, {\tt mutex}, enabling another thread
to acquire the mutex. 

Fairness in locking is not guaranteed; that is, a thread is not
guaranteed to acquire a lock if other threads are also attempting to
acquire the same lock.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_condattr\_init()}
\begin{verbatim}
int ports0_condattr_init(ports0_condattr_t *attr)
\end{verbatim}

Initialize {\tt attr} to have the default condition attributes.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_condattr\_destroy()}
\begin{verbatim}
int ports0_condattr_destroy(ports0_condattr_t *attr)
\end{verbatim}

Destroy the condition attributes object, {\tt attr}.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_cond\_init()}
\begin{verbatim}
int ports0_cond_init(ports0_cond_t *cond,
                     ports0_condattr_t *attr)
\end{verbatim}

Initialize the condition variable, {\tt cond}. 

The attributes for the condition are specified by {\tt attr}.  Default
attributes will be used if {\tt attr} is {\tt NULL}.  The result of
calling any other {\tt ports0\_cond\_*()} function on a condition that
has not been initialized is undefined.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_cond\_destroy()}
\begin{verbatim}
int ports0_cond_destroy(ports0_cond_t *cond)
\end{verbatim}

Destroy the specified condition. 

The result of calling any other\linebreak {\tt ports0\_cond\_*()}
function on a condition that has been destroyed is undefined.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_cond\_wait()}
\begin{verbatim}
int ports0_cond_wait(ports0_cond_t *cond,
                     ports0_mutex_t *mutex)
\end{verbatim}

Atomically release {\tt mutex} and wait on {\tt cond}.  When the
function returns, {\tt mutex} has been reacquired.

If the thread executing the function has not acquired {\tt mutex},
the result is undefined.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_cond\_signal()}
\begin{verbatim}
int ports0_cond_signal(ports0_cond_t *cond)
\end{verbatim}

Signal the specified condition, waking up one thread that is suspended
on this condition. 

If no threads are suspended on this condition, this call will have no
effect.

Return zero upon successful completion, otherwise nonzero.


\subsubsection{\tt ports0\_cond\_broadcast()}
\begin{verbatim}
void ports0_cond_broadcast(ports0_cond_t *cond)
\end{verbatim}

Unsuspend all threads suspended on the specified condition.

Return zero upon successful completion, otherwise nonzero.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reentrant Library}

\portszero\ provides a set of functions that mirror standard C
library routines.  These routines guarantee the following:

\begin{itemize}

\item {\em Reentrancy}:  Multiple threads can call these routines without
interfering with each other.

\item {\em Nonblocking}: A thread that calls one of these routines
is guaranteed to not block other threads from executing.

\end{itemize}

The following sections briefly describe routines that are provided by
\portszero.  Unless otherwise stated, each is identical to the
underlying C library routine after which the \portszero\ routine is
named.

In addition, \portszero\ exports a lock that may be used to control
reentrancy in non-\portszero\ routines.  This lock is manipulated by
the\linebreak {\tt ports0\_reentrant\_lock()} and {\tt
ports0\_reentrant\_unlock()} routines.


\subsection{\tt ports0\_malloc()}
\begin{verbatim}
void *ports0_malloc(size_t bytes)
\end{verbatim}

Allocate memory, like {\tt malloc()}.


\subsection{\tt ports0\_realloc()}
\begin{verbatim}
void *ports0_reallco(void *ptr, size_t bytes)
\end{verbatim}

Reallocate memory, like {\tt realloc()}.


\subsection{\tt ports0\_calloc()}
\begin{verbatim}
void *ports0_callco(size_t nobj, size_t bytes)
\end{verbatim}

Allocate memory, like {\tt calloc()}.


\subsection{\tt ports0\_free()}
\begin{verbatim}
void ports0_free(void *ptr)
\end{verbatim}

Free memory, like {\tt free()}.  The memory pointed to by {\tt ptr}
must have been previously allocated by {\tt ports0\_malloc()}, {\tt
ports0\_realloc()}, or\linebreak {\tt ports0\_calloc()}.


\subsection{\tt ports0\_open()}
\begin{verbatim}
int ports0_open(char *path,
                int flags,
                int mode)
\end{verbatim}

Open a file descriptor, like {\tt open()}.  All file descriptors that
are passed to other \portszero\ library routines must be opened using
{\tt ports0\_open()}.


\subsection{\tt ports0\_close()}
\begin{verbatim}
int ports0_close(int fd)
\end{verbatim}

Close a file, like {\tt close()}.


\subsection{\tt ports0\_read()}
\begin{verbatim}
int ports0_read(int fd,
                char *buf,
                int nbytes)
\end{verbatim}

Read from a file, like {\tt read()}.

Note: Instead of blocking indefinitely, this routine may return an
error with {\tt errno} set to EINTR.


\subsection{\tt ports0\_write()}
\begin{verbatim}
int ports0_write(int fd,
                 char *buf,
                 int nbytes)
\end{verbatim}

Write to a file, like {\tt write()}.

Note: Instead of blocking indefinitely, this routine may return an
error with {\tt errno} set to EINTR.


\subsection{\tt ports0\_lseek()}
\begin{verbatim}
int ports0_lseek(int fd,
                 off_t offset,
                 int whence)
\end{verbatim}

Move the offset within a file for subsequent reads and writes, like
{\tt lseek()}.


\subsection{\tt ports0\_fstat()}
\begin{verbatim}
int ports0_fstat(int fd,
                 struct stat *buf)
\end{verbatim}

Get information about a file, like {\tt fstat()}.


\subsection{\tt ports0\_reentrant\_lock()}
\begin{verbatim}
int ports0_reentrant_lock()
\end{verbatim}

Acquire the \portszero\ reentrancy lock.  


\subsection{\tt ports0\_reentrant\_unlock()}
\begin{verbatim}
int ports0_reentrant_unlock()
\end{verbatim}

Release the \portszero\ reentrancy lock.  

\end{document}



