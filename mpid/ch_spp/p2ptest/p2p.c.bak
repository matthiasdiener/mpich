#define P2P_EXTERN
#include "p2p.h"

void p2p_init(maxprocs,memsize)
int maxprocs;
int memsize;
{

#if defined(SGI)
       
    strcpy(p2p_sgi_shared_arena_filename,"/tmp/p2p_shared_arena_");
    sprintf(&(p2p_sgi_shared_arena_filename[strlen(p2p_sgi_shared_arena_filename)]),"%d",getpid());

    if (usconfig(CONF_INITUSERS,maxprocs) == -1)
    {
	p2p_error("p2p_init: usconfig failed for users: \n",maxprocs);
    }
    if (usconfig(CONF_INITSIZE,memsize) == -1)
    {
	p2p_error("p2p_init: usconfig failed: cannot map shared arena\n",memsize);
    }
    p2p_sgi_usptr = usinit(p2p_sgi_shared_arena_filename);
    if (p2p_sgi_usptr == NULL)
    {
	p2p_error("p2p_init: usinit failed: cannot map shared arena\n",memsize);
    }
#endif
}

void p2p_create_procs(numprocs)
int numprocs;
{
    int i, rc;

    for (i = 0; i < numprocs; i++)
    {
	if ((rc = fork()) == -1)
	{
	    p2p_error("p2p_init: fork failed\n",(-1));
	}
	else if (rc == 0)
	    return;
    }
}


void *p2p_shmalloc(size)
int size;
{
    void *p;

#if defined(SGI)
    p = usmalloc(size,p2p_sgi_usptr);
#endif

    return (p);
}

void p2p_shfree(ptr)
char *ptr;
{

#if defined(SGI)
    usfree(ptr,p2p_sgi_usptr);
#endif

}

#if defined(SGI)

/* p2p_lock and p2p_unlock are defined in p2p.h for SGI */

/* this is the spinlock method */
void p2p_lock_init(L) 
p2p_lock_t *L;
{ 
    (*L) = usnewlock(p2p_sgi_usptr);
}

/* this is the semaphore method */
/**********
void p2p_lock_init(L) 
p2p_lock_t *L;
{ 
    (*L) = usnewsema(p2p_sgi_usptr,1); 
}

**********/
#endif

p2p_cleanup()
{
 
#   if defined(SGI)
    unlink(p2p_sgi_shared_arena_filename);
#   endif
}

/*****

void p2p_dprintf(fmt, va_alist)
char *fmt;
va_dcl
{
    va_list ap;
 
    printf("%s: ", p2p_my_dprintf_id);
    va_start(ap);
#   if defined(HAVE_VPRINTF)
    vprintf(fmt, ap);
#   else
    _doprnt(fmt, ap, stdout);
#   endif
    va_end(ap);
    fflush(stdout);
}
 
void p2p_dprintfl(level, fmt, va_alist)
int level;
char *fmt;
va_dcl
{
    va_list ap;
 
    if (level > p2p_debug_level)
        return;
    printf("%d: %s: ", level, p2p_my_dprintf_id);
    va_start(ap);
#   if defined(HAVE_VPRINTF)
    vprintf(fmt, ap);
#   else
    _doprnt(fmt, ap, stdout);
#   endif
    va_end(ap);
    fflush(stdout);
}

*****/

p2p_error(string,value)
char * string;
int value;
{
    printf("%s %d\n",string, value);
    printf("p2p_error is not fully cleaning up at present\n");
    p2p_cleanup();
    exit(99);
}
