dnl This is an autoconf script.
dnl To rebuild the `configure' script from this, execute the command
dnl 	autoconf
dnl in the directory containing this script.  You must have autoconf
dnl version 1.4 or later (but NOT version 2.0 or later)
dnl
dnl The following text appears in the resulting `configure' script,
dnl explaining how to rebuild it.
[#!/bin/sh
# Guess values for system-dependent variables and create Makefiles.
# Generated automatically using autoconf.
# Copyright (C) 1991, 1992, 1993 Free Software Foundation, Inc.
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

progname="`echo $0 | sed 's:^\./\./:\./:'`"
print_error() {
    echo "*# $*" 2>&1 ;
    }
print_usage() {
cat <<.
Usage: ${progname} [-arch=ARCH_TYPE] [-comm=COMM_TYPE]
            [-device=DEVICE]
            [-prefix=INSTALL_DIR] 
            [-c++[=C++_COMPILER] | --enable-c++ ] [-noc++ | --disable-c++]
            [-cc=C_COMPILER] [-fc=FORTRAN_COMPILER]
            [-clinker=C_LINKER] [-flinker=FORTRAN_LINKER]
            [-c++linker=CC_LINKER] 
            [-nompe] [-mpe] [-mpe_opts=MPE_OPTS] [-jumpshot_opts=JUMPSHOT_OPTS]
	    [-nof77] [-f90nag] [-f95nag] [-opt=OPTFLAGS] 
	    [-make=MAKEPGM ]
            [-cflags=CFLAGS] [-fflags=FFLAGS] [-c++flags=CCFLAGS]
            [-optcc=C_OPTFLAGS] [-optf77=F77_OPTFLAGS]
            [-f90=F90_COMPILER] [-f90flags=F90_FLAGS]
            [-f90inc=INCLUDE_DIRECTORY_SPEC_FORMAT_FOR_F90]
            [-f90linker=F90_LINKER] 
            [-f90libpath=LIBRARY_PATH_SPEC_FORMAT_FOR_F90]
            [-lib=LIBRARY] [-mpilibname=MPINAME]
            [-no_short_longs] [-memdebug] [-ptrdebug]
	    [-listener_sig=name]
            [-usesysv]
            [-mpedbg] [-nompedbg] [-cross] [-devdebug] [-nodevdebug] 
            [-debug | --enable-debug ] [-nodebug | --disable-debug ] 
            [-tracing] [-dlast]
	    [-pkt_size=LENGTH] [-adi_collective]
            [-adi_coll_world]
            [-fortnames=FORTRANNAMES]
            [-ar_nolocal] [-automountfix=AUTOMOUNTFIX]
            [-noranlib] [-rsh=RSHCOMMAND] [-rshnol]
	    [-globusdir=GLOBUSDIR] [-noromio] [-file_system=FILE_SYSTEM]
            [-p4_opts=P4_OPTS]
where
   ARCH_TYPE       = the type of machine that MPI is to be configured for
   COMM_TYPE       = communications layer or option to be used
   DEVICE          = communications device to be used
   INSTALL_DIR     = directory where MPI will be installed (optional)
   MPE_OPTS        = options to pass to the mpe configure
   JUMPSHOT_OPTS   = options to pass to the jumpshot configure
   P4_OPTS         = options to pass to the P4 configure (device=ch_p4)
   C++_COMPILER    = default is to use g++ (optional)
   OPTFLAGS        = optimization flags to give the compilers (e.g. -g)
   CFLAGS          = flags to give C compiler
   FFLAGS          = flags to give Fortran compiler
   MAKEPGM         = version of make to use
   LENGTH          = Length of message at which ADI switches from short
                     to long message protocol
   FORTRANNAMES    = Form of the Fortran names.  See below.
   AUTOMOUNTFIX    = Command to fix automounters
   RSHCOMMAND      = Command to use for remote shell
   MPILIBNAME      = Name to use instead of mpich in the name of the MPI
                     library.  If set, libMPILIBNAME will be used instead
                     or libmpich.  This can be used on systems with
                     several different MPI implementations.
   GLOBUSDIR       = the location of the Globus distribution
   FILE_SYSTEM     = name of the file system ROMIO is to use.  Currently values
                     are nfs, ufs, pfs (Intel), piofs (IBM), hfs (HP), 
                     sfs (NEC), xfs (SGI)

All arguments are optional, but if 'arch', 'comm', or 'prefix' arguments
are provided, there must be only one.  'arch' must be specified before
'comm' if they both appear.

You can select a different C and Fortran compiler by using the '-cc' and
'fc' switches.  The environment variables 'CC' and 'FC' can also provide
values for these but their settings may be overridden by the configure
script.  Using '-cc=\$CC -fc=\$FC' will force configure to use those
compilers.

If '-cross' is given, configure assumes that you are cross-compiling.  If
it is not given, configure expects to be able to run programs.  Even if
'-cross' is not selected, configure will try to determine if you are
cross-compiling; this switch is needed only on systems where attempting
to run a cross-compiled program causes the configure script to hang.

If '-mpe is included as an option, then the MPE 'helper' libraries will be
built.  If '-nompe' is included as an option, then the MPE libraries are not 
built.  The default is to build the libraries ('-mpe').  

The option '-mpedbg' enables the '-mpedbg' command line switch in MPI
programs.  When used with an MPI program, the default error handler
(i.e., MPI_COMM_WORLD's error handler) tries to start xterm's running dbx
for each process that detects an error.  This option is intended
primarily for workstation environments but should work on some MPPs (such
as IBM SP2).

The option '-nof77' prevents the compilation of routines that require a
Fortran compiler.  If this option is selected, you may not use the
Fortran interface to MPI.

The option '--disable-c++' prevents the compilation of the C++ interface 
routines.

The option '-f90nag' allows you to use the NAG Fortran 90 instead of
Fortran 77.  This is a preliminary version and is based on the version
for NeXTs.  The version '-f95nag' may provide support for the NAG f95
compiler; this is based on mail from a user and has not been tested.

The option '-opt' allows you to specify optimization options for the
compilers (both C and Fortran).  For example, '-opt=-O' chooses optimized
code generation on many systems.  '-optcc' and '-optf77' allow you to
specify options for just the C or Fortran compilers.  Use -cflags and
-fflags for options not related to optimization.

The option '-globusdir=GLOBUS' allows one to specify the location of an
installed version of Globus.  You can acquire Globus from
http://www.globus.org .

The option '-lib' allows you to specify the location of a library that
may be needed by a particular device.  Most devices do NOT need this
option; check the installation instructions for those that might.

The option '-make' may be used to select an alternate make program.  For
example, on FreeBSD systems, -make=gnumake may be required because makes
derived from BSD 4.4 do not support the include operation (instead using
the form .include, unlike all other makes); this is used in the wrappergen
utility.

The option '-no_short_longs' may be used to suppress support for ANSI C
types 'long long int' and 'long double' when they are the same size as
'long' and 'double' respectively.  Some systems allow these long ANSI C
types, but generate a warning message when they are used; this option may
be used to suppress these messages (and support for these types).

The option '-fortnames=FORTRANNAMES' allows you to specify the form of
the Fortran names.  This is used primarily to generate names with and
without trailing underscores for those systems that support both.
Possible values are
    FORTRANNAMES value     if Fortran MPI_SEND looks like
    DOUBLEUNDERSCORE       mpi_send__
    UNDERSCORE             mpi_send_
    CAPS                   MPI_SEND
    NOUNDERSCORE           mpi_send 

This option should normally NOT be used; configure determines what the
Fortran compiler generates.  This can be used to override that choice.

The option -finttype=<type> allows you to specify the C integer type
that corresponds to a Fortran INTEGER.  This is int by default.

The option '-ar_nolocal' prevents the library archive command from
attempting to use the local directory for temporary space.  This option
should be used when (a) there isn't much space (less than 20 MB)
available in the partition where MPICH resides and (b) there is enough
space in /tmp (or wherever ar places temporary files by default).

The option '-noranlib' causes the 'ranlib' step (needed on some systems
to build an object library) to be skipped.  This is particularly useful
on systems where 'ranlib' is optional (allowed but not needed; because it
is allowed, configure chooses to use it just in case) but can fail (some
'ranlib's are implemented as scripts using 'ar'; if they don't use the
local directory, they can fail (destroying the library in the process) if
the temporary directory (usually '/tmp') does not have enough space.
This has occured on some OSF systems.

The option '-usesysv' applies to the ch_shmem device, and causes the device to
attempt and use System V shared memory and semaphore routines, rather than
what would be chosen by default (often mmap or a system-specific method).

The option '-memdebug' enables extensive internal memory debugging code.
This should be used only if you are trying to find a memory problem (it
can be used to help find memory problems in user code as well).  Running
programs with the option '-mpidb memdump' will produce a summary, when 
'MPI_Finalize' is called, of all unfreed memory allocated my MPI.   For
example, a user-created datatype that was not later freed would be reported.

The option '--enable-debug' enables the collection of additional information 
for parallel debuggers such as Totalview.

The option '-tracing' enables tracing of internal calls.  This should be
used only for debugging the MPICH implementation itself.

The option '-dlast' enables tracing of the most recent operations performed
by the device.  These can be output when a signal (like SIGINT), error, 
or call to a special routine occurs.  There is a performance penalty for
this option, but it can be very useful for implementors attempting to debug
problems.  

The option '-rsh' allows you to select an alternative remote shell
command (by default, configure will use 'rsh' or 'remsh' from your
'PATH').  If your remote shell command does not support the '-l' option
(some AFS versions of 'rsh' have this bug), also give the option
'-rshnol'.  These options are useful only when building a network version
of MPICH (e.g., '-device=ch_p4' or '-device=ch_tcp').

Special Tuning Options:

There are a number of options for tuning the behavoir of the ADI
(Abstract Device Interface) which is the low-level message-passing
interface.  These should NOT be used unless you are sure you know what
you are doing.

The option '-nodevdebug' disables the debugging code in the MPI ADI code.
This should be used only when you are sure that everything is working
correctly.  (This option is also present to remind benchmarkers that the
low level code by default may contain debugging code.)  Note also that
some of the device code (in mpid/*) has had the debugging code removed
from the source code.  '-devdebug' turns on the debugging code.
'-nodevdebug' is the default.

The option '-pkt_size=LENGTH' allows you to choose the message length at
which the ADI (Abstract Device Interface) switches from its short to long
message format.  LENGTH must be positive.

The option '-adi_collective' allows the ADI to provide some collective
operations in addition to the basic point-to-point operations.
Currently, most systems do not support this option (it is ignored) and on
the others it has not been extensively tested.  The option
'-adi_coll_world' asks the ADI to try and use any collective operations
that are supported only on the MPI_COMM_WORLD communicator (and any
communicator with a similiar group).  This is also untested.

The option -noromio causes ROMIO (portable implementation of MPI I/O) to not
be configured and built.  The default is to build it.  Currently ROMIO can
utilize as its underlying file system NFS, IBM's PIOFS, Intel's PFS, HP's XFS,
NEC's SFS, and SGI's XFS file systems.  It also can use any Unix-compatible
file system (UFS).  The file system to be used can be specified with the
-file_system=FILE_SYSTEM option, but configure will attempt to choose the
approprate one.  Valid values of FILE_SYSTEM are nfs, ufs, pfs, piofs, xfs,
sfs, and hfs.  Multiple choices can be specified with a '+', as in ufs+nfs.

Sample Configure Usage:

To make for running on sun4's running SunOS with ch_p4 as the device,
 and with the installation directory equal to the current directory:

  ./configure -device=ch_p4 -arch=sun4
  make

Known devices are 
        ch_nx     (native Intel NX calls), 
        ch_mpl    (native IBM EUI or MPL calls),
        ch_p4     (p4)
	globus    (Globus)
        ch_meiko  (for Meiko CS2, using NX compatibility library),
        ch_shmem  (for shared memory systems, such as SMPs), 
        ch_lfshmem(for shared memory systems, such as SMPs; uses
                   lock-free message buffers), 
        ch_cenju3 (native NEC Cenju-3 calls)

The following devices were supported with ADI-1, but are currently
unsupported.  Please contact us if you are interested in helping us
support these devices:
        meiko     (for Meiko CS2, using elan tport library), and
	nx        (for Intel Paragon),
	t3d	  (for the Cray T3D, using Cray shmem library).
        ch_nc     (native nCUBE calls, requires -arch=ncube),
        ch_cmmd   (native TMC CM-5 CMMD calls)
These are no longer distributed with the MPICH distribution.      

Known architectures include (case is important)
        sun4      (SUN OS 4.x)
        solaris   (Solaris)
	solaris86 (Solaris on Intel platforms)
        hpux      (HP UX)
        sppux     (SPP UX)
        rs6000    (AIX for IBM RS6000)
        sgi       (Silicon Graphics IRIX 4.x, 5.x or 6.x)
        sgi5      (Silicon Graphics IRIX 5.x on R4400's, for the MESHINE)
        IRIX      (synonym for sgi)
        IRIX32    (IRIX with 32bit objects -32)
        IRIXN32   (IRIX with -n32)
        IRIX64    (IRIX with 64bit objects)
        alpha     (DEC alpha)
        intelnx   (Intel i860 or Intel Delta)
        paragon   (Intel Paragon)
        meiko     (Meiko CS2)
        CRAY      (CRAY XMP, YMP, C90, J90, T90)
        cray_t3d  (CRAY T3D)
        freebsd   (PC clones running FreeBSD)
        netbsd    (PC clones running NetBSD)
	LINUX     (PC clones running LINUX)
        ksr       (Kendall Square KSR1 and KSR2)
        EWS_UX_V  (NEC EWS4800/360AD Series workstation.  Untested.)
        UXPM      (UXP/M. Untested.)
        uxpv      (uxp/v. Untested.)
        SX_4_float0
                  (NEC SX-4; Floating point format float0
                             Conforms IEEE 754 standard.
                   C:       sizeof (int)     = 4; sizeof (float) = 4
                   FORTRAN: sizeof (INTEGER) = 4; sizeof (REAL)  = 4)
        SX_4_float1
                  (NEC SX-4; Floating point format float1
                             IBM floating point format.
                   C:       sizeof (int)     = 4; sizeof (float) = 4
                   FORTRAN: sizeof (INTEGER) = 4; sizeof (REAL)  = 4)
        SX_4_float2
                  (NEC SX-4; Floating point format float2
                             CRAY floating point format.
                   C:       sizeof (int)     = 4; sizeof (float) = 8
                   FORTRAN: sizeof (INTEGER) = 8; sizeof (REAL)  = 8)
                   !!! WARNING !!! This version will not run
                                   together with FORTRAN routines.
                                   sizeof (INTEGER) != sizeof (int)
        SX_4_float2_int64
                   (NEC SX-4; Floating point format float2 and
                              64-bit int's)
                    C:       sizeof (int)     = 8; sizeof (float) = 8
                    FORTRAN: sizeof (INTEGER) = 8; sizeof (REAL)  = 8)

Special notes:

For SGI (-arch=IRIX) multiprocessors running the ch_p4 device, use
-comm=ch_p4 to disable the use of the shared-memory p4 communication
device, and -comm=shared to enable the shared-memory p4 communication
device.  The default is to enable the shared-memory communication device.

Others may be recognized.
.
}
#
UseSharedLibs=0
NEEDS_CC_SHARED_OPT=1
ARCH=""
CPP_DIR=""
MPE_DIR=""
LIB_PATH=""
FLIB_PATH=""
OPTFLAGS=""
OPTFLAGSF=""
F90=""
f90nag=0
NOF77=0
NOMPE=0
NOCXX=""
AR_LOCAL=l
NOSHORTLONGS=0
HAS_FORTRAN=1
MPILIBNAME=mpich
# Nag F90 names are call f90_unix_MP_getarg(i,s) and 
# f90_unix_MP_iargc().
F77GETARGDECL="external getarg"
F77GETARG="call getarg(i,s)"
F77IARGC="iargc()"
F90UNIX="C"
MPI_FOBJECTS="\$(MPI_FOBJECTS)"
MPI_FINT=int
MPI_AINT=long
CFLAGS=""
# We use @ because configure uses %
AUTOMOUNTFIX='sed -e s@/tmp_mnt/@/@g'
#
# By not setting FFLAGS, we get the values from the environment
MAKE=make
P4_MDEPCFLAGS=""
ASMFILES_O=""
PREFIX=""
MPE_OPTS=""
P4_OPTS=""
JUMPSHOT_OPTS=""
DEVCFLAGS=""
CONFIGURE_ARGS="$*"
DEFAULT_MACHINE=''
DEVICE_KIND=MPP
cross_compiling=0
is_adi1=0
debug_version=0
#
FILE_SYSTEM=""
ROMIO=1
ROMIO_CFLAGS=""
ROMIO_FFLAGS=""
ROMIO_LFLAGS=""
ROMIO_TCFLAGS=""
ROMIO_TCPPFLAGS=""
ROMIO_TFFLAGS=""
usesysv=0
#
#MPIFDEP="mpif.h"
# The dependency on mpif.h is now handled by mpif77
MPIFDEP=
#
# -mpedbg
#MPE_MPI_EXT_C="$MPE_MPI_EXT_C dbxerr.c mpehname.c"
#MPE_MPI_EXT_O="$MPE_MPI_EXT_O dbxerr.o mpehname.o"
# dbxerr.c support has become too difficult to make part of the basic
# system (both because it is in MPE, which is now separately built and 
# configured after MPICH, and because of diverging (even for a single vendor)
# command syntax for the debuggers.  Add dbxdee.c/.o when we have a better
# solution.
MPE_MPI_EXT_C="$MPE_MPI_EXT_C mpehname.c"
MPE_MPI_EXT_O="$MPE_MPI_EXT_O mpehname.o"
#
# -devdebug
DEVDEBUGCFLAGS="-DMPID_DEBUG_NONE -DMPID_STAT_NONE"
# -dlast
DLAST=""
#
# This next variable is a version without quotes.
# We could also consider `echo $a | sed -e 's/"/\\"/g'`
CONFIGURE_ARGS_CLEAN=`echo $* | tr '"' ' '`
if test -n "$CONFIGURE_ARGS" ; then 
    echo "Configuring with args $CONFIGURE_ARGS"
fi
#
# Test for C++ support
# We can only set this if there is a C++ compiler....
buildcpp=0
# 
MPIVERSION=`grep 'PATCHLEVEL ' include/patchlevel.h | awk '{print $3}'`
# Make sure to remove quotes...
mvk=`grep 'PATCHLEVEL_RELEASE_KIND' include/patchlevel.h | awk '{print $3}' | \
 sed -e 's/"//g'`
mv1=`grep 'PATCHLEVEL_SUBMINOR' include/patchlevel.h | awk '{print $3}'`
mvtime=`grep 'Date:' include/patchlevel.h | sed -e 's/^.*$Date\(.*\)\$".*$/\1/g'`
if test -n "$mvk" ; then
    MPIVERSION="$MPIVERSION.$mv1 ($mvk) of $mvtime"
else
    MPIVERSION="$MPIVERSION.$mv1 of $mvtime"
fi
# Also check for exp version by looking for "mpich-exp" in the directory
# path
mpidirname=`pwd | sed -e 's%^.*/mpich-exp$%FOUND%g'`
if test "$mpidirname" = "FOUND" ; then
    MPIVERSION="$MPIVERSION (experimental)"
fi
echo "Configuring MPICH Version $MPIVERSION"
#
# IS_HETERO is set if the device supports heterogeneous machines.
# This requires additional coding, including checking for XDR
IS_HETERO=0
for arg
do
  # Handle --exec-prefix with a space before the argument.
  if test x$next_exec_prefix = xyes; then exec_prefix=$arg; next_exec_prefix=
  # Handle --host with a space before the argument.
  elif test x$next_host = xyes; then next_host=
  # Handle --prefix with a space before the argument.
  elif test x$next_prefix = xyes; then prefix=$arg; next_prefix=
  # Handle --srcdir with a space before the argument.
  elif test x$next_srcdir = xyes; then srcdir=$arg; next_srcdir=
  else
    case $arg in
     # For backward compatibility, also recognize exact --exec_prefix.
     -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* | --exec=* | --exe=* | --ex=* | --e=*)
	exec_prefix=`echo $arg | sed 's/[-a-z_]*=//'` ;;
     -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- | --exec | --exe | --ex | --e)
	next_exec_prefix=yes ;;

     -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
	PREFIX=`echo $arg | sed 's/[-a-z_]*=//'` ;;
     -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
	next_prefix=yes ;;

     -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=* | --s=*)
	srcdir=`echo $arg | sed 's/[-a-z_]*=//'` ;;
     -srcdir | --srcdir | --srcdi | --srcd | --src | --sr | --s)
	next_srcdir=yes ;;

     -arch=* | --arch=*)
       package=`echo $arg|sed 's/-*arch=//'`
       # Delete all the valid chars; see if any are left.
       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
         print_error "configure: $package: invalid architecture name"; exit 1
       fi
       ARCH=`echo $package|sed s/-/_/g`
       eval "arch_`echo $package|sed s/-/_/g`=1"
       ;;

     -bopt=* | --bopt=*)
       package=`echo $arg|sed 's/-*bopt=//'`
       # Delete all the valid chars; see if any are left.
       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
         print_error "configure: $package: invalid bopt value" ; exit 1
       fi
       BOPT=`echo $package|sed s/-/_/g`
       eval "bopt_`echo $package|sed s/-/_/g`=1" ;;

     -comm=* | --comm=*)
       package=`echo $arg|sed 's/-*comm=//'`
       # Delete all the valid chars; see if any are left.
       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
         print_error "configure: $package: invalid communications layer name";
	  exit 1
       fi
       COMM=`echo $package|sed s/-/_/g`	
       eval "comm_`echo $package|sed s/-/_/g`=1" 
       # Handle possible synonyms
       if test -n "$comm_ch_eui" ; then
           comm_ch_mpl=1
           COMM=ch_mpl
       fi
	;;

     -device=* | --device=*)
       package=`echo $arg|sed 's/-*device=//'`
       # Delete all the valid chars; see if any are left.
       if test -n "`echo $package|sed 's/[-a-zA-Z0-9_]*//g'`"; then
         print_error "configure: $package: invalid device name" ; exit 1
       fi
       DEVICE=$package    #|sed s/-/_/g`
       # Can't have - in variable names
       package=`echo $package | sed s/-/_/g`
       eval "device_$package=1" 
       # Handle possible synonyms
       if test -n "$device_ch_eui"; then
           device_ch_mpl=1
           DEVICE=ch_mpl
       fi
       ;;

     -adi1)
        CFLAGS="$CFLAGS -DMPI_ADI1"
	is_adi1=1
	;;

     -adi1ok)
	# THIS IS A SECRET FLAG.  DON'T USE THIS UNLESS YOU KNOW WHAT
	# YOU ARE DOING.  IF YOU DON'T KNOW WHAT WE'RE TALKING ABOUT,
	# DON'T USE IT.
	adi1_ok=1
	;;

      -listenersig=*)
         listener_sig=`echo A$arg|sed -e 's/A-listenersig=//g'`
         ;;

     -mpedbg | --mpedbg)
	# Definitions of DEFS must follow the PREPARE
	MPE_MPI_EXT_C="$MPE_MPI_EXT_C dbxerr.c mpehname.c"
	MPE_MPI_EXT_O="$MPE_MPI_EXT_O dbxerr.o mpehname.o"
	;;

     -nompedbg | --nompedbg)
	# Definitions of DEFS must follow the PREPARE
	MPE_MPI_EXT_C=""
	MPE_MPI_EXT_O=""
	;;

     -sharedlib | --sharedlib)
	# UNDOCUMENTED OPTION
	# Try to build shared libraries
	UseSharedLibs=1
	;;

     -nosharedlib | --nosharedlib)
	# UNDOCUMENTED OPTION
	# Done't use shared libraries
	UseSharedLibs=0
	;;

     -strict)
	# Setup for gcc strict checking
	CFLAGS="$CFLAGS -Wall -Wstrict-prototypes -Wmissing-prototypes"
	USER_CFLAGS="$USER_CFLAGS -Wall -Wstrict-prototypes -Wmissing-prototypes"
	ROMIO_CFLAGS="$ROMIO_CFLAGS -Wall -Wstrict-prototypes -Wmissing-prototypes"
	if test -z "$CC" ; then
	    CC=gcc
	    USERCC=1
        fi
	;;

     -ar_nolocal | --ar_nolocal)
	AR_LOCAL=''
	;;

     -noranlib | -no_ranlib)
        RANLIB=':'
	;;

     -usesysv)
	usesysv=1
	;;

     -mpilibname=*)
	MPILIBNAME=`echo A$arg|sed 's/A-*mpilibname=//'`
	;;

     -nodevdebug | --nodevdebug)
        NODEVDEBUG=1
	DEVDEBUGCFLAGS="-DMPID_DEBUG_NONE -DMPID_STAT_NONE"
	;;

     -devdebug | --devdebug)
        NODEVDEBUG=0
	DEVDEBUGCFLAGS=""
	;;

     -debug | --debug | --enable-debug | -enable-debug )
	debug_version=1
	;;
	
     -dlast | --dlast)
	DLAST="-dlast"
	;;

     -nodebug | --nodebug | --disable-debug | -disable-debug )
	debug_version=0
	;;

     -no_short_longs | --no_short_longs)
	NOSHORTLONGS=1
	;;

     -memdebug | --memdebug)
	MEMDEBUG=1
	;;

     -ptrdebug | --ptrdebug)
	PTRDEBUG=1
	;;

     -tracing | --tracing)
	TRDEBUG=1
	;;

     -cross)
	cross_compiling=1
	;;

     -pkt_size=* | --pkt_size=*)
	pktsize=`echo $arg|sed 's/-*pkt_size=//'`
	PKTSIZE=$pktsize
       	DEVCFLAGS="$DEVCFLAGS -DMPID_PKT_MAX_DATA_SIZE=$pktsize"
	;;

     -limited_buffers | --limited_buffers)
	LIMITEDBUFFERS=1
	DEVCFLAGS="$DEVCFLAGS -DMPID_LIMITED_BUFFERS"
	;;

     -tiny_buffers | --tiny_buffers)
	TINYBUFFERS=1
	DEVCFLAGS="$DEVCFLAGS -DMPID_TINY_BUFFERS"
	;;

     -nolimited_buffers | --nolimited_buffers)
	LIMITEDBUFFERS=0
	DEVCFLAGS="$DEVCFLAGS -DMPID_NO_LIMITED_BUFFERS"
	;;

     -notiny_buffers | --notiny_buffers)
	TINYBUFFERS=0
	DEVCFLAGS="$DEVCFLAGS -DMPID_NO_TINY_BUFFERS"
	;;

	# This is for p4 (and p3?)
      -socksize=*|--socksize=*)
   	SOCKSIZE="`echo $arg|sed 's/-*socksize=//'`"
     	;;

     -adi_collective | --adi_collective)
	ADI_COLLECTIVE=1
	;;

     -adi_coll_world | --adi_coll_world)
	ADI_COLL_WORLD=1
	;;

     -f77idx)
	# Force POINTER_64_BITS definition
	F77IDX=1
	;;

     -f90nag)
        # Insert module 
	F90UNIX="      use f90_unix"
	FC=f90
	f90nag=1
	# -mismatch allows type mismatches in arguments.  This 
	# is necessary until we have a Fortran 90 module with
	# generic paramters
	FFLAGS="$FFLAGS -mismatch"
	# Still to do - make sure that the Fortran interface is correctly
	# selected.
        ;;

     -f95nag)
        # Insert module 
	F90UNIX="      use f90_unix_env"
	FC=f95
        F77GETARGDECL=""
	#f90nag=1
	# -mismatch allows type mismatches in arguments.  This 
	# is necessary until we have a Fortran 90 module with
	# generic paramters
	#FFLAGS="$FFLAGS -mismatch"
	# Still to do - make sure that the Fortran interface is correctly
	# selected.
        ;;

      -f90=*)
	F90=`echo $arg|sed 's/-*f90=//'`
	;;
      -f90flags=*)
	USER_SET_F90FLAGS=1
	F90FLAGS=`echo $arg|sed 's/-*f90flags=//'`
	;;
      -f90inc=*)
	USER_SET_F90INC=1
	F90INC=`echo $arg|sed 's/-*f90inc=//'`	
	;;
      -f90linker=*)
	USER_SET_F90LINKER=1
	F90LINKER=`echo $arg|sed 's/-*f90linker=//'`
	;;
      -f90libpath=*)
	USER_SET_F90LIB_PATH=1
	F90LIB_PATH=`echo $arg|sed 's/-*f90libpath=//'`
	;;

     -noc++ | --noc++ | --disable-c++ | -disable-c++ )
        NOCXX="nocxx"
        ;;

     --enable-c++ | -enable-c++) 
	;;

     -c++=* | --c++=*)
       # We use .. instead of \+\+ because \+ is interpreted differently
       # by various sed's
       package=`echo $arg|sed 's/-*c..=//'`
       # Delete all the valid chars; see if any are left.
       #if test -n "`echo $package|sed 's/[-a-zA-Z0-9_+]*//g'`"; then
       #  print_error "configure: $package: invalid c++ compiler name"; exit 1
       #fi
       CPP_DIR="MPI-2-C++"
       CPP_COMPILER=`echo $package`		
       # We need to use mpCC for ch_mpl device!
       if test "$CPP_COMPILER" = "xlC" -a "$DEVICE" = "ch_mpl" ; then
	    CPP_COMPILER=mpCC
       fi
       echo Compiling C++ interface with $CPP_COMPILER ;;

     -cc=* | --cc=*)
	CC=`echo $arg|sed 's/-*cc=//'`
	USERCC=1
	;;

     -fc=* | --fc=*)
	FC=`echo $arg|sed 's/-*fc=//'`
	USERF77=1
	;;

     -fortnames=*)
	# Valid values are
	# FORTRANDOUBLEUNDERSCORE
	# FORTRANUNDERSCORE
	# FORTRANCAPS
	# FORTRANNOUNDERSCORE
	FORTRANNAMES="FORTRAN`echo $arg|sed 's/-*fortnames=//'`"
	;;

     -finttype=*)
	MPI_FINT=`echo a$arg | sed -e '/a-finttype=//g'`
	;;

     -clinker=* | --clinker=*)
	CLINKER=`echo $arg|sed 's/-*clinker=//'`
	USERCLINKER=1
	;;

     -c++linker=* | --c++linker=*)
       # We use .. instead of \+\+ because \+ is interpreted differently
       # by various sed's
	CCLINKER=`echo $arg|sed 's/-*c..linker=//'`
        # We need to use mpCC for ch_mpl device!
        if test "$CCLINKER" = "xlC" -a "$DEVICE" = "ch_mpl" ; then
	    CCLINKER=mpCC
        fi
	USERCCLINKER=1
	;;

     -flinker=* | --flinker=*)
	FLINKER=`echo $arg|sed 's/-*flinker=//'`
	USERFLINKER=1
	;;

      -rsh=*)
	rshcommand=`echo A$arg|sed 's/A-rsh=//'`
	;;

      -rshnol)
	rshnol=1
	;;

     -lib=* | --lib=*)
       package="`echo $arg|sed 's/-*lib=//'`"
       USERLIB="$package" ;;

     -opt=* | --opt=*)
       package="`echo $arg|sed 's/-*opt=//'`"
       OPTFLAGS="$package" ;;

     -optcc=* | --optcc=*)
       package="`echo $arg|sed 's/-*optcc=//'`"
       OPTFLAGSC="$package" ;;

     -optf77=* | --optf77=*)
       package="`echo $arg|sed 's/-*optf77=//'`"
       OPTFLAGSF="$package" ;;

     -mpe_opts=* | --mpe_opts=*)
	package="`echo $arg | sed 's/-*mpe_opts=//'`"
	if test -z "$MPE_OPTS" ; then
  	    MPE_OPTS="$package" 
	else
	    MPE_OPTS="$MPE_OPTS $package"
	fi
	;;
    
     -p4_opts=* | --p4_opts=*)
	package="`echo $arg | sed 's/-*p4_opts=//'`"
	if test -z "$P4_OPTS" ; then
  	    P4_OPTS="$package" 
	else
	    P4_OPTS="$P4_OPTS $package"
	fi
	;;
    
     -jumpshot_opts=* | --jumpshot_opts=*)
	package="`echo $arg | sed 's/-*jumpshot_opts=//'`"
	if test -z "$JUMPSHOT_OPTS" ; then
	    JUMPSHOT_OPTS="$package" 
	else
	    JUMPSHOT_OPTS="$JUMPSHOT_OPTS $package" 
	fi
	;;

     -cflags=* | --cflags=*)
       package="`echo $arg|sed 's/-*cflags=//'`"
       USER_CFLAGS="$package"
       ROMIO_CFLAGS="$package"
       CFLAGS="$CFLAGS $package" ;;

     -c++flags=* | --c++flags=*)
       # We use .. instead of \+\+ because \+ is interpreted differently
       # by various sed's
       package="`echo $arg|sed 's/-*c..flags=//'`"
       USER_CCFLAGS="$package"
       CCFLAGS="$CCFLAGS $package" ;;

     -fflags=* | --fflags=*)
       package="`echo $arg|sed 's/-*fflags=//'`"
       ROMIO_FFLAGS="$package"
       FFLAGS="$package" ;;

     -mpe | --mpe)
       echo "Make will build MPE routines" ;;

     -nompe | --nompe)
       MPE_DIR=""
       NOMPE=1
       echo "Make will not build MPE routines" ;;
 
     -mpe | --mpe)
       MPE_DIR="mpe"
       NOMPE=0
	;;
 
     -make=* | --make=*)
       package=`echo $arg|sed 's/-*make=//'`
       MAKE="$package"
	;;

     -nof77 | --nof77)
       echo "Don't build the Fortran interfaces"
       NOF77=1
       HAS_FORTRAN=0
       CFLAGS="-DMPID_NO_FORTRAN $CFLAGS"
       romio_config_args="$romio_config_args -nof77"
       MPI_FOBJECTS="" ;;
	
     -automountfix=* | --automountfix=*)
	AUTOMOUNTFIX="`echo $arg | sed 's/-*automountfix=//'`"
	;;

     -nobanner)
	nobanner=1
	;;

     -echo )
	set -x 
        configure_echo=1
	;;

     -globusdir=* | --globusdir=*)
	GLOBUSDIR="`echo $arg|sed 's/-*globusdir=//'`"
       ;;

     -noromio | --noromio )
        ROMIO=0
       ;;

     -file_system=* | --file_system=* )
        FILE_SYSTEM="`echo $arg|sed 's/-*file_system=//'`"
       ;;

      -u | -usage | --usage | --usag | --usa | --us | --u | -help | --help )
	print_usage >& 2
       exit 1 ;;

     -v | -verbose | --verbose | --verbos | --verbo | --verb | --ver | --ve | --v)
       verbose=yes ;;

     *) 
	print_error "Unrecognized configure option $arg" 
	exit 1
	;;
    esac
  fi
done]

dnl Finish the initalization
rm -f config.log
AC_PREPARE()
dnl
dnl Place the definitions into a configuration file, rather than sedding
dnl them into Makefiles.  
dnl Comment out this line (with dnl!) to force the definitions into
dnl the Makefiles.  Also, make sure that this file gets moved into the
dnl library directory before the builds take place.
AC_CONFIG_HEADER(mpichconf.h)
#
if test -z "$NOCXX" ; then
    CPP_DIR="MPI-2-C++"
    if test -z "$CPP_COMPILER" ; then
	# aCC is the HPUX ANSI C++ compiler (CC is their older one)
	# We need to use xlC in preference to g++ on AIX 
	# And we need to use mpCC for ch_mpl device!
	PAC_PROGRAMS_CHECK(GXX,xlC g++ c++ aCC CC cxx,,gcc)
	if test "$GXX" = "xlC" -a "$DEVICE" = "ch_mpl" ; then
	    GXX=mpCC
        fi
	if test "$GXX" != "gcc" ; then
	    # Test that this really work: compile iostream.h
cat > conftest.cc <<EOF
#include <iostream.h>
EOF
	    if $GXX -c conftest.cc >/dev/null 2>&1 ; then
                CPP_COMPILER="$GXX"
	        echo Compiling C++ interface with $GXX
	    else
		GXX=""
	    fi
	    /bin/rm -f conftest*
	fi
    fi
    if test -d MPI-2-C++ -a -n "$CPP_COMPILER" ; then
	echo ' '
	echo 'Include C++ bindings for MPI from http://www.mpi.nd.edu/research/mpi2c++'
	echo ' '
	buildcpp=1
    else
	# No compiler found; set the C++ directory to null
	CPP_DIR=""
    fi
fi
# Make sure we remove any configuration file incase there is out-of-date data.
/bin/rm -f mpichconf.h
PAC_FIXUP_SRCDIR
#
# There are definitions in aclocal.m4 that must be in the same directory
# as this configure file for autoconf to properly build configure.
#
# Set basic defintions based on flags set from commandline
#
if test "$ADI_COLLECTIVE" = 1 ; then
    AC_DEFINE(MPID_USE_ADI_COLLECTIVE)
fi
if test "$ADI_COLL_WORLD" = 1 ; then
    AC_DEFINE(MPID_COLL_WORLD)
fi
#
if test -n "$DEVDEBUGCFLAGS" ; then 
    DEVCFLAGS="$DEVCFLAGS $DEVDEBUGCFLAGS"
fi
#
# Definitions for special debugging features.  
if test $debug_version = 1 ; then
    # Make the code keep separate send queues.
    AC_DEFINE(MPI_KEEP_SEND_QUEUE)
fi
#
PAC_GETWD(MPIR_TRIAL,src/pt2pt/Makefile.in)
MPIR_HOME=$MPIR_TRIAL
if test "$NOMPE" = 0 ; then
    MPE_DIR=$MPIR_HOME/mpe
fi
#
#
# Check that an ARCH was set
# If it wasn't set, try to guess using "bin/tarch"
#
if test -z "$ARCH" ; then 
    # First check for some special cases
    if test -n "$device_t3d" ; then 
	ARCH=cray_t3d
        arch_cray_t3d=1
    fi
fi
if test -z "$ARCH" -a -x bin/tarch ; then
    AC_MSG_CHECKING(for architecture)
    ARCH=`./bin/tarch | sed s/-/_/g`
    if test -z "$ARCH" ; then
       AC_MSG_RESULT(Unknown!)
       print_error "Error: Couldn't guess target architecture, you must"
       print_error "       set an architecture type with -arch=<value>"
       exit 1
    fi
    eval "arch_$ARCH=1"
    AC_MSG_RESULT($ARCH)
fi
if test -n "$arch_sgi" ; then
    arch_IRIX=1
    ARCH=IRIX
fi
if test -n "$arch_IRIX64" ; then
    arch_IRIX=1
fi
if test -n "$arch_IRIX32" ; then
    arch_IRIX=1
fi
if test -n "$arch_IRIXN32" ; then
    arch_IRIX=1
fi
#  Handle solaris on Intel platforms, needed to get heterogeneity right in p4
if test -n "$arch_solaris86" ; then
    arch_solaris=1
    ARCH=solaris86
fi
if test -n "$arch_sgi5" ; then
    arch_IRIX5=1
    ARCH=IRIX
fi
if test -n "$arch_cray" ; then
    arch_CRAY=1
    ARCH=CRAY
fi
#
# Check that a DEVICE was set
# If it wasn't set, try to guess using "bin/tdevice"
#
if test -z "$DEVICE" -a -x bin/tdevice ; then
    AC_MSG_CHECKING(device)
    DEVICE=`bin/tdevice $ARCH`
    if test ! -n "$DEVICE" ; then
	AC_MSG_RESULT(Unknown!)
       print_error "Error: Couldn't guess device, you must" 
       print_error "       set a device with -device=<value>" 
       exit 1
    fi
    eval "device_$DEVICE=1" 
    AC_MSG_RESULT($DEVICE)
fi
#
# Check for a VALID device
if test ! -d mpid/$DEVICE ; then
    print_error "$DEVICE is not a valid device!" 
    exit 1
fi
#
# Set Default values of variables
if test -z "$NOCXX" ; then
    if test -n "$CPP_COMPILER" -a -z "$CCLINKER" ; then
        CCLINKER="$CPP_COMPILER"
    fi
    # -O conflicted with -O3, which the C++ configure uses with IRIX64
    # Note that the C++ configure takes -O by default!
    CPPFLAGS="-I$MPIR_HOME/$CPP_DIR/src"
    CPPLDFLAGS="-L$MPIR_HOME/$CPP_DIR/src"
    if test "$CPP_COMPILER" = "g++" ; then 
	# Particularly for LDFLAGS, -fhandle-exceptions must ONLY be used
	# for GNU g++
	AC_MSG_CHECKING([for g++ compiler exception flags])
	cat > conftest.cc <<EOF
int main () {}
EOF
	$CPP_COMPILER -c conftest.cc -fhandle-exceptions 2>conftest.out
	if test ! -s conftest.out ; then
	    CPPFLAGS="$CPPFLAGS -fhandle-exceptions"
	    AC_MSG_RESULT(-fhandle-exceptions)
	else
	    /bin/rm conftest.o conftest.out
	    $CPP_COMPILER -c conftest.cc -fexceptions 2>conftest.out
	    if test ! -s conftest.out ; then
	        CPPFLAGS="$CPPFLAGS -fexceptions"
		AC_MSG_RESULT(-fexceptions)
	    else
		AC_MSG_RESULT(not determined)	
	    fi
	    /bin/rm conftest.o conftest.out conftest.cc
	fi	
	# These LDFLAGS break configure tests that try to link when the
	# compiler is not the C++ compiler.
	# These should be CPPLDFLAGS, if those are required
        #CPPLDFLAGS="$LDFLAGS -fhandle-exceptions"
    fi
fi
#
CC=${CC:-cc}
F77=${FC:-f77}
if test -n "$FC" ; then
    USERF77=1
fi
# CLINKER and FLINKER are set by PAC _GET_CC and F77
#
# First, check for the basic CC and Ranlib 
if test -z "$USERCC" ; then
    AC_PROG_CC
fi
# AC _PROG_INSTALL
#
# Using this autoconf macro for ranlib doesn't handle the problem 
# of 'helpful' ranlib's that issue error messages (!).  Once
# we've identified the proper compiler etc, we'll try this 
# ranlib below; if it fails, we'll replace it with ':'
#
if test -z "$RANLIB" ; then
    AC_PROG_RANLIB
fi
AR="ar cr$AR_LOCAL"
# CPRP is the version of cp that accepts -r and -p arguments.
# See CRAY below
CPRP="cp"
INCLUDE_PATH=""
USER_INCLUDE_PATH=""
USER_DEFS=""
LIB_LIST=""
# Fixup for make
PAC_MAKE_IS_GNUMAKE
PAC_MAKE_IS_BSD44
PAC_MAKE_IS_OSF
#
# Check that a DEVICE was set
if test -z "$DEVICE" ; then
    print_error "You must set a device type with -device=<value>" 
    exit 1
fi
#
# Check that an ARCH was set
if test -z "$ARCH" ; then
    print_error "You must set an architecture type with -arch=<value>"
    exit 1
fi
#
# Set comm from device?
if test -z "$COMM" ; then
    COMM=$DEVICE
    # Remember that COMM set as default, not explicitly, 7/13/95, bri@sgi.com
    default_comm=1
fi
# If some extensions are set, mark the defs
if test -n "$MPE_MPI_EXT_C" ; then
   AC_DEFINE(MPE_USE_EXTENSIONS)
fi

############################################################################
# In order to determine the correct compilers and options to use, 
# we sometimes need to get more detailed information on the system
# This is osversion, osvminor, and cputype.
# Currently, only IRIX uses this
############################################################################
PAC_GET_SPECIAL_SYSTEM_INFO

# special case 'sgi5' for use on MESHINE which is much like an SGI running
# irix 5 with r4400 chips, but does not have 'hinv', so above code doesn't
# work
if test -n "$arch_sgi5"; then
   osversion=5
   cputype=4400
   IRIXARCH="$ARCH_$osversion"
   IRIXARCH="$IRIXARCH_$cputype"
   echo "IRIX-specific architecture is $IRIXARCH"
fi

if test -n "$arch_EWS_UX_V" ; then
    # This is a Unix System V system running on MIP/SGI processors
    LIB_LIST="$LIB_LIST -lsocket -lnsl -lc"	
fi
#
# End of architecture-specific tests
#
if test ! -d build ; then
   mkdir build
fi
if test ! -d build/$ARCH ; then 
   mkdir build/$ARCH
fi
#
# Comm is an option to the device.  It MAY augment the device name, but
# must not be used as a synonym.
if test ! -d build/$ARCH/$DEVICE ; then 
   mkdir build/$ARCH/$DEVICE
fi
for dir in lib include bin data ; do 
    if test ! -d build/$ARCH/$DEVICE/$dir ; then
	mkdir build/$ARCH/$DEVICE/$dir
    fi
done

# Check all of the devices first; they need to be known 
# before doing the transport layer

# check whether --device=chameleon was given
if test -n "$device_chameleon"; then
  echo "Chameleon is no longer supported.  There are specific devices for"
  echo "each system that Chameleon provided (except for PVM, which is not"
  echo "supported)."
  exit 1
fi
# 
# Check for Unix Variants
AC_AIX
AC_MINIX
#
# For Globus, find the device, get the libraries and info needed to build
# the Globus device.
if test -n "$device_globus"; then
  DEVICE_KIND=network
  if test -z "$GLOBUSDIR" ; then
	print_error "You must set the directory for Globus with -globusdir=dir"
	exit 1
  fi
  if test ! -d $GLOBUSDIR ; then
	print_error "Could not find Globus in $GLOBUSDIR"
	exit 1
  fi
  # Check the version
  globusversion=`$MAKE -f $GLOBUSDIR/etc/Makefile.mpich globusversion`
  if test $? != 0 ; then
       print_error "Your version of globus does not support globusversion"
       exit 1
  fi
  # Get the libraries, etc (there's also a globuslibpath and globuslib)
  # For some reason, Globus thinks that only MPICH is interested in this
  # information.  I'm surprised that no other Globus users need this info.
  USERLIB="$USERLIB `$MAKE -f $GLOBUSDIR/etc/Makefile.mpich userlibpath`"
  if test $? != 0 ; then
       print_error "Your version of globus does not support userlibpath"
       exit 1
  fi
  USERLIB="$USERLIB `$MAKE -f $GLOBUSDIR/etc/Makefile.mpich userlib`"
  if test $? != 0 ; then
       print_error "Your version of globus does not support userlib"
       exit 1
  fi
  # User include directories (should there be any?)
  USER_CFLAGS="$USER_CFLAGS `$MAKE -f $GLOBUSDIR/etc/Makefile.mpich userincdir`"
  if test $? != 0 ; then
       print_error "Your version of globus does not support userincdir"
       exit 1
  fi
  # Globus requires different compilers 
  CC=`$MAKE -f $GLOBUSDIR/etc/Makefile.mpich cc`
  if test $? != 0 ; then
       print_error "Your version of globus does not support cc target"
       exit 1
  fi
  CLINKER=`$MAKE -f $GLOBUSDIR/etc/Makefile.mpich clinker`
  if test $? != 0 ; then
       print_error "Your version of globus does not support clinker target"
       exit 1
  fi
  if test -z "$CC" -o -z "$CLINKER" ; then
       print_error "Globus did not specify C compiler or C linker"
       exit 1
  fi
  if test "$USERCC" = 1 ; then
      print_error "Globus device over-rode choice of C compiler"
  fi
  # Set usercc as if -cc was used, since the globus compiler must take
  # precedence
  USERCC=1
  if test "$USERCLINKER" = 1 ; then
      print_error "Globus device over-rode choice of C linker"
  fi
  # Set userclinker as if -clinker was used, since the globus compiler must 
  # take precedence
  USERCLINKER=1
  #
  FLINKER=`$MAKE -f $GLOBUSDIR/etc/Makefile.mpich flinker`
  if test $? != 0 ; then
       print_error "Your version of globus does not support flinker target"
       exit 1
  fi
  if test -n "$FLINKER" ; then 
      USERFLINKER=1
  fi
  # Globus requires an ANSI compiler.  Check that the compiler accepts
  # prototypes
  PAC_CHECK_CC_PROTOTYPES(cc_proto=1,cc_proto=0)
  if test $cc_proto = 0 ; then
	print_error "Globus requires a C compiler that supports prototypes"
	exit 1
  fi

  GLOBUS_INCLUDE_DIR=`$MAKE -f $GLOBUSDIR/etc/Makefile.mpich globusincdir`
  if test $? != 0 ; then
       print_error "Your version of globus does not support globusincdir"
       exit 1
  fi
  #LIB_PATH="$LIB_PATH $GLOBUS_LIB_PATH $GLOBUS_EXTRA_LIB_PATH"
  #LIB_LIST="$LIB_LIST $GLOBUS_LIBS $GLOBUS_EXTRA_LIBS"
  # These files are only included by files in mpich/mpid/globus/*.c
  # and not by the user.
  INCLUDE_PATH="$INCLUDE_PATH $GLOBUS_INCLUDE_DIR"
fi
# Get the C compiler, Fortran compiler, and archiver
CARCH=$ARCH
case $DEVICE in
    ch_cenju3)       CARCH=cenju3 ;;
#    ch_cmmd)         CARCH=cm5 ;;
    ch_mpl|ch_eui)   CARCH=ibmpoe ;;
    ch_meiko|meiko)  CARCH=meiko ;;
    ch_nx|nx)        CARCH=intelnx ;;
#    ch_nc)           CARCH=ncube ;;
#    ch_spp)          CARCH=convex_spp ;;
esac
dnl PAC_GET_CC($CARCH)
dnl Get_ANSI_CC looks for a compiler that accepts prototypes.  It tries 
dnl gcc if the selected CC doesn't accept prototypes
PAC_GET_ANSI_CC($CARCH)
if test $NOF77 = 0 ; then
    PAC_GET_F77($CARCH)
else
    HAS_F77=0
fi
# if HAS_F77 = 0, then define the same variables as if the -nof77 switch
# was given at configure time
if test "$HAS_F77" = "0" ; then
    echo "Will not  build the Fortran interfaces"
    NOF77=1
    HAS_FORTRAN=0
    CFLAGS="-DMPID_NO_FORTRAN $CFLAGS"
    romio_config_args="$romio_config_args -nof77"
    MPI_FOBJECTS="" 
fi
#
PAC_GET_AR($CARCH)
#
# Check to see if the compiler accepts prototypes
PAC_CHECK_CC_PROTOTYPES(AC_DEFINE(HAVE_PROTOTYPES))
#
# Check to see if it accepts const
PAC_CHECK_CC_CONST(,AC_DEFINE(HAVE_NO_C_CONST)
ROMIO_CFLAGS="$ROMIO_CFLAGS -DHAVE_NO_C_CONST")

# Panic check to see if we have any compiler at all
if test -z "$CC" ; then
    print_error "Could not find a C compiler!"
    exit 1
fi
#
# Check for shared library options
if test -z "$SHAREDKIND" ; then 
    SHAREDKIND="ignore"
fi
if test -z "$SHAREDKIND_FOR_TV" ; then
    SHAREDKIND_FOR_TV="ignore"
fi
if test "$UseSharedLibs" = 1 -o "$debug_version" = 1 ; then
    # Options are -fPIC for C (gcc)
    # -KPIC (Solaris SunPro)
    # (none) (AIX, but making the library itself is a mess, and allows -KPIC
    #         as an option!)
    # (none) (Alpha, but allows -fPIC as an option!)
    #
    # There are also needed linker options.  For example, under solaris, 
    # -R<mpich-lib-dir>:$LD_RUN_PATH is needed; this should be determined
    # at mpicc LINK time
    if test "$CC" != "gcc" -a "$ARCH" = "rs6000" ; then
        NEEDS_CC_SHARED_OPT=0
    fi
    if test "$CC" != "gcc" -a "$ARCH" = "alpha" ; then
        NEEDS_CC_SHARED_OPT=0
    fi

    if test "$NEEDS_CC_SHARED_OPT" = 1 ; then 
        # CHECK_COMPILER_OPTION adds option if successful
        CFLAGSSAV="$CFLAGS"
        if test -z "$CC_SHARED_OPT" ; then
            PAC_CHECK_COMPILER_OPTION(-fPIC,CC_SHARED_OPT=-fPIC)
            # Check that we can link with that option
  	    # Note that this does NOT work with SunOS
            SHAREDKIND=gcc
        fi
        if test -z "$CC_SHARED_OPT" ; then
            PAC_CHECK_COMPILER_OPTION(-KPIC,CC_SHARED_OPT=-KPIC)
            if test $ARCH = "solaris" ; then
	        SHAREDKIND=solaris
	        # This only works with some compilers.
	        # Also note that this overrides LD_RUN_PATH
		# -R is used for RUNTIME linking (dlopen)
	        #LDFLAGS="$LDFLAGS -R$MPIR_HOME/build/$ARCH/$DEVICE/lib/shared"
            fi
        fi
	CFLAGS="$CFLAGSSAV"
        # This isn't quite right, but it will work for some systems 
        # Export the shared option to the MPI-2-C++ configure
        CXXFLAGS_FOR_SHARED=$CC_SHARED_OPT
    fi
    # Fortran choices
    # -PIC (SunOS)
    # -KPIC (Solaris)
    # CHECK_COMPILER_OPTION adds option if successful
    FFLAGSSAV="$FFLAGS"
    if test -z "$FC_SHARED_OPT" ; then
        PAC_CHECK_FC_COMPILER_OPTION(-PIC,FC_SHARED_OPT=-PIC)
    fi
    if test -z "$FC_SHARED_OPT" ; then
        PAC_CHECK_FC_COMPILER_OPTION(-fPIC,FC_SHARED_OPT=-fPIC)
    fi
    if test -z "$FC_SHARED_OPT" ; then
        PAC_CHECK_FC_COMPILER_OPTION(-KPIC,FC_SHARED_OPT=-KPIC)
    fi
    FFLAGS="$FFLAGSSAV"
    # Check that the shared libraries work
    export CC
    export CLINKER
    SHARED_LIB_PATH="-L."
    export SHARED_LIB_PATH
    SHARED_LIB_UTIL="util/makesharedlib -noecho -kind=$SHAREDKIND -local -link -noverbose"
    PAC_SHARED_LIBS_OK(,SHAREDKIND=ignore)
    # Note that configure uses CFLAGS for compiling and linking !
    # Add the shared option only if we're building shared libraries
    # (the shared option is also needed when building the totalview
    # dynamically loadable queue library).
    CC_SHARED_OPT_FOR_TV="$CC_SHARED_OPT"
    SHAREDKIND_FOR_TV="$SHAREDKIND"
    if test "$UseSharedLibs" = 1 ; then 
        CFLAGS="$CC_SHARED_OPT $CFLAGS"
        FFLAGS="$FC_SHARED_OPT $FFLAGS"
    else
	CC_SHARED_OPT=""
	FC_SHARED_OPT=""
	CXXFLAGS_FOR_SHARED=""
        SHAREDKIND="ignore"
    fi
    # If we can't find the appropriate options, we should switch to 
    # UseSharedLibs=0
fi
AC_SUBST(CC_SHARED_OPT)
AC_SUBST(CC_SHARED_OPT_FOR_TV)
AC_SUBST(CXXFLAGS_FOR_SHARED)
AC_SUBST(SHAREDKIND)
AC_SUBST(SHAREDKIND_FOR_TV)
#
#
# Various systems have known special needs (particularly libraries);
# get thos here
#    
DEFAULT_MACHINE=$DEVICE
#
if test -n "$device_nx"; then
  DEFAULT_MACHINE="paragon"
  is_adi1=1
  # Check for fast collective routines
  if test  -r /usr/lib/libjmc.a; then
    CFLAGS="$CFLAGS -DICCLIB"
    ICCLIB="iCClib"
  fi
fi

if test -n "$device_ch_shmem" -o -n "$device_ch_lfshmem" ; then
  if test -n "$arch_solaris" ; then
    AC_HAVE_LIBRARY(thread,LIB_LIST="$LIB_LIST -lthread")
    # the C compiler might include this for us, but the Fortran compiler
    # does not
    AC_HAVE_LIBRARY(nsl,LIB_LIST="$LIB_LIST -lnsl")
  fi
  if test -n "$arch_ksr" ; then
    AC_HAVE_LIBRARY(rpc,LIB_LIST="$LIB_LIST -lrpc")
  fi
  if test -n "$arch_alpha" ; then
    AC_HAVE_LIBRARY(rpc,LIB_LIST="$LIB_LIST -lrpc")
  fi
fi
#
if test -n "$device_ch_meiko" -o -n "$device_meiko" ; then
  is_adi1=1
  DEFAULT_MACHINE="meiko"
  # Jim Cownie claims that -laio is no longer needed ...
  if test -s /opt/MEIKOcs2/lib/libmpsc.a ; then
      if test -n "$device_meiko" ; then
          LIB_LIST="$LIB_LIST -L/opt/MEIKOcs2/lib -lew -lelan"
      else
          LIB_LIST="$LIB_LIST -L/opt/MEIKOcs2/lib -lmpsc -lew -lelan"
      fi
  else
      print_error "Could not find the library /opt/MEIKOcs2/lib/libmpsc.a"
      print_error "Cannot build MEIKO version"
      exit 1
  fi
  # This include is needed for the elan.h files
  DEVCFLAGS="$DEVCFLAGS -I/opt/MEIKOcs2/include"
  # These were recommended by Jim Cownie
  if test -z "$OPTFLAGS" ; then
#      OPTFLAGS="-xcg92 -xO2"
       OPTFLAGS="-O"
  fi
  #RANLIB=true
fi
#
if test -n "$device_ch_mpl" ; then
    # Check for ANL default machine:
    if test -d /etc/FRAMES -a -d /mcs ; then
        DEFAULT_MACHINE="anlspx"
    fi
    # check for mpproto.h
    PAC_CHECK_HEADER(mpproto.h,pre_req=1,pre_req=0)
    if test $pre_req = 0 ; then
	print_error "Could not find the header file mpproto.h that is needed"
	print_error "by the ch_mpl device.  Check that you have"
	print_error "IBMs parallel operating environment (POE), which is "
	print_error "required for this device."
	exit 1
    fi
    if test $MPILIBNAME = "mpi" ; then 
	print_error "You should select a name for the MPICH library with"
	print_error "-mpilibname=name_of_library.  Using mpich as the"
	print_error "library name."
	MPILIBNAME="mpich"
    fi
    # We need to check for gettimeofday in case we are not using the Switch
    # timer
    AC_HAVE_FUNCS(gettimeofday)
fi
#
dnl if test -n "$device_ch_spp" ; then
dnl    DEFAULT_MACHINE="convex_spp"
dnl   if test -z "$OPTFLAGS" ; then
dnl	# If optimization is turned on, the wrong code is generated for
dnl	# some operations with unsigned chars.
dnl	OPTFLAGS=-O0
dnl   fi
dnl   AC_RETSIGTYPE
dnl   PAC_HAVE_VOLATILE
dnl   PAC_SIGNALS_WORK
dnl   #  
dnl   LIB_LIST="$LIB_LIST -lcnx_syscall /lib/libail.sl"
dnl fi
if test -n "$device_ch_shmem" -o -n "$device_ch_lfshmem" -o \
      \( -n "$device_ch_p4" -a "$COMM" = "shared" \) ; then 
AC_HAVE_FUNCS(mmap)
# Check that MMAP works!
AC_MSG_CHECKING([that anonymous mmap works])
#
PAC_TEST_PROGRAM([
#include <sys/mman.h>
#include <fcntl.h>
#include <errno.h>
int main(){
int memsize, errno;
caddr_t shmptr;
memsize = getpagesize();
errno = 0;
shmptr = mmap((caddr_t) 0, memsize, 
PROT_READ|PROT_WRITE|PROT_EXEC, 
MAP_SHARED
#ifdef MAP_ANON
|MAP_ANON
#endif
,-1, (off_t) 0);
if (errno){
 return 1;}
return 0;
}
],MMAP=1,MMAP=0)
if test $MMAP = 0 ; then 
   AC_MSG_RESULT(no!)
   AC_DEFINE(HAVE_NO_ANON_MMAP)
else
   AC_MSG_RESULT(yes)
fi
dnl
AC_MSG_CHECKING([that semget works])
SEMGET=1
cat > conftest.c <<EOF
#include <sys/types.h>
#include <sys/ipc.h>
#include <errno.h>
#include <sys/sem.h>
int main () {
key_t key;
int semset_id;
key=ftok(".", 'a');
errno=0;
if ((semset_id=semget(key,10,IPC_CREAT|IPC_EXCL|0666)) == -1) 
printf("%d\n", errno);
else {
printf("%d\n", errno);
semctl(semset_id,0,IPC_RMID,0); }
return 0; 
}
EOF
    if $CC $CFLAGS -o conftest conftest.c $LIBS > /dev/null 2>&1 ; then
	if test -x conftest ; then
	    /bin/rm -f conftest.out
	    ./conftest > conftest.out
	    errno=`cat conftest.out`

	    if test $errno -eq 0 ; then
	        AC_MSG_RESULT(yes)
	    elif test $errno -eq 13 ; then  
	        AC_MSG_RESULT(no)
	        SEMGET=0
                print_error "No access permission rights to the semaphore set"
		print_error "created with this key!"
                print_error "Configure could have chosen to create a"
                print_error "semaphore set using an unacceptable key value"
	     elif test $errno -eq 17 ; then
	        AC_MSG_RESULT(no)
	        SEMGET=0
	        print_error "The semaphore set created with this key"
	        print_error "already exists!"
	        print_error "Try running util/cleanipcs and then reconfiguring"
		print_error "This may or may not help."
	     elif test $errno -eq 43 ; then
	        AC_MSG_RESULT(no)
	        SEMGET=0
	        print_error "The semaphore set created with this key"
		print_error "is marked to be deleted!"
		print_error "Try running util/cleanipcs and then"
	        print_error "reconfiguring.  This may or may not help."
	    elif test $errno -eq 2 ; then
	        AC_MSG_RESULT(no)
		SEMGET=0
		print_error "No semaphore set exists for this key!"
		print_error "Configure could have chosen to create a" 
		print_error "semaphore set using an unacceptable key value."
	    elif test $errno -eq 12 ; then
	        AC_MSG_RESULT(undetermined)
		SEMGET=0
		print_error "Not enough memory to create a semaphore set!"
	        print_error "Try running util/cleanipcs and then" 
		print_error "reconfiguring.  This may or may not help."
	    elif test $errno -eq 28 ; then
	        AC_MSG_RESULT(no)
		SEMGET=0
		print_error "The system limit for the maximum number of"
	        print_error "semaphore sets (SEMMNI), or the system wide"
                print_error "maximum number of semaphores (SEMMNS)"
		print_error "has been reached."
	    fi
	else
	    AC_MSG_RESULT(undetermined)
	    print_error "Could not build executable"
	fi
    else
	AC_MSG_RESULT(undetermined)
	print_error "Could not compile program"
    fi
    /bin/rm -f conftest*
dnl
if test $MMAP = 0 -a "$SEMGET" = 0; then
    print_error "Configure detected that both anonymous mmap and semget fail."
    print_error "Configuring MPICH for shared memory may cause problems!"
fi
fi
dnl
# Shared-memory (processes) device.  Only need to set mpirun default machine.
if test -n "$device_ch_shmem" -o -n "$device_ch_lfshmem" ; then
   DEFAULT_MACHINE="smp"
dnl   SAVEDEFS="$DEFS"
dnl   DEFS=""
   dnl A C _ HAVE_FUNCS(msem_init)
   AC_FUNC_CHECK(msem_init,AC_DEFINE(HAVE_MSEM_INIT)have_msem_init=1)
   if test "$have_msem_init" = 1 ; then
       # If have msem_init, we need to see if we need struct msemaphore or just
       # msemaphore.
       true
       AC_COMPILE_CHECK(Is msemaphore a typedef or struct name?,[
#include <ctype.h>
#include <sys/mman.h>],[
typedef struct msemaphore MPID_Msemaphore;
typedef struct { MPID_Msemaphor lock; int a; } Msem;
Msem sem;
       ],is_struct=1,is_struct=0)
        if test $is_struct = 1 ; then
	    AC_DEFINE(MSEMAPHORE_IS_STRUCT)
	    echo struct
        else
	    echo typedef
        fi
   fi
   #
   # Here's a horrible "feature".  Solaris include null stubs for 
   # mutex_init in libc (!), so that users can build threaded code that
   # doesn't work (rather than putting this null stubs in -lnothread, 
   # where they belong).  Thus, if mutex_init IS found, we need to 
   # check for -lthread.   (Which we should have done above)
   #
   AC_HAVE_FUNCS(mutex_init)
   AC_HAVE_FUNCS(shmat)
   AC_HAVE_FUNCS(semop)
   PAC_HAVE_VOLATILE
   #
  # This should check for shmat and semop first
  if test "$usesysv" = 1 ; then
	AC_DEFINE(SHMEM_PICKED)
	AC_DEFINE(USE_SHMAT)
	AC_DEFINE(LOCKS_PICKED)
	AC_DEFINE(USE_SEMOP)
  fi
   # Look for sigaction routine (instead of signal)
   PAC_CHECK_HEADERS(signal.h)
   AC_HAVE_FUNCS(sigaction)
   # To use sigaction, you also need the struct sigaction.  We've had
   # some systems mess this up
   AC_COMPILE_CHECK(for struct sigaction,[#include <signal.h>],[
struct sigaction act; sigaddset( &act.sa_mask, SIGINT );],sigaction_ok="yes",sigaction_ok="no")
   AC_HAVE_FUNCS(sigprocmask)
   AC_HAVE_FUNCS(signal)
   AC_HAVE_FUNCS(sigmask)
   AC_HAVE_FUNCS(sigset)
   # Also need to get signal hander arg count 1? 3? 4? something else?
   PAC_SIGNALS_WORK
   AC_RETSIGTYPE
   #
   AC_HAVE_FUNCS(gettimeofday)
dnl   AC_MSG_CHECKING(for how many arguments gettimeofday takes)
dnl   AC_TEST_PROGRAM([#include <sys/time.h>
dnl   main() {struct timeval tp;
dnl   gettimeofday(&tp,(void*)0);return 0;}],AC_MSG_RESULT(two - whew),
dnl   DEV_CFLAGS="$DEV_CFLAGS -DUSE_WIERDGETTIMEOFDAY"
dnl   AC_MSG_RESULT(one!))
   AC_HAVE_FUNCS(BSDgettimeofday)
dnl
dnl   DEV_DEFS="$DEFS"
dnl   DEFS="$SAVEDEFS"
fi
if test -n "$device_ch_tcp" ; then
    DEVICE_KIND=network
    AC_VPRINTF
fi

if test -n "$device_ch_p4"; then
  echo "About to do p4 device"
  DEVICE_KIND=network
#  INCLUDE_PATH="$INCLUDE_PATH -I$MPIR_HOME/mpid/ch_p4/p4/include"
# This needs to get the other libraries as required for the specific
# architecture.  
#
# P4's arch specification is different from MPI's (sun4 vs. SUN, etc.)
# Here we set P4_ARCH to the right value, which we deduce from $ARCH and $COMM
# Note that the IRIX code further below may make further changes to 
# P4_ARCH
  if test "$ARCH" = "rs6000"; then
    case $COMM in
      eui|mpl)
        P4_ARCH=SP1_EUI ;;
      p4)
        P4_ARCH=RS6000 ;;
      *)
        P4_ARCH=RS6000 ;;
    esac

########################################################################
#
# Document the IRIX p4 parameter selection a bit, 7/13/95, bri@sgi.com
#
#       OS      COMM    CPU             P4_ARCH         DEFAULT_MACHINE
#       --      ----    ---             -------         ---------------
#       6.x     shared  R8000           SGI_CH64        sgi_mp
#       6.x     shared  *               SGI_CH
#       6.x     *       R8000           SGI             sgi
#       6.x     *       *               SGI
#       5.x     shared  *               SGI_MP          sgi_mp
#       5.x     *       *               SGI
#       *       *       *               SGI
#
# What to do with R10000?  R5000?
########################################################################
# NEW TABLE
#
#       OS      COMM    CPU             P4_ARCH         Other options
#       --      ----    ---             -------         ---------------
#       6                               SGI6
#       6       shared                  SGI6            -p4comm=shared
#       5                               SGI5
#       5       shared                  SGI5            -p4comm=shared
#       *                               SGI
#       *       shared                  SGI             -p4comm=shared
#
# Also supported are special cases of SGI6: SGIN32, SGI32, and SGI64
#              
########################################################################

  elif test "$ARCH" = "IRIX64" ; then
    P4_ARCH=SGI6       #SGI_CH64
#    DEFAULT_MACHINE="sgi_mp"
  elif test "$ARCH" = "IRIX" ; then
    P4_ARCH=SGI
    if test $osversion = 6 ; then
#        if test "$COMM" = "shared" ; then
#  	    # Use IRIX64 for SGI_CH64
# 	    P4_ARCH=SGI_CH32
##	    if test $cputype = 8000 ; then
##	        P4_ARCH=SGI_CH32
#	        DEFAULT_MACHINE="sgi_mp"
##	    fi
#	else
     	    P4_ARCH=SGI6
#	    if test $cputype = 8000 ; then
#	        P4_ARCH=SGI6
#	        #DEFAULT_MACHINE="sgi"
#	    fi
#	fi
    elif test $osversion = 5 ; then 
        P4_ARCH=SGI5         # SGI
#        if test "$COMM" = "shared" ; then
#	    P4_ARCH=SGI_MP
#	    DEFAULT_MACHINE="sgi_mp"
#	fi
    fi
    if test "$COMM" = "shared" ; then
	DEFAULT_MACHINE="sgi_mp"
    fi
  else
    # Note that this will change IRIXxxx to SGIxxx (i.e., IRIX32 to SGI32)
    P4_ARCH=`echo $ARCH | sed \
	    -e 's/sun4/SUN/g'              -e 's/intelnx/IPSC860/g'  \
	    -e 's/IRIX/SGI/g'              -e 's/hpux/HP/g'          \
	    -e 's/solaris86/I86_SOLARIS/g' -e 's/solaris/SUN_SOLARIS/g' \
	    -e 's/c2mp/CONVEX/g'           -e 's/uxpv/UXPV/g'          \
	    -e 's/alpha/ALPHA/g'           -e 's/dec5000/DEC5000/g'       \
	    -e 's/NeXT/NEXT/g'             -e 's/paragon/PARAGONIP/g'     \
	    -e 's/inteldelta/DELTA/g'      -e 's/symmetry/SYMMETRY/g'\
	    -e 's/cray/CRAY/g'             -e 's/tc2000/TC_2000/g'   \
	    -e 's/ksr/KSR/g'               -e 's/freebsd/FREEBSD/g'  \
	    -e 's/cm5/CM5/g'               -e 's/meiko/MEIKO_CS2/g'  \
            -e 's/rs6000/RS6000/g'	   -e 's/symm_ptx/SYMMETRY_PTX/g' \
            -e 's/sppux/HP/g'              -e 's/netbsd/NETBSD/g'`
  fi
echo "Finished setting p4arch..."
#
echo "Configuring p4 subsystem..."
# Make sure that the lib Makefile gets remade
  if test -n "$SOCKSIZE" ; then
      otherargs="-socksize=$SOCKSIZE"
  fi
  if test -n "$configure_echo" ; then
      otherargs="$otherargs -echo"
  fi
  if test -n "$rshcommand" ; then
      otherargs="$otherargs -rsh=$rshcommand"
  fi
  if test -n "$rshnol" ; then
      otherargs="$otherargs -rshnol"
  fi
  if test -n "$DLAST" ; then
      otherargs="$otherargs $DLAST"
  fi
  if test -n "$listener_sig" ; then
      otherargs="$otherargs -listenersig=$listener_sig"
  fi
  if test -n "$P4_OPTS" ; then
      otherargs="$otherargs $P4_OPTS"
  fi
  # specify the C compiler in case it is different from the P4 choice
  (cd mpid/ch_p4/p4 ; \
	./configure -p4arch=$P4_ARCH -p4make="$MAKE" -opt="$OPTFLAGS" -cc="$CC" -p4comm="$COMM" -cflags="$USER_CFLAGS $P4_CFLAGS $CC_SHARED_OPT" $otherargs )
  if test $? != 0 ; then
      print_error "Configure of the p4 sub-system may have failed!"
      exit 1
  fi
  echo "Finished configuring the p4 subsystem"
  P4_MDEPLIBS=`$MAKE -f mpid/ch_p4/p4/lib/Makefile p4mdeplibs | grep -v make`
  LIB_LIST="$LIB_LIST $P4_MDEPLIBS"
  #
  P4_MDEPCFLAGS=`$MAKE -f mpid/ch_p4/p4/lib/Makefile p4mdepcflags | grep -v make`
  if test -n "$P4_MDEPCFLAGS" ; then
      CFLAGS="$CFLAGS $P4_MDEPCFLAGS"
  fi
  P4_MDEPFFLAGS=`$MAKE -f mpid/ch_p4/p4/lib/Makefile p4mdepfflags | grep -v make`
  if test -n "$P4_MDEPFFLAGS" ; then
      FFLAGS="$FFLAGS $P4_MDEPFFLAGS"
  fi

  # These directories are built above.  
  #if test ! -d build/$ARCH/ch_p4/lib ; then 
  #    mkdir build/$ARCH/ch_p4/lib
  #fi 
#   
#   We need to change the makefile.protos in mpid/ch_p4/p4 to use
#   the correct libraries
#   if test -n "$COMM" ; then 
#       COMM="ch_p4_$COMM"
#   else
       COMM="ch_p4"
#   fi
#  if test ! -d build/$ARCH/$COMM/lib ; then 
#       mkdir build/$ARCH/$COMM/lib
#  fi 
#   p4 library is intergrated with libmpi.a...
#   LIB_PATH="$LIB_PATH -L$build/$ARCH/$COMM/lib"
#   LIB_LIST="$LIB_LIST -lp4";
  IS_HETERO=1
  PAC_SIGNALS_WORK
  # For the timers, we try for gettimeofday.  Just for the device
dnl  SAVEDEFS="$DEFS"
  AC_HAVE_FUNCS(gettimeofday)
dnl  AC_MSG_CHECKING(for how many arguments gettimeofday takes)
dnl  AC_TEST_PROGRAM([#include <sys/time.h>
dnl  main() {struct timeval tp;
dnl  gettimeofday(&tp,(void*)0);return 0;}],AC_MSG_RESULT(two - whew),
dnl  DEV_CFLAGS="$DEV_CFLAGS -DUSE_WIERDGETTIMEOFDAY"
dnl  AC_MSG_RESULT(one!))
  AC_HAVE_FUNCS(BSDgettimeofday)
dnl  DEV_DEFS="$DEV_DEFS $DEFS"
dnl  DEFS="$SAVEDEFS"
fi

#
# This is incomplete
dnl if test -n "$device_ch_p4_1" ; then
dnl   AC_HAVE_FUNCS(gettimeofday)
dnl   LIB_LIST="$LIB_LIST /home/MPI/mpich/mpid/ch_p4/libp4.a"
dnl   IS_HETERO=1
dnl fi

if test -n "$arch_IRIX"; then
   # We now have to look at  all sorts of things to determine the
   # various flags.  We need to set both the CFLAGS and various options
   # for the linkers (by setting CLINKER and FLINKER).
   # The OS version and chipset were determined above so that they could
   # be used to set the P4_ARCH if necessary.
   #
   # Latest information we have is that (thanks to Winfrid Tschiedel 
   # <Winfrid.Tschiedel@mch.sni.de>):
   #  cputype          Instruction sets
   #  R4X00            -mips2 -mips3 (mips2 requires -32)
   #  R5000, R8000 and R10000 : -mips2 (-32) and -mips3 (-n32 or -64)
   #                            -mips4 (-n32 or -64)
   # Also, IRIX 6.2 supports R4X00 only in 32 bit mode (requires -n32)
   # EXCEPT for R4400, which also supports -64.
   # In 6.2, the defaults SEEM to be -32 -mips 2
   # but you may need -64 -mips3 OR -mips 4 OR -n32 -mips3 or -mips4
   # Also, some systems REQUIRE -non_shared and others REQUIRE NOT 
   # -non_shared.  
   # 
   # Finally, compilation with optimization may stree the linker;
   # include -TENV:large_GOT=ON in this case
   #
   if test $osversion = 4 ; then
	# Nathan's tests showed that we needed this.
	RANLIB="ar ts"
   elif test $osversion = 5 ; then
        # Turn off warnings about long doubles not being supported.
	if test "$CC" != "gcc" ; then
            CFLAGS="$CFLAGS -woff 728"
	    # Other useful woff values are: 852,635,813,831,835
        fi
   elif test $osversion = 6 ; then
#       these flags settings are handled by including MDEPCFLAGS from p4
	SYMTYPE=""
	if test $cputype = 8000 -o $cputype = 10000 ; then
	    if test -n "$arch_IRIX64" ; then
	        SYMTYPE="-64 -mips4"
            elif test -n "$arch_IRIXN32" ; then
		SYMTYPE="-n32"
            else 
		SYMTYPE="-32"
            fi
	elif test $cputype -gt 4000 ; then
	    if test -n "$arch_IRIX64" ; then
		SYMTYPE="-64 -mips3"
            elif test -n "$arch_IRIXN32" ; then
		SYMTYPE="-n32"
            else 
		SYMTYPE="-32"
            fi
        else
	    # According to winfrid.tschiedel@mch.sni.de, need -n32 for R4000
	    SYMTYPE="-n32"
            # Not "-n32 -mips3"?
        fi
	if test -n "$P4_MDEPFFLAGS" ; then
	    # This no longer works.  At least at MCS, the Fortran compiler
	    # won't accept these.
	    addflags=0
	    PAC_CHECK_FC_COMPILER_OPTION($P4_MDEPFFLAGS,addflags=1)
	    if test $addflags = 1 ; then 
                FFLAGS="$FFLAGS $P4_MDEPFFLAGS"
	    fi
        fi
        # Warning flags are > 1000
#       CFLAGS="$CFLAGS -woff 1152,1174,1184"
#       1184 not in the p4 list
        if test "$CC" != "gcc" ; then
            CFLAGS="$CFLAGS -woff 1184,1174"
        fi
	# Check whether we need to add SYMTYPE to CFLAGS and FFLAGS
	hasarg=`echo A$CFLAGS | sed -n -e '/-n32/p' -e '/-32/p' -e '/-64/p'`
#       override SYMTYPE computed above (2/21)
        SYMTYPE=""
	if test -z "$hasarg" ; then
            CC="$CC $SYMTYPE"
	    F77="$F77 $SYMTYPE"
	    CLINKER="$CC $SYMTYPE"
	    FLINKER="$F77 $SYMTYPE"
#	else 
#	    hasarg=`echo A$CLINKER | sed -n -e '/-n32/p' -e '/-32/p' -e '/-64/p'`
#	    if test -z "$hasarg" ; then
#		# We need to make the linker compatible with the compiler.
#	    fi
	fi
   fi
   echo "Messages about long doubles not being supported are being suppressed"
   dnl AC_HAVE_ LIBRARY ( sun )
fi

# for symm_ptx, add the ptx_ifile to  LIB_LIST
if test -n "$arch_symm_ptx"; then
  LIB_LIST="$LIB_LIST $MPIR_HOME/ptx_ifile"
fi

# check whether --arch=intelnx was given
# Use this for both i860 and Delta
if test -n "$arch_intelnx"; then
  DEFAULT_MACHINE="i860"
  # Note that RANLIB may be set incorrectly if we are cross-compiling...
  RANLIB=true
  # inteldelta is used to select the appropriate args to killproc...
  DEVCFLAGS="$DEVCFLAGS -Dinteldelta"
  #
  # X11 includes are in /usr/ipsc/XDEV/i860/include-ipsc/X11
  # X11 libs are in /usr/ipsc/XDEV/i860/lib-coff
  # at least on one system
fi

# check whether --arch=paragon was given
if test -n "$arch_paragon"; then
  DEFAULT_MACHINE="paragon"
  #OPTFLAGS="-O"
  # Note that RANLIB may be set incorrectly if we are cross-compiling...
  RANLIB=true
  #echo "If you get errors about killproc, uncomment this line"
  #DEVCFLAGS="$DEVCFLAGS -DPARAGON_HAS_NO_KILLPROC"
fi


if test -n "$arch_CRAY"; then
   # The CRAY cp doesn't even support -r (!!) but at least there 
   # is a version that does work.
   if test -x /usr/ucb/cp ; then
       CPRP="/usr/ucb/cp"
   else
       print_error "Using default cp for copy; install may fail if -r and -p"
       print_error "switches are not supported."
   fi
   # It might be better to use AR="bld qvz" than the regular ar clr
   DEVCFLAGS="$DEVCFLAGS -DMPID_FLOAT_CRAY"
   # We might want to add
   # -DMPIR_FORT_INT_T=long
   # to the defines.
   # According to Laurie Costello <lmc@cray.com>, the Triton needs this
   # definition
dnl
   # If tested code does NOT compile, then define _TWO_WORD_FCD
   AC_COMPILE_CHECK([whether TWO_WORD_FCDs are used],
[#include <fortran.h>],[void  *buf;_fcd temp;temp = _fcdtocp(buf);],
compile_check=yes,compile_check=no)
if test "$compile_check" = "no" ; then
    TEMP_CFLAGS=$CFLAGS
    CFLAGS="-D_TWO_WORD_FCD $CFLAGS"
    AC_COMPILE_CHECK([whether program compiles if _TWO_WORD_FCD is defined ],
[#include <fortran.h>],[void  *buf;_fcd temp;temp = _fcdtocp(buf);],
compile_check=yes,compile_check=no)
    if test "$compile_check" = "no" ; then
	print_error "You may have problems compiling the Fortran interface",
	print_error "specifically calls to  _fcdtocp"
    elif test "$compile_check" = "yes" ; then
        AC_DEFINE(_TWO_WORD_FCD)
    fi
    CFLAGS=$TEMP_CFLAGS
fi
   # 
dnl   if test -n "$arch_CRAYTS" ; then 
dnl       AC_DEFINE(_TWO_WORD_FCD)
dnl   fi
fi
#
# The compilers are in /mpp/bin (at least on some systems)
# You may also need 
# setenv TARGET cray-t3d
# Also need -lsma library
if test -n "$arch_cray_t3d"; then
   is_adi1=0
   DEFAULT_MACHINE="cray_t3d"
   LIB_LIST="$LIB_LIST -lsma"
   RANLIB=true
   # dbxerr not supported by T3D (-mpedbg)
   MPE_MPI_EXT_C="mpehname.c"
   MPE_MPI_EXT_O="mpehname.o"
   AC_DEFINE(MPI_NO_MPEDBG)
   # The CRAY cp doesn't even support -r (!!) but at least there 
   # is a version that does work.
   if test -x /usr/ucb/cp ; then
       CPRP="/usr/ucb/cp"
   else
       print_error "Using default cp for copy; install may fail if -r and -p"
       print_error "switches are not supported."
   fi
   #  ASMFILES_O="shmem_stack.o get_stack.o"
   # Some users needed /mpp/bin/asm, others /opt/ctl/bin/cam
   for asm in /mpp/bin/cam /opt/ctl/bin/cam /mpp/bin/asm ; do
       if test -s $asm ; then
           ASM=$asm
           break
       fi
   done
   if test -z "$ASM" ; then 
        print_error Cannot find assembler needed to build MPICH
        print_error Neither /mpp/bin/cam, /opt/ctl/bin/cam,  nor 
        print_error /mpp/bin/asm is available
        exit 1
   fi
   # 
   # This is needed for the Fortran interfaces (also for the triton CRAY TS)
   AC_DEFINE(_TWO_WORD_FCD)
fi

# In default (pre-ANSI) mode, nested #if's cause most of the file to
# be SILENTLY skipped.  
if test -n "$arch_hpux" -o -n "$arch_sppux" ; then
    if test -n "$device_ch_shmem" -o -n "$device_ch_lfshmem" ; then
       ASMFILES_O="amem.o"
       DEVCFILES="mem.c"
       DEVOFILES="mem.o"
    fi
    if test -n "$device_ch_shmem" -a -n "$comm_convex_spp" ; then
       DEVCFILES="shmem1stbar.c cnxCxdb.c cnxQuerySC.c cnxGlobalop.c cnxCopy.c"
       DEVOFILES="shmem1stbar.o cnxCxdb.o cnxQuerySC.o cnxGlobalop.o cnxCopy.o"
    fi
    # We can also remove +U77 and -lU77 from the p4 lib/defs.all file.
fi

if test -n "$arch_UXPM" ; then
    # This asserts that Fortran passes functions by passing the address of the
    # pointer to the function.
    # We really need a TEST for this
    AC_DEFINE(FORTRAN_SPECIAL_FUNCTION_PTR)
    # Suggested values for these are
    #CFLAGS=-O
    dnl    #FFLAGS=-Oe,-U -Aabe ( Parameter e is not supported on  uxp/m )
    FLINKER=frt
    FLIBS="$(FLIB_PATH) $(LIB_LIST)"
fi
if test -n "$arch_uxpv" ; then
    # This asserts that Fortran passes functions by passing the address of the
    # pointer to the function.
    # We really need a TEST for this
    AC_DEFINE(FORTRAN_SPECIAL_FUNCTION_PTR)
    # Suggested values for these are
    #CFLAGS=-O
    # Thanks to Winfrid Tschiedel <Winfrid.Tschiedel@mch.sni.de> for
    # this information
    dnl FLINKER="ld -dy -J /usr/ccs/lib/crt0.o /usr/lang/lib/fj90rt0.o /usr/ccs/lib/values-Xt.o"
    FLINKER="frt  -sc -Wl,-dy" # it works already and it is close the final solution
    # This isn't quite correct, but at least this is a place to put this 
    # information.
dnl    FLIBS="$(FLIB_PATH) $(LIB_LIST)  -lfj90 -lfj90fv -lfj90f -lfjsamp -lm -lelf        -lsocket -lnsl -lgen -lpx -ljsp -lvfl -lc"
    FLIBS="$(FLIB_PATH) $(LIB_LIST)"
fi
#
# Not all versions of gcc support -munalign-doubles!
#if test -n "$arch_sun4" -o -n "$arch_solaris" ; then
#    if test "$CC" = "gcc" -a "$NOF77" = 0 ; then
#        CC="$CC -munaliged-doubles"
#    fi
#fi
#
# check whether --comm=p4 was given
if test -n "$comm_p4"; then
  echo "Please use -device=ch_p4 instead of -device=chameleon -comm=p4"
  exit 1
fi

dnl if test -n "$arch_SX4" ; then 
dnl     CFLAGS="$CFLAGS -pvctl,nomsg -DCHAR_PTR_IS_ADDRESS"
dnl fi
# This really needs to look at arches of the form SX_4_float[012] and
# SX_4_float2_int64
issx4=`expr "$ARCH" : "\(SX_4_float\)[012]"`
if test "$issx4" = "SX_4_float" ; then
    arch_SX4=1
fi
if test -n "$arch_SX4" ; then 
    # The -pvctl,nomsg option suppresses "vec inf: Unvectorized loop"
    # messages from the compiler.  Need to test that this is a valid
    # option....
    # Also note that it causes -hobjlst (assembly listing) to silently fail.
    dnl CFLAGS="$CFLAGS -pvctl,nomsg -DCHAR_PTR_IS_ADDRESS"
    if test -n "$device_ch_lfshmem" ; then
       ASMFILES_O="vtest1.o syncvset0.o syncvset1.o vmemcpy.o tslock.o tsunlock.o tslock_init.o"
       DEVCFLAGS="$DEVCFLAGS -DLOCKS_PICKED -DUSE_TSLOCKS -DMPID_USE_SX4_VOPS"
#
	if test -z "$sx4int" ; then
	    if test "$ARCH" = SX_4_float2_int64 ; then
		sx4int=int64
	    else
	        sx4int=int32
	    fi
	fi
       for file in $ASMFILES_O
       do
          files=`echo $file | sed -e "s/.o$/.s/"`
          rm -f mpid/$DEVICE/$files
          cp mpid/$DEVICE/sx4_$sx4int/$files mpid/$DEVICE/$files
       done
    else
       DEVCFLAGS="$DEVCFLAGS -DLOCKS_PICKED -DUSE_SEMOP"
    fi
    DEVCFLAGS="$DEVCFLAGS -DHAVE_SHMAT=1 -DHAVE_SEMOP=1 -DRETSIGTYPE=void -DHAVE_SIGACTION -DMPI_SX_4 -DMPID_SETUP_SIGNALS"
dnl    # We've learned that if Fortran is selected, you should use Fortran to
dnl    # link with.
dnl    if test "$USERCLINKER" != 1 -a "$NOF77" != 1 -a -n "$FLINKER" ; then 
dnl	CLINKER="$FLINKER"
dnl    fi
fi
# check whether --comm=pvm3 was given
if test -n "$comm_pvm3"; then
  echo "PVM 3 no longer supported."
  echo "Note that MPICH was NEVER implemented on top of PVM; PVM was merely"
  echo "one of the many devices supported from the very beginning."
  exit 1
fi

#
# Finally, we are ready to check to see if we are cross-compiling.
#
if test $cross_compiling = 0 ; then
    AC_CROSS_CHECK()
fi
if test $cross_compiling = 1 ; then
    if test $DEVICE = ch_shmem -o $DEVICE = ch_p4 -o $DEVICE = ch_tcp -o \
	$DEVICE = ch_lfshmem ; then
        print_error "Configure was unable to compile and run a simple program."
    fi
fi
#
# Some devices use gettimeofday.  If this is one of them, check to see 
# what form it is
if test -n "$arch_solaris" -o -n "$arch_SX_4" ; then
    PAC_IS_GETTIMEOFDAY_OK(,DEVCFLAGS="$DEVCFLAGS -DUSE_WIERDGETTIMEOFDAY")
fi

# Look for sigaction routine (instead of signal)
# This is used in one of the TEST programs (sigchk.c)
PAC_CHECK_HEADERS(signal.h)
AC_HAVE_FUNCS(sigaction)
AC_COMPILE_CHECK(for struct sigaction,[#include <signal.h>],[
struct sigaction act; sigaddset( &act.sa_mask, SIGINT );],sigaction_ok="yes",sigaction_ok="no")
#
# Test for weak symbol support...
# We can't put # in the message because it causes autoconf to generate
# incorrect code
AC_MSG_CHECKING(for weak symbol support)
AC_TRY_LINK([
#pragma weak PFoo = Foo
int Foo(a) { return a; }
],[return PFoo(1);],has_pragma_weak=1)
if test "$has_pragma_weak" = 1 ; then
    AC_MSG_RESULT([pragma weak])
else
    AC_TRY_LINK([
#pragma _HP_SECONDARY_DEF Foo = PFoo
int Foo(a) { return a; }
],[return PFoo(1);],has_pragma_hp_secondary=1)
    if test "$has_pragma_hp_secondary" = 1 ; then 
        AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
    else
        AC_TRY_LINK([
#pragma _CRI duplicate PFoo as Foo
int Foo(a) { return a; }
],[return PFoo(1);],has_pragma_cri_duplicate=1)
        if test "$has_pragma_cri_duplicate" = 1 ; then
	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
        else    
            AC_MSG_RESULT(no)
        fi
    fi
fi
#
# Check for remote shell program
#
if test -z "$rshcommand" ; then
    PAC_PROGRAMS_CHECK(RSHCOMMAND,remsh rsh)
    rshcommand="$RSHCOMMAND"
fi
#
# Check for perl and perl version
PAC_PROGRAMS_CHECK(PERL,perl5 perl,,,PERLFULLPATH)
if test -n "$PERL" ; then
    PERL="$PERLFULLPATH"
    changequote(,)
    perlversion=`$PERL -v | grep 'This is perl' | \
	sed -e 's/^.*version *\([0-9]\).*$/\1/'`
    changequote([,])
    # Should do a test first for ch_p4 etc.
    if test "$perlversion" != 5 ; then
        echo "Some scripts require perl version 5, which configure did not find."
        echo "You can set the environment variable PERL to contain the "
        echo "location of perl version 5."
	echo "Configure believes that $PERL is version $perlversion ."
	PERL=""
    fi
    AC_SUBST(PERL)
fi
#
# Check for Fortran
if test $HAS_F77 = 0 -a $NOF77 = 0 ; then
    NOF77=1
    HAS_FORTRAN=0
    AC_DEFINE(MPID_NO_FORTRAN)
    dnl CFLAGS="$CFLAGS -DMPID_NO_FORTRAN"
    MPI_FOBJECTS="" 
elif test $HAS_F77 = 1 ; then
    # msg_yes set to yes if the command line routine is found
    msg_yes=no
    # Some Fortran compilers want -lU77 to get getarg etc.
    # Create a test program for these functions.
    # Note that there has been an unfortunate split in the Fortran
    # command line support from Unix.  Apparently, POSIX defines
    # *DIFFERENT* interface, call pxfgetarg(i,str,len,ierr), for
    # getarg.  We need to rearrange these tests to try the various 
    # different interfaces.  
cat > conftest.f <<EOF
        program main
$F90UNIX
        integer i
        character*20 s

	$F77GETARGDECL
        $F77GETARG
        i=$F77IARGC
        end
EOF
     AC_MSG_CHECKING(that Fortran has routines to get commandline)
     if $F77 $FFLAGS -o conftest conftest.f $FLIBS > /dev/null 2>&1 ; then
        if test -x conftest ; then
	    rm -rf conftest*
	    AC_MSG_RESULT(yes)
	    msg_yes=yes
        else
            AC_MSG_RESULT(no)
        fi
     else
	AC_MSG_RESULT(no)
     fi
     if test "$msg_yes" = "no" ; then   
         AC_MSG_CHECKING(that -lU77 provides commandline functions)
         FLIBSAVE="$FLIBS"
         FLIBS="-lU77 $FLIBS"
         if $F77 $FFLAGS -o conftest conftest.f $FLIBS > /dev/null 2>&1 ; then
	     if test -x conftest ;  then
	         rm -rf conftest*
	         AC_MSG_RESULT(yes)
	         FLIB_LIST="$FLIB_LIST $FLIBS"
	         msg_yes=yes
             else
	         AC_MSG_RESULT(no)
	     fi
         else
	    AC_MSG_RESULT(no)
	 fi
     fi
     if test "$msg_yes" = "no" ; then
         AC_MSG_CHECKING(that -N109 compile option works with -lU77)
         FFLAGS_SAVE="$FFLAGS"
	 FFLAGS="-N109 $FFLAGS"
         if $F77 $FFLAGS -o conftest conftest.f $FLIBS > /dev/null 2>&1 ; then 
	     if test -x conftest ; then
	         rm -rf conftest*
	         AC_MSG_RESULT(yes)
	         FLIB_LIST="$FLIB_LIST $FLIBS"
	         msg_yes=yes
	         USER_SET_F90FLAGS=1
	     else
	         AC_MSG_RESULT(no)
	         FLIBS="$FLIBSAVE"
	         FFLAGS="$FFLAGS_SAVE"
	     fi  
         else
             AC_MSG_RESULT(no)
         fi  
     fi 
     # If at the end of all the tests we haven't found a workable solution,
     # report the problem.
     if test "$msg_yes" = "no" ; then
	 F77GETARGDECL=""
	 F77GETARG="print *, 'ERROR - CANNOT FIND COMMAND LINE ARGS'"
	 F77IARGC=0
	 print_error "Command line options will not work with Fortran"
	 print_error "You will not be able to run MPI programs "
	 print_error "if MPI_INIT is called from Fortran."
     fi
     PAC_GET_FORTNAMES
     if test $HAS_FORTRAN = 0 ; then
         dnl CFLAGS="$CFLAGS -DMPID_NO_FORTRAN"
	 AC_DEFINE(MPID_NO_FORTRAN)
         MPI_FOBJECTS=""
     elif test -n "$WDEF" ; then
         CFLAGS="$CFLAGS $WDEF"
dnl      elif test -n "$FORTRANNAMES" ; then
dnl	 AC_DEFINE($FORTRANNAMES)
     fi
fi  #elif
if test $HAS_FORTRAN != 0 ; then
    PAC_FORTRAN_HAS_INCDIR($MPIR_HOME/include,FINC="-I@MPIR_HOME@/include",)
    # some systems support FINC="-Wf,-I@MPIR_HOME@/include" (SGI for one)
    # If I can find others, I'll try them.  For this, I'll need
    # to test for it (the test above tries -I$1 for a file created for the test)

    PAC_FORTRAN_HAS_EXCLAM_COMMENTS(fixupmpif=yes,fixupmpif=no)

    # Check that pmpi_wtime and pmpi_wtick can be in the mpif.h file
    AC_MSG_CHECKING([that unused externals are ok])
    rm -f conftest*
    cat > conftest.f <<EOF
        program main
        external bar
        end
EOF
    if $F77 $FFLAGS -o conftest conftest.f >conftest.out 2>&1 ; then
	AC_MSG_RESULT(yes)
	MPIFPMPI=",PMPI_WTIME, PMPI_WTICK"
    else 
	AC_MSG_RESULT(no)
	MPIFPMPI=""
	if test -s conftest.out ; then cat conftest.out >> config.log ; fi
	print_error "Removed PMPI_WTIME and PMPI_WTICK from mpif.h"
	print_error
    fi   
    AC_SUBST(MPIFPMPI)
    rm -f conftest* 
    # Check for extra Fortran types
    PAC_TEST_FORTTYPES
    # Defines FORT_INT1=1, FORT_INT2=1, FORT_INT4=1, FORT_INT8=1,
    # FORT_INT16=1, FORT_REAL4=1, 
    # FORT_REAL8=1, FORT_REAL16=1, FORT_COMPLEX8=1, FORT_COMPLEX16=1,
    # FORT_COMPLEX32=1, FORT_DOUBLE_COMPLEX=1 if the types are available.
    # For each defined type, find the corresponding C MPI_DATATYPE.
    # If none can be found, use MPI_DATATYPE_NULL.
    for c_type in char short int long "long long" float double "long double"; do
	PAC_GET_TYPE_SIZE($c_type,typelen)
    done
    if test -z "$FORT_REAL_LEN" ; then
        PAC_FORTRAN_GET_REAL_SIZE(fort_real_len)
	if test -z "$fort_real_len" ; then
	    print_error "Unable to determine the length of a FORTRAN real"
	    print_error "You can set the environment variable FORT_REAL_LEN"
	    print_error "with the number of bytes in a FORTRAN real and rerun"
	    print_error "configure."
	fi
    else 
	fort_real_len=$FORT_REAL_LEN
    fi
    # Set the corresponding MPI_Datatypes
    char_mpi=1
    short_mpi=4
    int_mpi=6
    long_mpi=8
    long_long_mpi=13
    float_mpi=10
    double_mpi=11
    long_double_mpi=13
    # Warning: float_cplx is Fortran COMPLEX, not (float,float)
    float_cplx_mpi=23
    # Warning: double_cplx is Fortran DOUBLE COMPLEX, not (double,double)
    double_cplx_mpi=24
    for len in 1 2 4 8 16 ; do
        eval testval=\$"FORT_INT$len"
        AC_MSG_CHECKING(for Fortran INTEGER*$len)
        found=0
	if test "$testval" = 1 ; then
	    for c_type in char short int long "long_long" ; do
		eval typelen=\$"${c_type}"_len
		if test $len = "$typelen" ; then
		    # Fortran type FORT_INT$len corresponds to C type
		    # $ctype
		    eval FORT_INT$len=\$"${c_type}_mpi"
		    AC_MSG_RESULT(found)
		    found=1
		    break
		fi 
            done
        fi
        if test $found = 0 ; then
	    eval FORT_INT$len=0
            AC_MSG_RESULT(not supported)
        fi
    done
    for len in 4 8 16 ; do
	# Use len2 for Complex.
        len2=`expr $len + $len`
	lenby2=`expr $len / 2`
        eval testval=\$"FORT_REAL$len"
        AC_MSG_CHECKING(for Fortran REAL*$len and COMPLEX*$len2)
        found=0
	if test "$testval" = 1 ; then
	    for c_type in float double "long_double" ; do
		eval typelen=\$"${c_type}"_len
		if test $len = "$typelen" ; then
		    # Fortran type FORT_REAL$len corresponds to C type
		    # $ctype
		    eval FORT_REAL$len=\$"${c_type}_mpi"
		    # Notes that we may not have been able to determine 
		    # fort_real_len
		    # The corresponding Complex type
		    if test "$fort_real_len" = "$len" ; then 
			eval FORT_COMPLEX$len2=$float_cplx_mpi
		    elif test "$fort_real_len" = "$lenby2" ; then
			eval FORT_COMPLEX$len2=$double_cplx_mpi
		    else
			eval FORT_COMPLEX$len2=0
		    fi
		    AC_MSG_RESULT(found)
		    found=1
		    break
		fi 
            done
        fi
        if test $found = 0 ; then
	    eval FORT_REAL$len=0
            eval FORT_COMPLEX$len2=0
            AC_MSG_RESULT(not supported)
        fi
    done
    AC_SUBST(FORT_INT1)
    AC_SUBST(FORT_INT2)
    AC_SUBST(FORT_INT4)
    AC_SUBST(FORT_INT8)
    AC_SUBST(FORT_INT16)
    AC_SUBST(FORT_REAL4)
    AC_SUBST(FORT_REAL8)
    AC_SUBST(FORT_REAL16)
    AC_SUBST(FORT_COMPLEX8)
    AC_SUBST(FORT_COMPLEX16)
    AC_SUBST(FORT_COMPLEX32)
#    if test "$fixupmpif" = "yes" ; then
#	if test ! -s include/mpif.h.orig ; then
#	    mv include/mpif.h include/mpif.h.orig
#	fi
#        sed -e 's/^C/\!/g' include/mpif.h.orig > include/mpif.h
#    fi
fi
#
# Check for Fortran 90
# Currently, we allow Fortran 90, but build for Fortran 77.  
# The following definitions must be provided for Fortran 90
# F90     - Name of F90 compiler
# F90INC  - How to specify include/use module directory (often -I<dir>)
# F90FLAGS - Flags to F90 for compilation
# F90LINKER - Name of F90 linker (often $F90)
# F90LIB_PATH - How to specify library search paths (often -L<dir>)
# If F90 is defined but not the other items, take them from the
#   Fortran 77 values
if test -z "$F90" ; then
    if test "$f90nag" = 0 ; then
    # Try to find an F90 compiler
    PAC_PROGRAMS_CHECK(F90,f90 xlf90)
    fi
fi
if test -n "$F90" ; then  
    F90_SUFFIX="f90"
    if test "$f90nag" = 0 ; then 
        if test -z "$USER_SET_F90INC" -a -z "$F90INC" ; then 
	    F90INC=$FINC
        fi
        if test -z "$USER_SET_F90FLAGS" -a -z "$F90FLAGS" ; then
	    # We should check these individually; at least things like
            # Fortran shared library flags.
	    F90FLAGS="$FFLAGS"
        fi
        if test -z "$USER_SET_F90LINKER" -a -z "$F90LINKER" ; then
	    F90LINKER="$F90"
        fi
	PAC_CHECK_F90_COMPILER_OK(,F90="")
    fi
    ## Remove all comments from mpif.h
    #if test ! -s include/mpif.h.orig ; then
    #    cp include/mpif.h include/mpif.h.orig
    #fi
    #/bin/rm -f include/mpif.h
    #sed -e 's/^C/\!/g' include/mpif.h.orig > include/mpif.h
fi
AC_SUBST(F90)
AC_SUBST(F90INC)
AC_SUBST(F90FLAGS)
AC_SUBST(F90LINKER)
AC_SUBST(F90LIB_PATH)
AC_SUBST(f90nag)
AC_SUBST(F90_SUFFIX)
#
# Check that the C compiler will generate code that will work with Fortran.
# Fortran requires that doubles be accessible on float/integer boundaries.
# The following C-only code attempts to test this by forcing accesses to
# doubles on an odd number int boundary.
#
# The test program can core dump.  To avoid having core files around,
# we create a non-writable core file
if test $HAS_FORTRAN != 0 ; then
    # If we're cross-compiling, we can't actually tell.  Be quiet and hope
    # for the best.
    touch core
    chmod a-w core
    CC_F77_SAFE=1
    AC_MSG_CHECKING([that C compiler allows unaligned doubles])
    PAC_TEST_PROGRAM([
void fetch_double();
int main( argc, argv )
int argc;
char **argv;
{
int p[4];
double *p_val;
fetch_double( (double *)&(p[0]) );
p_val = (double *)&(p[0]);
if (*p_val != 1.0) return 1;
fetch_double( (double *)&(p[1]) );
p_val = (double *)&(p[1]);
if (*p_val != 1.0) return 1;
return 0;
}
void fetch_double( v )
double *v;
{
*v = 1.0;
}
],CC_F77_SAFE=1,CC_F77_SAFE=0)
    if test $CC_F77_SAFE = 0 ; then 
        AC_MSG_RESULT(no!)
        print_error "Your C compiler $CC does not support unaligned accesses"
        print_error "to doubles.  This is required for interoperation with "
        print_error "Fortran (the Fortran standard requires it)."
        # See if the compiler is gcc and allows munaligned-doubles
        hasopt=0
        if test "$CC" = "gcc" ; then
            PAC_CHECK_COMPILER_OPTION(-munaligned-doubles,hasopt=1,hasopt=0)
            if test "$hasopt" = 1 ; then
		AC_MSG(Adding -munaligned-double to CFLAGS)
                CFLAGS="$CFLAGS -munaligned-doubles"
            fi
        fi
        if test "$hasopt" = 0 ; then
        print_error "Some C compilers support special options that allow"
	print_error "unaligned access; for gcc, try -munaligned-doubles."
	print_error "Configure will continue, but some Fortran programs"
	print_error "may fail.  Another option is to use a Fortran option"
	print_error "that forces all double precision quantities to be"
	print_error "double aligned; for SunOS, the option is -dalign."
        fi
    else
	AC_MSG_RESULT(yes)
    fi
    chmod +w core
    rm -f core
fi
# Check for byte ordering
PAC_WORDS_BIGENDIAN
#
# Check for xdr available and properly installed (our FreeBSD machines
# have incorrect xdr header files, for examples).  Currently, we just
# set a dummy function body and see if rpc/xdr.h is available and
# can be included.
#
# Just to complicate things, some systems have "xdr.h" that is complete
# and can be used by itself; more frequently, xdr.h does NOT include
# definitions that it requires!  rpc.h seems to be more reliable.
#
if test "$IS_HETERO" = 1 ; then
    AC_COMPILE_CHECK("XDR includes and functions",[#include <rpc/rpc.h>],[
    int a=1;
    ],HAS_XDR=1,HAS_XDR=0)
    if test "$HAS_XDR" = 1 ; then
	AC_DEFINE(HAS_XDR)
    else 
        print_error  "XDR not available on this system" 
    fi
fi
# Check for the functions that may be needed by the ADI to implement
# Processor_name.  Save these defines in a special place.
SAVEDEFS="$DEFS"
DEFS=""
AC_FUNC_CHECK(uname,AC_DEFINE(HAVE_UNAME)haveuname=1)
PAC_CHECK_HEADERS(netdb.h)
AC_FUNC_CHECK(gethostbyname,AC_DEFINE(HAVE_GETHOSTBYNAME)havegethostbyname=1)
if test -z "$havegethostbyname" ; then
    # Try again after adding libnsl.  We do it this way instead of just
    # testing for nsl because some systems (IRIX for one) generate many
    # warning messages when libnsl and libc are combined (!)
    AC_HAVE_LIBRARY(nsl,LIB_LIST="$LIB_LIST -lnsl";havelibnsl=1)
    if test "$havelibnsl" = 1 ; then
	echo "checking for gethostbyname in libnsl"
        AC_FUNC_CHECK(gethostbyname,AC_DEFINE(HAVE_GETHOSTBYNAME)havegethostbyname=1)
    fi
fi
# If we have uname and gethostbyname, we can skip getdomainname ...
if test "$haveuname" != 1 -o "$havegethostbyname" != 1 ; then
    AC_HAVE_FUNCS(gethostname sysinfo)
    #
    # systeminfo is needed for sysinfo 
    PAC_CHECK_HEADERS(sys/systeminfo.h)
    #
    # getdomainname is special BECAUSE IT MAY BE USELESS (!Network computing 
    # indeed - stuff like this is why Windows95/NT WILL WIN). 
    AC_CHECK_FUNC(getdomainname,has_getdomainname=1,has_getdomainname=0)
    if test $has_getdomainname = 1 -a $cross_compiling = 0 ; then
        PAC_PROGRAM_CHECK(has_domainname,domainname,1,0,d_domainname)
        PAC_PROGRAM_CHECK(has_hostname,hostname,1,0,d_hostname)
        PAC_PROGRAM_CHECK(has_rup,rup,1,0,d_rup)
        # Form hostname.domainname, do rup to it
        # rup may not be enabled, but short of running a program to lookup the
        # local host, there does not seem to be a better alternative.
        #
        if test $has_domainname = 1 -a $has_hostname = 1 -a $has_rup = 1 ; then
changequote(,)
            fullhost=`$d_hostname | sed -e 's/^\([^\.]*\)\..*/\1/'`
changequote([,])
#	    echo $fullhost
            fullhost="${fullhost}.`$d_domainname`"
            response=`($d_rup $fullhost 2>&1) | egrep '(Unknown host|translation failed)'`
#	    echo $fullhost
            if test -n "$response" ; then
   print_error "The getdomainname system routine has been rendered USELESS"
   print_error "on your system.  This is not a bug and will not affect"
   print_error "MPICH.  Some MPE routines (particularly those that"
   print_error "interact with X Windows) may not work."
            else
                AC_DEFINE(HAVE_GETDOMAINNAME)
	    fi
        fi
    fi
fi
GETNAME_DEFS="$DEFS"
DEFS="$SAVEDEFS"
#
# Check for message archive routines (to be used for internationalization)
#
SAVEDEFS="$DEFS"
DEFS=""
# 
# Some systems have these in /usr/xpg2lib/libxpg.a (our Suns did)
# The includes (for nl_types) might be in /usr/xpg2include 
# This hasn't been handled yet.
AC_HAVE_FUNCS(catopen catclose catgets)
# Will need to generate binary form of file
# !!! We have a report that on Cray, gencat is a completely different command
# (parallel fscks?).  We're supposed to use 
# caterr -c cat_file msg_file.  Instead, we'll skip it
if test -n "$device_td3" ; then 
 # May try caterr -c cat_file msg_file
 print_error "Configure needs the gencat program to generate message catalogs"
 print_error "Some (all?) Cray T3D systems have a program named gencat"
 print_error "that performs file system checks instead.  For this reason,"
 print_error "message catalogs will not be created for the T3D device."
 print_error "You may be able to use the caterr command instead."
 print_error "MPICH will work without the message catalogs (though the"
 print_error "ability to generate error messages in languages other than"
 print_error "US English will be lost)."
else
 PAC_PROGRAM_CHECK(has_gencat,gencat,1,0,d_gencat)
 if test $has_gencat = 1 ; then
    AC_DEFINE(HAVE_GENCAT)
    PAC_CHECK_HEADERS(nl_types.h)
    NLS_DEFS="$DEFS"
    # Generate the cataloge
    AC_MSG("Generating message catalogs")
    # WARNING: IRIX systems seem to use a DIFFERENT MESSAGE CATALOG FORMAT
    # AND (AS USUAL) MAY NOT WORK AS EXPECTED.  This is the "....cat.m" file.
    (cd src/env ; \
    for file in mpich.*.msg ; do \
	fileroot=`basename $file .msg` ; \
        /bin/rm -f $fileroot.cat $fileroot.cat.m ; \
        gencat $fileroot.cat $file > /dev/null 2>&1 ; \
        if test -s $fileroot.cat ; then \
	    /bin/rm -f ../../build/$ARCH/$fileroot.cat ; \
	    cp $fileroot.cat ../../build/$ARCH ; \
        fi ; \
        if test -s $fileroot.cat.m ; then \
	    /bin/rm -f ../../build/$ARCH/$fileroot.cat.m ; \
	    cp $fileroot.cat.m ../../build/$ARCH ; \
        fi ; \
    done \
    )
    if test -s src/env/mpich.En_US.cat ; then
	if test ! -s build/$ARCH/mpich.cat ; then
	   (cd build/$ARCH ; ln -s mpich.En_US.cat mpich.cat )
        fi
	AC_MSG_RESULT("done")
    else
	# You can't put a ; in the message (!)
        AC_MSG_RESULT("Could not create catalog. US English messages will be used")
    fi
 fi
fi
DEFS="$SAVEDEFS"
#
AC_STDC_HEADERS
SAVEDEFS="$DEFS"
DEFS=""
PAC_CHECK_HEADERS(stdlib.h string.h)
PAC_CHECK_HEADERS(unistd.h)
PAC_CHECK_HEADER(stdarg.h,[AC_DEFINE(HAVE_STDARG_H)
havestdarg=1])
#
# It isn't enough to check for stdarg.  Even gcc doesn't get it right;
# on some systems, the gcc version of stdio.h loads stdarg.h WITH THE WRONG
# OPTIONS (causing it to choose the OLD STYLE va_start etc).
#
if test -n "$havestdarg" ; then
    PAC_COMPILE_CHECK_FUNC(stdarg is correct,[
/* DEC Alpha compiler by default does NOT define __STDC__ but DOES
   accept prototypes */
#if !defined(__STDC__)
'bad text'
#endif
#include <stdio.h>
#include <stdarg.h>
int func( int a, ... ){
int b;
va_list ap;
va_start( ap, a );
b = va_arg(ap, int);
printf( "%d-%d\n", a, b );
va_end(ap);
fflush(stdout);
return 0;
}
int main() { func( 1, 2 ); return 0;}],
AC_DEFINE(USE_STDARG)
USER_CFLAGS="$USER_CFLAGS -DUSE_STDARG")
fi
PAC_MALLOC_RETURNS_VOID()
USER_DEFS="$USER_DEFS $DEFS"
DEFS="$SAVEDEFS $DEFS"
#
# System is used only in MPE; i860's do not support it.
AC_HAVE_FUNCS(system)
#
# Nice is used only in env/init.c
AC_HAVE_FUNCS(nice)
#
# Look for headers that might have memset()....
# (string.h might also, but it is also needed by MPE)
PAC_CHECK_HEADERS(memory.h)
#
# Turn off F77
# One problem with this is that some part of the ar will fail.  Lets hope
# it isn't fatal.  We've tried to fix this by defining MPI_FOBJECTS
# as the object files created from Fortran.
if test $NOF77 = 1 ; then
  F77="echo no Fortran compiler"
  FLINKER="$F77"
fi
#
#
# Check for erroneous C compilers
broken=0
do_test=1
if test $cross_compiling = 1 ; then
   if test "$CC" = mpcc ; then 
	TESTCC=xlc
   elif test "$CC" = mpCC ; then
        TESTCC=xlC
   else
        do_test=0
   fi
else 
    # If not cross compiling, testcc is just the compiler
    TESTCC="$CC"
fi
# 
# Should eventually use a file like $file.run to see if the program should
# be run or just compiled.  And eventually, this should be run EARLY,
# before checking for things like functions and include files.
#
PAC_CHECK_COMPILER_OK(cc_works=1,cc_works=0)
if test $cc_works = 0 ; then
    print_error "Could not compile a simple file with $CC!"
    print_error "Check for license and path restrictions on $CC."
    exit 1
fi
if test $NOF77 = 0 ; then
    PAC_CHECK_F77_COMPILER_OK(,NOF77=1;HAS_FORTRAN=0;HAS_F77=0;
       AC_DEFINE(MPID_NO_FORTRAN)
       dnl CFLAGS="-DMPID_NO_FORTRAN $CFLAGS"
       F77="echo no Fortran compiler"
       FLINKER="$F77"
       MPI_FOBJECTS="")
    # 
    # This test will allow us to make MPI_BOTTOM a 0 pointer on
    # some (many?) systems.  Currently here just for testing.
    if test $NOF77 = 0 ; then
        PAC_FORTRAN_HAS_POINTER(f77_pointer=1,f77_pointer=0)
    fi
    # In order to use the Fortran linker to with C programs, it may be
    # necessary to add some libraries from the C linker.  We HOPE that we
    # we can use the -v option with the compiler to extract the libraries
    # Code from /tmp/petsc/bin/findftnlibs ...
    # Create the sample programs
    #trap  '/bin/rm -f t1$$.c t1$$.f t1$$c t1$$u t1$$f t1$$.o t1$$' 0 2 3 10
    cat > t1$$.f <<EOF
      program main
      end
EOF
    cat > t1$$.c <<EOF
      int main() { return 0; }
EOF
    # Compile and link with the -v option; extract library options
    # Some compilers will generate multiple refs.  We may need to 
    # know about that, but for now, we depend on finding unique differences
    # We split on , as well as blank because some systems (AIX4) use exec 
    # notation with , separating args.
    # We can't split on , and blank, since for some systems (Solaris), the
    # comma is important in some options.
    # Rather, we try to identify
    # , separated: ... /bin/ld(ld,options,moreoptions)
    # blank separated: ... bin/ld option option ...
    $CC -o t1$$ -v t1$$.c 2>&1 | grep '/ld' > t1$$c1
    # 
    # Try to detect , separated form
    if grep 'ld,' t1$$c1 >/dev/null 2>&1 ; then
        cat t1$$c1 | tr ',' '\012' | \
            sed -n -e '/^-l/p' -e '/^-L/p' | \
  	    sed -e 's/^P,/-P,/g' | sort | uniq > t1$$c
    else
        cat t1$$c1 | tr ' ' '\012' | \
            sed -n -e '/^-l/p' -e '/^-L/p' | \
	    sed -e 's/^P,/-P,/g' | sort | uniq > t1$$c
    fi
    $F77 -o t1$$ -v t1$$.f 2>&1 | grep '/ld' > t1$$f1
    if grep 'ld,' t1$$f1 >/dev/null 2>&1 ; then
        cat t1$$f1 | tr ',' '\012' | \
            sed -n -e '/^-l/p' -e '/^-L/p' -e '/^P,/p' | \
	    sed -e 's/^P,/-P,/g' | sort | uniq > t1$$f
    else
        cat t1$$f1 | tr ' ' '\012' | \
            sed -n -e '/^-l/p' -e '/^-L/p' -e '/^P,/p' | \
	    sed -e 's/^P,/-P,/g' | sort | uniq > t1$$f
    fi

    # Now, remove common libraries/search paths
    cat t1$$c t1$$f | sort | uniq -u > t1$$u
    #
    # Finally, since the ORDER is important, we extract those lines from
    # the original t1$$f file
    #echo 'u'
    #cat t1$$u
    #echo 'f'
    #cat t1$$f
    #echo 'c'
    #cat t1$$c
    #set -x
    #echo 'results'
    foundany=0
    # Find lines in the C linker output that are not in the Fortran linker 
    # output
    for line in `cat t1$$c` ; do
        #line=`echo $line | sed -e 's/-/\\\\-/'`
        pureline=`echo $line | sed -e 's/-/./'`
#        if grep "'""$line\$""'" t1$$u 2>&1 >/dev/null ; then
        if grep "$pureline\$" t1$$u 2>&1 >/dev/null ; then
            # Special case: P,dirpath needs to be expanded
	    matchnum=`expr "$line" : '-P,'`
    	    if test "$matchnum" -eq 3 ; then
	        newline=`echo $line | sed -e 's/^-P,/-L/g' -e 's/:/ -L/g'`
	        line=$newline
            fi
	    $F77 -o t1$$ t1$$.f $line 2>&1 | grep 'undefined reference' > tout
	    if test ! -s tout ; then
	    	echo "Fortran linker needs $line"
           	FLIB_LIST="$FLIB_LIST $line"
            	foundany=1
	    else
	        print_error "$line which is in the C linker"
		print_error "does not work with Fortran programs and is not"
	        print_error "being added to the Fortran linker line.  This"
	        print_error "may cause problems when linking Fortran programs." 
	    fi
	    /bin/rm tout
        fi
    done
    /bin/rm -f t1$$.c t1$$.f t1$$c t1$$u t1$$f t1$$.o t1$$ t1$$c1 t1$$f1 tout

    # Add a test here for MPI_FINT
    PAC_FORTRAN_GET_INTEGER_SIZE(f_integer_size)
    if test "$f_integer_size" != "unavailable" ; then
	AC_MSG_CHECKING([for C integer type for MPI_Fint])
        AC_MSG_RESULT()
	for c_type in int long short "long long" ; do
	    PAC_GET_TYPE_SIZE($c_type,type_len)
            if test "$type_len" = "$f_integer_size" ; then
                MPI_FINT_FOUND=yes
		MPI_FINT=$c_type
	        break
	    fi
        done
        AC_MSG(C integer type for MPI_Fint is)
	if test "$MPI_FINT_FOUND" = yes ; then 
   	    AC_MSG_RESULT($MPI_FINT)
        else
	    AC_MSG_RESULT(could not find matching C type!)
	fi
    fi
fi

if test $do_test = 1 ; then
    PAC_CORRECT_COMPILER()
fi
#
if test "$RANLIB" != ":" ; then
    PAC_RANLIB_WORKS
fi
#
# Some Sun SOLARIS systems don't have AR (at least, not in a typical user
# path)
# Remove any arguments from the string AR
ARTEST=`expr "$AR" : "\(.*\) "`
PAC_PROGRAM_CHECK(ARFOUND,$ARTEST,1,,ARLOC)
if test -z "$ARLOC" ; then 
    # Check for /usr/ccs/bin/ar ; Solaris likes to hide anything remotely
    # useful in this directory
    print_error "The library archiver $AR is not in your path"
    print_error "MPICH cannot be built without this program, which"
    print_error "should be part of ANY program development environment."
    if test -x /usr/ccs/bin/ar ; then 
        print_error "You need /usr/ccs/bin in your path."
    else
        print_error "Check your path; contact your system vendor if your"
        print_error "path appears to be ok."
    fi
    exit 1
fi
#
#
# Check for long pointers.  All such options are placed into DEFS (see
# autoconf manual, AC _ DEFINE)
#
PAC_POINTER_64_BITS()
PAC_INT_LT_POINTER()
if test -n "$F77IDX" ; then
    AC_DEFINE(POINTER_64_BITS)
fi
dnl
PAC_GET_TYPE_SIZE(void *,address_size)
if test "$address_size" != "unknown" ; then
    AC_MSG_CHECKING([for C integer type for MPI_Aint])
    AC_MSG_RESULT()
    for c_type in int long short "long long" ; do
        PAC_GET_TYPE_SIZE($c_type,type_len)
        if test "$type_len" = "$address_size" ; then
            MPI_AINT_FOUND=yes
	    MPI_AINT=$c_type
            break
        fi
    done
    AC_MSG(C integer type for MPI_Aint is)
    if test "$MPI_AINT_FOUND" = yes ; then 
        AC_MSG_RESULT($MPI_AINT)
    else
        AC_MSG_RESULT(could not find matching C type!)
    fi
fi
# 
# Do not test 
# PROBLEM: ROMIO depends on long long in some cases.  For now, leave it
# outside the -no_short_longs test
PAC_LONG_LONG_INT()
if test "$NOSHORTLONGS" = 0 ; then
    # If not cross-compiling, we could dynamically check
    dnl The AC_LONG_DOUBLE macro is junk (it doesn't check that 
    dnl long double exists at all!
    PAC_LONG_DOUBLE()
    PAC_CHECK_SIZEOF(double,doublesize)
    PAC_CHECK_SIZEOF(long double,longdoublesize)
    if test $doublesize -eq $longdoublesize ; then
	# Suppress long double if == double?
	# NOSHORTLONGS=1
     print_error "If you get warning messages about long doubles not supported"
     print_error "on $ARCH, use the -no_short_longs argument to configure."
    fi
fi

#
# Check for structure alignment using util/structlayout.c
if test "$cross_compiling" = 0 ; then
   if test -n "$TESTCC" ; then
       CCsav="$CC"
       CC="$TESTCC"
   fi
   AC_MSG_CHECKING([for structure alignment])
   rm -f conftest*
   cat confdefs.h util/structlayout.c > conftest.c
   eval $compile
   if test ! -s conftest ; then
	AC_MSG_RESULT([Could not build executable program to test alignment])
   else
	if test -x conftest && (./conftest; exit) 1>conftestout ; then
	    if test -s conftestout ; then
  	        alignvalue=`cat conftestout`
            else
	        alignvalue="Unknown"
            fi
	    AC_MSG_RESULT($alignvalue)
	else
	    AC_MSG_RESULT(Execution of test program failed)
	fi
   fi
   rm -f conftest*
   if test -n "$TESTCC" ; then
       CC="$CCsav"
   fi
fi

#### was
#USER_CFLAGS="$CFLAGS $USER_DEFS"
# We must not make USER_CFLAGS all of CFLAGS...
USER_CFLAGS="$USER_CFLAGS $USER_DEFS"
#
dnl definitions should be passed to the configuration file
dnl CFLAGS="$CFLAGS $DEFS"
# We really should use MPICHCONF_H instead of CONFIG_H
CFLAGS="$CFLAGS -DHAVE_CONFIG_H -DHAVE_MPICHCONF_H"
#
if test $is_adi1 = 0 ; then
    AC_DEFINE(MPI_ADI2)
    dnl CFLAGS="$CFLAGS -DMPI_ADI2 -I../../mpid/ch2"
    dnl CFLAGS="$CFLAGS -I../../mpid/ch2 -I../../build/$ARCH/$DEVICE/include"
    # Don't include mpid/ch2 since that has default versions of the include
    # files.  If a device needs them, it should copy or link them into
    # its directory.
    CFLAGS="$CFLAGS -I../../build/$ARCH/$DEVICE/include"
    if test "$MEMDEBUG" = "1" ; then 
	AC_DEFINE(MPIR_MEMDEBUG)
	AC_DEFINE(MPIR_OBJDEBUG)
	dnl CFLAGS="$CFLAGS -DMPIR_MEMDEBUG -DMPIR_OBJDEBUG"
    fi
    if test "$TRDEBUG" = "1" ; then 
	AC_DEFINE(DEBUG_TRACE)
        dnl CFLAGS="$CFLAGS -DDEBUG_TRACE"
    fi
    if test "$PTRDEBUG" = 1 ; then 
	AC_DEFINE(MPIR_PTRDEBUG)
    fi
fi
if test $is_adi1 = 1 -a -z "$adi1_ok" ; then
    cat <<EOF
The MPICH implementation of MPI no longer supports the ADI-1 interface.
The supported devices are all ADI-2 interfaces (e.g., ch_p4, ch_shmem, 
ch_nx, etc.).  

All implementors that we know about are notified about changes in the MPICH
implementation.  If you are an implementor using MPICH, please let us know
about you so that we can add you to the list of MPICH developers.  Send
mail to mpi-bugs@mcs.anl.gov and asked to be added to the MPICH developers 
list.
EOF
    exit 1
fi

#if test -z "$PREFIX" ; then 
	LIB_PATH="-L$MPIR_HOME/build/$ARCH/$COMM/lib $LIB_PATH"
#else
#	LIB_PATH="-L$PREFIX/build/$ARCH/$COMM/lib $LIB_PATH"
#fi
#
# hpux's Fortran compiler f77 (but not the POSIX version fort77) does
# not accept -L <dir> for library search path.
# Eventually, we should check this to see if it works, not guess based on
# the system
FLIB_PATH_LEADER="-L"
FLIB_PATH="$FLIB_PATH $LIB_PATH"
if test "$F77" = "f77" -a \( -n "$arch_hpux" -o -n "$arch_sppux" \) ; then
   FLIB_PATH=`echo $FLIB_PATH | sed -e 's/-L/-Wl,-L,/g'`
   FLIB_PATH_LEADER="-Wl,-L,"
   FLIB_LIST=`echo $FLIB_LIST | sed -e 's/-L/-Wl,-L,/g'`
fi
#
if test -n "$F90" ; then
    if test -z "$USER_SET_F90LIB_PATH" -a -z "$F90LIB_PATH" ; then
	F90LIB_PATH="$FLIB_PATH"
    fi
fi
# Add any user libraries
if test -n "$USERLIB" ; then
    LIB_LIST="$LIB_LIST $USERLIB"
fi
#
# mpirun needs sync to try and fix NFS problems on some machines.  Some
# users may not have sync in their path, so we try to find it here.
SYNCLOC=""
PAC_PROGRAM_CHECK(SYNCFOUND,sync,1,,SYNCLOC)
if test -z "$SYNCLOC" ; then SYNCLOC=true ; fi
#
# Make this the default.  Eventually, use the --enable stuff to allow
# a user to turn this off.
AC_DEFINE(USE_BASIC_ALIGNMENT)
#
# if the device uses the machines file and there is no machines.$ARCH, 
# create one using hostname (or uname)
#
if test $DEVICE_KIND = network ; then
    if test ! -s util/machines/machines.$ARCH ; then
        HOST=""
        PAC_PROGRAM_CHECK(HOSTNAME_PGM,hostname,,,hostname)
        if test -x "$hostname" ; then
	    HOST="`$hostname`"
        fi
        # Note that uname -n may not produce a usable hostname.  
	# Any suggestions?
        if test "$HOST" = "" ; then
	    HOST="`uname -n`"
        fi
   	cat > util/machines/machines.$ARCH <<.
$HOST
$HOST
$HOST
$HOST
$HOST
.
	echo "Created util/machines/machines.$ARCH with five copies of $HOST"
	echo "You may want to edit this file to add and delete hosts"
	echo "(These hosts are used by mpirun.)"
    fi
fi
#
# Make sure that configure is group writable
#
chmod g+w configure > /dev/null 2>&1
#
# BASE_LIB_LIST lets us separate the MPI library from the other libs
BASE_LIB_LIST="$LIB_LIST"
# used to be LIB_LIST="$LIB_LIST -lmpi" I switched it, inspired by HPUX
LIB_LIST="-l$MPILIBNAME $LIB_LIST"
#
# Generate the name for the MPI-C, MPI-CC, and MPI-F77 compilers (for use
# in Makefiles that should not be MPICH dependent
MPICC=$MPIR_HOME/build/$ARCH/$DEVICE/bin/mpicc
if test $NOF77 = 0 ; then
	MPIF77=$MPIR_HOME/build/$ARCH/$DEVICE/bin/mpif77
else
	MPIF77=""
fi
MPIF90=$MPIR_HOME/build/$ARCH/$DEVICE/bin/mpif90
MPICPLUSPLUS=$MPIR_HOME/build/$ARCH/$DEVICE/bin/mpiCC
LIB_DIR=$MPIR_HOME/build/$ARCH/$DEVICE
#
# Some mpi2 commands supported (for the testing scripts)
HAS_MPI2=1
#
#  Configure ROMIO if specified
#
if test $ROMIO = 1 -a -d romio ; then
    # first test that romio will configure if on LINUX.
    # ROMIO uses this test for LINUX
    if test `bin/tarch` = "LINUX" ; then
	AC_MSG_CHECKING(that linux/nfs_fs.h is correct)
	AC_COMPILE_CHECK(,[
#include <sys/types.h>
#include <sys/vfs.h>
#include <linux/nfs_fs.h>],return 0;,,ROMIO=0)
	if test $ROMIO = 1 ; then
	    AC_MSG_RESULT(yes)
	else
	    AC_MSG_RESULT(no)
	    print_error "ROMIO cannot be built because linux/nfs_fs.h is broken"
	    print_error "Get an updated version of LINUX to fix this"
	fi
    fi
fi
if test $ROMIO = 1 -a -d romio ; then
  echo "Configuring ROMIO, for support of MPI-IO"
  (cd romio ; \
  ./configure -arch="$ARCH" -file_system="$FILE_SYSTEM" \
            -mpi=mpich -from_mpich \
	    -make="$MAKE" \
            -mpiincdir=$MPIR_HOME/include \
            -mpilib=$MPIR_HOME/build/$ARCH/$DEVICE/lib/lib$MPILIBNAME.a \
            -mpiolib=$MPIR_HOME/build/$ARCH/$DEVICE/lib/lib$MPILIBNAME.a \
            -cc="$CC" -cflags="$ROMIO_CFLAGS $CC_SHARED_OPT" \
            -fc="$FC" -fflags="$ROMIO_FFLAGS $FC_SHARED_OPT" -f90="$F90" $romio_config_args )
  /bin/rm -f include/mpio.h
  cp romio/include/mpio.h include
  ROMIO_LFLAGS="`$MAKE -f romio/Makefile romio_lflags`"
  ROMIO_TCFLAGS="`$MAKE -f romio/Makefile romio_tcflags`"
  ROMIO_TCPPFLAGS="`$MAKE -f romio/Makefile romio_tcppflags`"
  ROMIO_TFFLAGS="`$MAKE -f romio/Makefile romio_tfflags`"
  LIB_LIST="$LIB_LIST `$MAKE -f romio/Makefile romio_liblist`"
# mpif.h prepared for ROMIO at end of configure
  (cd examples; \rm -f io; ln -s ../romio/test io; \
   (cd test; \rm -f io; ln -s ../../romio/test io))
  echo "Finished configuring ROMIO"
fi
if test "$ROMIO" = 1 ; then
    NEWTESTDIRS="$NEWTESTDIRS io"
fi
#
# Substitute variables
# Variables used in scripts only
AC_SUBST(AUTOMOUNTFIX)dnl
if test -z "$RSHCOMMAND" ; then
    RSHCOMMAND=$rshcommand
fi
AC_SUBST(RSHCOMMAND)dnl
# FINC contains an @MPIR_HOME@, so it needs to come first
AC_SUBST(FINC)dnl
AC_SUBST(wishloc)dnl
AC_SUBST(TK_DIR)dnl
AC_SUBST(TCL_DIR)dnl
AC_SUBST(TK_VERSION)dnl
dnl not used AC_SUBST(BITMAP_DIR)dnl
AC_SUBST(SYNCLOC)dnl
# Variables defined ONLY for the doc/port file:
AC_SUBST(COMPRESSEDPKT)dnl
AC_SUBST(CONFIGURE_ARGS)dnl
AC_SUBST(CONFIGURE_ARGS_CLEAN)dnl
AC_SUBST(NODEVDEBUG)dnl
AC_SUBST(PKTSIZE)dnl
dnl AC_SUBST(PREALLOC)dnl
dnl AC_SUBST(PREPOST)dnl
dnl AC_SUBST(USERNDV)dnl
AC_SUBST(VARPKT)dnl
AC_SUBST(LIMITEDBUFFERS)dnl
AC_SUBST(ADI_COLLECTIVE)dnl
AC_SUBST(cross_compiling)dnl
# Variables used by Makefile.in's:
AC_SUBST(ASM)dnl
AC_SUBST(ASMFILES_O)dnl
AC_SUBST(AR)dnl
AC_SUBST(ARCH)dnl
AC_SUBST(BASE_LIB_LIST)dnl
AC_SUBST(BOPT)dnl
AC_SUBST(CC)dnl
AC_SUBST(CFLAGS)dnl
AC_SUBST(CLINKER)dnl
AC_SUBST(CCFLAGS)dnl
AC_SUBST(CCLINKER)dnl
AC_SUBST(COMM)dnl
AC_SUBST(CPP_COMPILER)dnl
AC_SUBST(CPP_DIR)dnl
AC_SUBST(CPPFLAGS)dnl
AC_SUBST(LDFLAGS)dnl
AC_SUBST(CPPLDFLAGS)dnl
AC_SUBST(CPRP)dnl
AC_SUBST(DEFAULT_MACHINE)dnl
AC_SUBST(DEVCFLAGS)dnl
AC_SUBST(DEVCFILES)dnl
AC_SUBST(DEVOFILES)dnl
AC_SUBST(DEV_DEFS)dnl
AC_SUBST(DEVICE)dnl
AC_SUBST(DEVICE_MAKE_INCLUDE)dnl
AC_SUBST(F77)dnl
AC_SUBST(FAST_COPY)dnl
AC_SUBST(FFLAGS)dnl
AC_SUBST(FLIB_PATH)dnl
AC_SUBST(FLIB_PATH_LEADER)dnl
AC_SUBST(FLIB_LIST)dnl
AC_SUBST(FLINKER)dnl
AC_SUBST(GETNAME_DEFS)dnl
AC_SUBST(HAS_FORTRAN)dnl
AC_SUBST(HAS_MPI2)dnl
AC_SUBST(ICCLIB)dnl    Used by -device=nx
AC_SUBST(INCLUDE_PATH)dnl
AC_SUBST(LIB_LIST)dnl
AC_SUBST(LIB_PATH)dnl
AC_SUBST(LIB_DIR)dnl
AC_SUBST(MAKE)dnl
AC_SUBST(MPE_DIR)dnl
AC_SUBST(MPE_MPI_EXT_C)dnl
AC_SUBST(MPE_MPI_EXT_O)dnl
MPICH_VERSION="MPICH $MPIVERSION"
dnl This is used to make sure that we get the correct mpirun.
AC_SUBST(MPICH_VERSION)dnl
AC_SUBST(MPIR_HOME)dnl
AC_SUBST(MPIFDEP)dnl
AC_SUBST(MPI_FOBJECTS)dnl
AC_SUBST(MPI_AINT)dnl
AC_SUBST(MPI_FINT)dnl
AC_SUBST(MPILIBNAME)dnl
AC_SUBST(MPICC)dnl
AC_SUBST(MPIF77)dnl
AC_SUBST(MPIF90)dnl
AC_SUBST(MPICPLUSPLUS)dnl
AC_SUBST(MEMDEBUG)dnl
AC_SUBST(GLOBUSDIR)dnl
AC_SUBST(NLS_DEFS)dnl
AC_SUBST(NEWTESTDIRS)dnl
AC_SUBST(OPTFLAGS)dnl
AC_SUBST(OPTFLAGSC)dnl
AC_SUBST(OPTFLAGSF)dnl
AC_SUBST(P4_ARCH)dnl
AC_SUBST(P4_DIR)dnl
AC_SUBST(RHS_COMMAND)dnl
# P4_MDEPCFLAGS now used only in doc/port.in
AC_SUBST(P4_MDEPCFLAGS)dnl
AC_SUBST(PREFIX)dnl
AC_SUBST(RANLIB)dnl
AC_SUBST(USER_CFLAGS)dnl
AC_SUBST(USER_INCLUDE_PATH)dnl
AC_SUBST(ROMIO)dnl
AC_SUBST(ROMIO_LFLAGS)dnl
AC_SUBST(ROMIO_TCFLAGS)dnl
AC_SUBST(ROMIO_TCPPFLAGS)dnl
AC_SUBST(ROMIO_TFFLAGS)dnl
AC_SUBST(buildcpp)dnl
AC_SUBST(NOF77)dnl
AC_SUBST(NOMPE)dnl
AC_SUBST(MPE_OPTS)dnl
AC_SUBST(JUMPSHOT_OPTS)dnl
#
# src/env/farg.f
# 
AC_SUBST(F77IARGC)dnl
AC_SUBST(F77GETARGDECL)dnl
AC_SUBST(F77GETARG)dnl
AC_SUBST(F90UNIX)dnl
# End configuration file
#
AC_OUTPUT(Makefile util/Makefile examples/Makefile examples/perftest/Makefile src/pt2pt/Makefile src/coll/Makefile src/context/Makefile src/dmpi/Makefile src/env/Makefile src/topol/Makefile src/profile/Makefile src/util/Makefile src/infoexport/Makefile examples/basic/Makefile src/misc2/Makefile src/external/Makefile )
#
# Once we've done one output of the header file, we don't need to do it
# again.  By defining the header as null, we hope to avoid messages about
# "mpichconf.h unchanged"
CONFIG_HEADERS=""
export CONFIG_HEADERS
PAC_OUTPUT_EXEC(util/mpicc util/mpiCC util/mpif77 util/mpif90 util/mpiinstall util/chkserv util/chkmachine, a+x )
PAC_OUTPUT_EXEC(include/mpidefs.h include/mpif.h,a+r)
/bin/rm -f build/$ARCH/$DEVICE/include/mpidefs.h
cp include/mpidefs.h build/$ARCH/$DEVICE/include/mpidefs.h
if test -n "$F90" ; then
    # Remove all comments from mpif.h
    /bin/rm -f include/mpif.h.copy
    cp include/mpif.h include/mpif.h.copy
    if test "$fixupmpif" = "no" ; then
	# Regular Fortran doesn't have ! for comments, so we just delete them
        sed -e '/^C/d' -e 's/\!.*$//g' include/mpif.h.copy > include/mpif.h
    else
        sed -e 's/^C/\!/g' include/mpif.h.copy > include/mpif.h
    fi
    /bin/rm -f include/mpif.h.copy
else
    # ROMIO might have added ! comments to mpif.h
    if test -z "$fixupmpif" -o "$fixupmpif" = "no" ; then
        /bin/rm -f include/mpif.h.copy
        cp include/mpif.h include/mpif.h.copy
	# Regular Fortran doesn't have ! for comments, so we just delete them
        sed -e '/^C/d' -e 's/\!.*$//g' include/mpif.h.copy > include/mpif.h
        /bin/rm -f include/mpif.h.copy
    fi
fi
/bin/rm -f build/$ARCH/$DEVICE/include/mpif.h

cp include/mpif.h build/$ARCH/$DEVICE/include/mpif.h
PAC_OUTPUT_EXEC(src/env/farg.f)
for file in mpicc mpiCC mpif77 mpif90 mpiinstall ; do
    if test -s util/$file ; then 
        rm -f bin/$file
	mv util/$file bin/$file
    fi
done
#
# Scripts in util: Copy to bin directory (for users of a single device/arch)
for src in mpicc mpiCC mpif77 mpif90 mpiinstall ; do 
  cp bin/$src build/$ARCH/$DEVICE/bin
done
#
# Configure the tests (now that the compiler scripts are built)
echo "Configuring the test suite..."
#echo "(cd examples/test ; ./configure -cc=$MPICC -fc=$MPIF77 -mpichpath=$MPIR_HOME/build/$ARCH/$DEVICE/bin )"
# Building a dummy library allows mpicc et al to build non-MPI programs
#built_dummy_lib=0
#set -x
#if test ! -s build/$ARCH/$DEVICE/lib/lib$MPILIBNAME.a ; then
#    $AR cr build/$ARCH/$DEVICE/lib/lib$MPILIBNAME.a /dev/null # >/dev/null 2>&1
#    built_dummy_lib=1
#fi
#set +x
unset CONFIG_FILES
if test "$HAS_F77" = "1" ; then
    ( cd examples/test ; ./configure -basecc="$CC" -cc="$MPICC" \
	 			     -basefc="$F77" -fc="$MPIF77" \
			     -mpichpath="$MPIR_HOME/build/$ARCH/$DEVICE/bin")
else
    ( cd examples/test ; ./configure -basecc="$CC" -cc="$MPICC" \
	 			     -basefc="$F77" -fc="$MPIF77" -nof77 \
			      -mpichpath="$MPIR_HOME/build/$ARCH/$DEVICE/bin")
fi
#if test $build_dummy_lib = 1 ; then
#    rm -f build/$ARCH/$DEVICE/lib/lib$MPILIBNAME.a
#fi
#
# Configure JUST the correct device file
CONFIG_FILES="mpid/$DEVICE/Makefile"
if test -f mpid/tests/Makefile.in ; then
    CONFIG_FILES="$CONFIG_FILES mpid/tests/Makefile"
fi
if test -n "$device_ch_shmem" ; then
    if test -s mpid/ch_shmem/p2ptest/Makefile.in ; then
        CONFIG_FILES="$CONFIG_FILES mpid/ch_shmem/p2ptest/Makefile"
    fi
fi
if test -n "$device_ch_tcp" -a -s mpid/ch_tcp/p3/Makefile.in ; then
    CONFIG_FILES="$CONFIG_FILES  mpid/ch_tcp/p3/Makefile"
fi
export CONFIG_FILES
${CONFIG_SHELL-/bin/sh} ./config.status
CONFIG_FILES=""
#
# Set the final choices of flags
#
# If the test suite is part of the directory, generate its makefiles
if test -d tsuite ; then
    CONFIG_FILES="tsuite/Makefile tsuite/coll/Makefile tsuite/pt2pt/Makefile tsuite/mpitc2/Makefile"
    export CONFIG_FILES
    ${CONFIG_SHELL-/bin/sh} ./config.status
fi
#
# If the bugs directory is available, generate its makefiles
if test -d bugs ; then
    CONFIG_FILES=""
    if test -s bugs/Makefile.in ; then
	CONFIG_FILES="bugs/Makefile.in"
    fi
    for dir in irecv fort sockperf srleak ssend testsendrecv wait ; do
	if test -s bugs/$dir/Makefile.in ; then
	    CONFIG_FILES="$CONFIG_FILES bugs/$dir/Makefile"
	fi
    done
    export CONFIG_FILES
    ${CONFIG_SHELL-/bin/sh} ./config.status
fi
#
# If the xmpi directory is available, generate its files
if test -d xmpi ; then 
    CONFIG_FILES="xmpi/buildinfo.tcl"
    export CONFIG_FILES
    ${CONFIG_SHELL-/bin/sh} ./config.status
fi
#
# If the mpich-ibm testsuite is available, generate its files
if test -d examples/test/mpitc ; then
    CONFIG_FILES="examples/test/mpitc examples/test/mpitc/ccl examples/test/mpitc/comm examples/test/mpitc/dtyp examples/test/mpitc/env examples/test/mpitc/group examples/test/mpitc/pt2pt examples/test/mpitc/topo"
    export CONFIG_FILES
    ${CONFIG_SHELL-/bin/sh} ./config.status
fi
#
# If the doc/port.in file is available, generate it
if test -f doc/port.in ; then
    PAC_OUTPUT_EXEC(doc/port doc/portbuild doc/portperf doc/porttest,a+x)
fi
#
# Remove the old config.status and copy new one; this allows mpireconfig to
# work with the current configuration.
# 
/bin/rm -f build/$ARCH/$DEVICE/bin/config.status
cp ./config.status build/$ARCH/$DEVICE/bin
#
# If we put the DEF values into this file, copy it to the library directory
# We also need the .in file for config.status (used by mpireconfig)
if test -f mpichconf.h ; then
    mv mpichconf.h build/$ARCH/$DEVICE/include
    cp mpichconf.h.in build/$ARCH/$DEVICE/include
fi
#
# add ROMIO part of mpif.h if it exists
if test -f romio/include/mpiof.h ; then
  echo "preparing mpif.h for ROMIO"
  cat include/mpif.h romio/include/mpiof.h > mpif-tmp.h
  rm -f include/mpif.h
  mv mpif-tmp.h include/mpif.h
  rm -f build/$ARCH/$DEVICE/include/mpif.h
  cp include/mpif.h build/$ARCH/$DEVICE/include/mpif.h
#else
#  echo "not preparing mpif.h for ROMIO"
fi
#
if test ! -f .mpich -a -z "$nobanner" ; then
  print_error "--->"
  print_error You should register your copy of MPICH with us by sending mail
  print_error to majordomo@mcs.anl.gov containing the message
  print_error subscribe mpi-users
  print_error This will allow us to notify you of new releases of MPICH.
  print_error " "
  print_error "You can also check the MPICH home page at "
  print_error "http://www.mcs.anl.gov/mpi/mpich/index.html"
  print_error "---< "
fi
#
# Issue warnings about multiple devices with same architecture
dev_count=0
for dir in build/$ARCH/*/include ; do
    if test -s $dir/mpidefs.h ; then 
        dev_count=`expr $dev_count + 1`
    fi
done
if test $dev_count -gt 1 ; then
    /bin/rm -f include/mpidefs.h
    # We need include/mpif.h for the build of files in env/*.f
    #/bin/rm -f include/mpif.h
    /bin/rm -f include/mpichconf.h
    echo "When building multiple MPICH devices for the same architecture"
    echo "make sure that you use the commands and mpidefs include file in"
    echo "build/$ARCH/$DEVICE/bin,include instead of bin/ and include/ ."
fi
echo 'Configuration completed.'
exit 0
